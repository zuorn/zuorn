<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Alacritty</title>
    <url>/year/01/20/Alacritty/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmtm45q5qaj31980ekdic.jpg" alt="image-20210120032619740"></p>
<h2 id="Alacritty-最快的终端模拟器"><a href="#Alacritty-最快的终端模拟器" class="headerlink" title="Alacritty 最快的终端模拟器"></a>Alacritty 最快的终端模拟器</h2><a id="more"></a>

<h3 id="为什么选择-Alacritty"><a href="#为什么选择-Alacritty" class="headerlink" title="为什么选择 Alacritty"></a>为什么选择 Alacritty</h3><p>Alacritty 将自己标榜为最快的终端模拟器。事实上它的确要比 iTerm2 流畅不少，这种情况尤其在使用 neovim 的时候明显。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Mac </span><br><span class="line">brew cask install alacritty</span><br><span class="line"></span><br><span class="line"># Ubuntu</span><br><span class="line">sudo apt install alacritty</span><br><span class="line"></span><br><span class="line"># Arch</span><br><span class="line">sudo pacman -S alacritty</span><br><span class="line"></span><br><span class="line"># Windows</span><br><span class="line">choco install alacritty</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>Alacritty 默认不会添加配置文件，需要自己手动添加。</p>
<ul>
<li>Linux &amp; Mac</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~&#x2F;.config&#x2F;alacritty&#x2F;alacritty.yml</span><br></pre></td></tr></table></figure>

<ul>
<li>Windows</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%APPDATA%\alacritty\alacritty.yml</span><br></pre></td></tr></table></figure>

<h3 id="我的配置"><a href="#我的配置" class="headerlink" title="我的配置"></a>我的配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">colors:</span><br><span class="line"></span><br><span class="line">  primary:</span><br><span class="line">    background: &quot;#1e2127&quot;</span><br><span class="line">    # background: &quot;#2E3440&quot;</span><br><span class="line">    foreground: &quot;#D8DEE9&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  normal:</span><br><span class="line">    black: &quot;#3B4252&quot;</span><br><span class="line">    red: &quot;#BF616A&quot;</span><br><span class="line">    green: &quot;#A3BE8C&quot;</span><br><span class="line">    yellow: &quot;#EBCB8B&quot;</span><br><span class="line">    blue: &quot;#81A1C1&quot;</span><br><span class="line">    magenta: &quot;#B48EAD&quot;</span><br><span class="line">    cyan: &quot;#88C0D0&quot;</span><br><span class="line">    white: &quot;#abb2bf&quot;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  bright:</span><br><span class="line">    black: &quot;#5c6370&quot;</span><br><span class="line">    red: &quot;#e06c75&quot;</span><br><span class="line">    green: &quot;#98c379&quot;</span><br><span class="line">    yellow: &quot;#d19a66&quot;</span><br><span class="line">    blue: &quot;#61afef&quot;</span><br><span class="line">    magenta: &quot;#c678dd&quot;</span><br><span class="line">    cyan: &quot;#56b6c2&quot;</span><br><span class="line">    white: &quot;#ECEFF4&quot;</span><br><span class="line"></span><br><span class="line">background_opacity: 1.0</span><br><span class="line"></span><br><span class="line"># 设置字体</span><br><span class="line">font:</span><br><span class="line">  normal:</span><br><span class="line">    family: &quot;Hack Nerd Font&quot;</span><br><span class="line">    style: Regular</span><br><span class="line">  bold:</span><br><span class="line">    family: &quot;Hack Nerd Font&quot;</span><br><span class="line">    style: Bold</span><br><span class="line">  italic:</span><br><span class="line">    family: &quot;Hack Nerd Font&quot;</span><br><span class="line">    style: Italic</span><br><span class="line">  bold_italic:</span><br><span class="line">    family: &quot;Hack Nerd Font&quot;</span><br><span class="line">    style: Bold Italic</span><br><span class="line"></span><br><span class="line">  # 字大小</span><br><span class="line">  size: 15.0 </span><br><span class="line"></span><br><span class="line">  offset:</span><br><span class="line">    x: 0</span><br><span class="line">    y: 0</span><br><span class="line">  glyph_offset:</span><br><span class="line">    x: 0</span><br><span class="line">    y: 0</span><br><span class="line"></span><br><span class="line">window:</span><br><span class="line">  padding:</span><br><span class="line">    x: 2</span><br><span class="line">    y: 2</span><br><span class="line"></span><br><span class="line">scrolling:</span><br><span class="line"># 回滚缓冲区中的最大行数,指定“0”将禁用滚动。</span><br><span class="line">  history: 10000</span><br><span class="line"></span><br><span class="line">  # 滚动行数 </span><br><span class="line"></span><br><span class="line">  multiplier: 10</span><br><span class="line"></span><br><span class="line"># 如果为‘true’，则使用亮色变体绘制粗体文本。</span><br><span class="line">draw_bold_text_with_bright_colors: true</span><br><span class="line"></span><br><span class="line">selection:</span><br><span class="line">  semantic_escape_chars: &#39;,│&#96;|:&quot;&#39;&#39; ()[]&#123;&#125;&lt;&gt;&#39;</span><br><span class="line">  save_to_clipboard: true</span><br><span class="line"></span><br><span class="line">live_config_reload: true</span><br><span class="line"></span><br><span class="line">key_bindings:</span><br><span class="line">  - &#123; key: V, mods: command, action: Paste &#125;</span><br><span class="line">  - &#123; key: C, mods: command, action: Copy &#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul>
<li><a href="https://github.com/alacritty/alacritty" target="_blank" rel="noopener">github：alacritty</a></li>
<li><a href="https://github.com/alacritty/alacritty/wiki/Color-schemes" target="_blank" rel="noopener">Color-schemes</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker学习笔记</title>
    <url>/year/04/06/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g36jt91zduj327w0r4168.jpg" alt=""></p>
<a id="more"></a>



<h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><ul>
<li>启动容器： <code>docker run -dit ubuntu</code></li>
<li>查看建立的容器： <code>dokcer inspect</code></li>
<li>自定义容器名：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dokcer run --name=自定义名 -i -t IMAGE /bin/bash</span><br></pre></td></tr></table></figure></li>
<li>重新启动停止的容器：<code>docker start [-i] 容器名</code>。 -i是以交互的方式启动停止的容器</li>
<li>删除已经停止的容器：<code>docker rm 容器名</code></li>
</ul>
<h3 id="守护式容器"><a href="#守护式容器" class="headerlink" title="守护式容器"></a>守护式容器</h3><blockquote>
<p>能够长期运行<br>没有交互式会话<br>适合运行应用程序和服务</p>
</blockquote>
<ul>
<li>以守护式运行容器：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">docker run -i -t IMAGE /bin/bash</span><br><span class="line">同时按ctrl+P和ctrl+q <span class="comment">//退出后容器在后台运行</span></span><br></pre></td></tr></table></figure>
<ul>
<li>附加到运行中的容器：<code>docker attach 容器名</code></li>
<li>启动守护式容器：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//-d 使用后台的方式来执行命令</span><br><span class="line">docker run -d 镜像名 [COMMAND] [ARG...]</span><br><span class="line">``` </span><br><span class="line">* 查看容器日志：</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">docker logs [-f] [-t] [--tail] 容器名</span><br><span class="line">	-f --follows=true|false 默认false</span><br><span class="line">	-t timestamps=true|false 默认false</span><br><span class="line">	--tail="all"</span><br></pre></td></tr></table></figure>

<ul>
<li>查看容器内进程：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">docker top 容器名</span><br></pre></td></tr></table></figure>

<ul>
<li>在运行中的容器内启动新进程：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">docker exec [-d] [-i] [-t] 容器名 [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>停止守护式容器：</p>
<p>  备注：重启容器后容器的ip和端口映射都会发生改变。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">docker stop 容器名 <span class="comment">//发送一个信号给容器，等待停止</span></span><br><span class="line">docker kill 容器名 <span class="comment">//直接停止容器</span></span><br></pre></td></tr></table></figure>

<h3 id="设置容器的映射端口"><a href="#设置容器的映射端口" class="headerlink" title="设置容器的映射端口"></a>设置容器的映射端口</h3><h4 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">run [-P] [-p]</span><br><span class="line"></span><br><span class="line"><span class="comment">//将为容器暴露的所有端口进行映射</span></span><br><span class="line">-P,publish-all=<span class="literal">true</span> | <span class="literal">false</span> 默认为<span class="literal">false</span></span><br><span class="line">	docker run -P -i-t ubuntu /bin/bash</span><br><span class="line">	</span><br><span class="line"><span class="comment">//指定映射端口</span></span><br><span class="line">-p,--publish=[]</span><br><span class="line"></span><br><span class="line">containerPort <span class="comment">//只制定容器的端口（宿主机的端口是随机映射的）</span></span><br><span class="line">	docker run -p <span class="number">8080</span>:<span class="number">80</span> -i -t ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line">hostPort:containnerPort <span class="comment">//同时指定宿主机的端口和容器的端口（一一对应）</span></span><br><span class="line">	docker run -p <span class="number">8080</span>:<span class="number">80</span> -i -t ubuntu /bin/bash</span><br><span class="line">	</span><br><span class="line">ip::containerPort <span class="comment">//指定ip和容器的端口</span></span><br><span class="line">	docker run -p <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">80</span> -i -t ubuntu /bin/bash</span><br><span class="line">	</span><br><span class="line">ip:hostPort:containerPort <span class="comment">//ip、宿主机端口和容器端口都进行指定</span></span><br><span class="line">	docker run -p <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8080</span>:<span class="number">80</span> -i -t ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="查看端口映射"><a href="#查看端口映射" class="headerlink" title="查看端口映射"></a>查看端口映射</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dokcer port 容器名</span><br></pre></td></tr></table></figure>

<h4 id="练习：在容器中部署静态网站"><a href="#练习：在容器中部署静态网站" class="headerlink" title="练习：在容器中部署静态网站"></a>练习：在容器中部署静态网站</h4><pre><code>//创建映射80端口的交互式容器
docker run -p 80 --name=web -i -t b2ab0ed558bb /bin/bash    
//安装Nginx
yum install -y nginx

//安装文本编辑器vim
yum install vim

//验证网站访问
docker port web //查看端口</code></pre><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><ul>
<li>列出镜像</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">docker images [OPTSIONS][REPOSITORY]</span><br><span class="line">		-a,--all=<span class="literal">false</span>  <span class="comment">//默认不显示中间层的镜像</span></span><br><span class="line">		-f,--filter=[]  <span class="comment">//显示时的过滤条件</span></span><br><span class="line">		--no-trunc=<span class="literal">false</span>  <span class="comment">//不使用截断的形式来显示数据（默认会截断唯一id）</span></span><br><span class="line">		-q,--quiet=<span class="literal">false</span>  <span class="comment">//只显示镜像的唯一id</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>镜像的仓库</p>
<p>REPOSITORY 仓库 镜像的集合</p>
</li>
<li><p>TAG 标签 默认使用latest标签</p>
</li>
<li><p>查看镜像的详细信息(inspect也支持容器的查看)</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">docker inspect [OPTIONS]CONTAINER|IMAGE[CONTAINER|IMAGE...]</span><br><span class="line">	-f,format=<span class="string">""</span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除镜像</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">docker rmi [OPTIONS]IMAGE[IMAGE...]</span><br><span class="line">	-f,--force=<span class="literal">false</span> 强制删除镜像</span><br><span class="line">	--no-prune=<span class="literal">false</span> 会保留被删镜像中被打标签的父镜像</span><br></pre></td></tr></table></figure>

<h3 id="获取和推送镜像"><a href="#获取和推送镜像" class="headerlink" title="获取和推送镜像"></a>获取和推送镜像</h3><ul>
<li>查找镜像<br>  Docker Hub<br>  <a href="https://registry.hub.docker.com" target="_blank" rel="noopener">https://registry.hub.docker.com</a></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">docker search [OPTIONS]TERM</span><br><span class="line">	--automated=<span class="literal">false</span></span><br><span class="line">	--no-trunc=<span class="literal">false</span> </span><br><span class="line">	-s,--stars=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>拉取镜像</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">docker pull [OPTIONS] NAME[:TAG]</span><br><span class="line">	-a,all-tags=<span class="literal">false</span> 下载全部标记的镜像</span><br></pre></td></tr></table></figure>
<ul>
<li>推送镜像</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">docker push NAME[:TAG]</span><br></pre></td></tr></table></figure>

<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><blockquote>
<p>保存对容器的修改，并再次使用<br>自定义镜像的能力<br>以软件的形式打包并分发服务及其运行环境</p>
</blockquote>
<ul>
<li>通过容器构建</li>
</ul>
<p>会暂停正在使用的容器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">	docker commit [OPTIONS] CONTAINER [REPOSITORY][:TAG]</span><br><span class="line">		-a,--author=<span class="string">""</span>  镜像的作者</span><br><span class="line">		-m,-message=<span class="string">""</span> 镜像构建的信息</span><br><span class="line">		-p,--pause=<span class="literal">true</span> 可以不暂停正在使用的容器</span><br><span class="line">	<span class="string">``</span><span class="string">`	</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* 通过Dockerfile文件构建</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	1. 创建Dockerfile文件</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	2. 运行docker build命令</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">	docker build [OPTIONS] PATH | URL | -</span><br><span class="line">		--force-rm=<span class="literal">false</span></span><br><span class="line">		--no-cache=<span class="literal">false</span></span><br><span class="line">		-pull==<span class="literal">false</span></span><br><span class="line">		-q,--quiet=<span class="literal">false</span></span><br><span class="line">		--rm=<span class="literal">true</span></span><br><span class="line">		-t,--tag=<span class="string">""</span></span><br></pre></td></tr></table></figure>

<h3 id="dockerC-S模式"><a href="#dockerC-S模式" class="headerlink" title="dockerC/S模式"></a>dockerC/S模式</h3><pre><code>![](https://ws4.sinaimg.cn/large/006tNc79ly1g1tbggmcy8j317s0nsnbb.jpg)</code></pre><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g1tbg4n0arj317e0e01ft.jpg" alt=""></p>
<h4 id="Remote-API"><a href="#Remote-API" class="headerlink" title="Remote API"></a>Remote API</h4><ul>
<li><p>RESTful风格API</p>
</li>
<li><p>STDIN、STDOUT、STDERR<br><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g1tbfr9f67j317g0ewx25.jpg" alt=""></p>
</li>
<li><p>Docker官方的Remote APO Reference:</p>
<p>  <a href="https://docs.docker.com/reference/api/docker_remote_api/" target="_blank" rel="noopener">https://docs.docker.com/reference/api/docker_remote_api/</a></p>
</li>
</ul>
<h4 id="连接方式（客户端与服务端的守护进程）"><a href="#连接方式（客户端与服务端的守护进程）" class="headerlink" title="连接方式（客户端与服务端的守护进程）"></a>连接方式（客户端与服务端的守护进程）</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g1tbf671nlj316o0c2qet.jpg" alt=""></p>
<ul>
<li>unix://var/run/docker.sock</li>
<li>tcp://host:port</li>
<li>fd://socketfd</li>
</ul>
<h3 id="Docker守护进程的配置和操作"><a href="#Docker守护进程的配置和操作" class="headerlink" title="Docker守护进程的配置和操作"></a>Docker守护进程的配置和操作</h3><ul>
<li>查看守护进程</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ps -ef |grep docker</span><br><span class="line">sudo status docker</span><br></pre></td></tr></table></figure>

<ul>
<li>使用service命令管理</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">启动</span><br><span class="line">sudo service docker start</span><br><span class="line"></span><br><span class="line">停止</span><br><span class="line">sudo service docker stop</span><br><span class="line"></span><br><span class="line">重启</span><br><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用ADB无线连接Android真机进行调试</title>
    <url>/year/01/05/ADB%E6%97%A0%E7%BA%BF%E8%BF%9E%E6%8E%A5Android%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p><img src="https://blog-1256335675.cos.ap-chengdu.myqcloud.com/2019-06-18-006tKfTcgy1fqa8x1kfm7j30gi08n74m.jpg" alt=""></p>
<a id="more"></a>

<h2 id="什么是-ADB"><a href="#什么是-ADB" class="headerlink" title="什么是 ADB?"></a>什么是 ADB?</h2><p>Android调试桥（ adb ）是一个开发工具，帮助安卓设备和个人计算机之间的通信。 这种通信大多是在USB电缆下进行，但是也支持Wi-Fi连接。 adb 还可被用来与电脑上运行的安卓模拟器交流通信。 adb 对于安卓开发来说就像一把“瑞士军刀”。</p>
<h2 id="通过-Homebrew-安装"><a href="#通过-Homebrew-安装" class="headerlink" title="通过 Homebrew 安装"></a>通过 Homebrew 安装</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">brew cask install android-platform-tools</span><br></pre></td></tr></table></figure>

<p>测试是否安装正常</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure>

<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul>
<li>手机和电脑处于同一个局域网内</li>
<li>电脑上已经安装好ADB工具</li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1、打开手机"><a href="#1、打开手机" class="headerlink" title="1、打开手机"></a>1、打开手机</h3><p>让手机在指定的端口可以接收到TCP/IP连接。</p>
<ol>
<li>确保手机开启了usb调试</li>
<li>用usb线把手机和电脑连接起来</li>
<li>执行命令：adb tcpip 5555</li>
</ol>
<p>执行成功后就可以把usb线拔掉了，端口可以不是5555，这个官方默认使用的。</p>
<h3 id="2、找到手机的的IP地址"><a href="#2、找到手机的的IP地址" class="headerlink" title="2、找到手机的的IP地址"></a>2、找到手机的的IP地址</h3><p>执行命令</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">adb connect <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span>:<span class="number">5555</span></span><br></pre></td></tr></table></figure>
<p>如果提示：</p>
<blockquote>
<p>connected to 192.160.1.100:5555</p>
</blockquote>
<p>则表示连接成功，如果端口号是5555可以省略，直接：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db connect <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span></span><br></pre></td></tr></table></figure>
<h3 id="如果没有连接成功"><a href="#如果没有连接成功" class="headerlink" title="如果没有连接成功"></a>如果没有连接成功</h3><p>如果确定你的网络和端口都没问题，可以尝试重启一下adb服务：</p>
<blockquote>
<p>adb kill-server</p>
</blockquote>
<p>然后再进行连接，实在还是不行就Google吧。</p>
<h3 id="连接成功"><a href="#连接成功" class="headerlink" title="连接成功"></a>连接成功</h3><p>如果连接成功的话，执行以下命令查看当前连接的设备列表：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure>
<p>可以看到连接的设备，像这样</p>
<blockquote>
<p>$ adb devices<br>List of devices attached<br>192.168.1.100:5555 device</p>
</blockquote>
<p>以后没有数据线也可以调试手机或者在上面运行自动化测试了。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>更换一个网络环境需要使用新IP重新connect即可。</li>
<li>但是如果手机重启了，就需要重新连接数据线再次开启端口。</li>
<li>开启端口可以通过adb，也可以直接在手机上打开，但一般需要root权限和特殊软件。</li>
</ol>
<p>原文地址：<a href="https://betacat.online/posts/2017-12-12/connect-adb-via-wifi/" target="_blank" rel="noopener">戳这里</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>EmacsVim 高效写作环境 | 像写代码一样优雅的写作</title>
    <url>/year/09/16/EmacsVim/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gini0f1grqj30gn0bcqd0.jpg" alt="image-20200912070945321 -w299"></p>
<blockquote>
<p>本质上讲，我们的工作是重复性的。不论是在几个不同的地方做相同的小改动，还是在文档的相似结构间移动，我们都会重复很多操作。凡是可以简化复杂性的方式，都会成倍的节省我们的时间。</p>
</blockquote>
<a id="more"></a>

<h2 id="Emacs-for-macOS"><a href="#Emacs-for-macOS" class="headerlink" title="Emacs for macOS"></a>Emacs for macOS</h2><ul>
<li>Control + a/e：光标移动到行首行尾。几乎等同于 Command (⌘)+ ←/→，但后者需要右手离开打字区。</li>
<li>Control + b/f/n/p ：左右上下移动光标。</li>
<li>Control + o/t : 新插入一行，将插入点后面的置于与插入点前面的字符交换。</li>
<li>Control + k/h/d ：删除插入点之后整行或整段内容，删除左边字符和删除右边字符。</li>
</ul>
<p>具体见下表：</p>
<table>
<thead>
<tr>
<th>键位</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Control–A</td>
<td>移至行或段落的开头。</td>
</tr>
<tr>
<td>Control–E</td>
<td>移至行或段落的末尾。</td>
</tr>
<tr>
<td>Control–F</td>
<td>向前移动一个字符。</td>
</tr>
<tr>
<td>Control–B</td>
<td>向后移动一个字符。</td>
</tr>
<tr>
<td>Control–L</td>
<td>将光标或所选内容置于可见区域中央。</td>
</tr>
<tr>
<td>Control–P</td>
<td>上移一行。</td>
</tr>
<tr>
<td>Control–N</td>
<td>下移一行。</td>
</tr>
<tr>
<td>Control–O</td>
<td>在插入点后新插入一行。</td>
</tr>
<tr>
<td>Control–T</td>
<td>将插入点后面的字符与插入点前面的字符交换。</td>
</tr>
<tr>
<td>Control-K</td>
<td>删除插入点与行或段落末尾处之间的文本。</td>
</tr>
<tr>
<td>Control-H</td>
<td>删除插入点左边的字符。也可以使用 Delete 键。</td>
</tr>
<tr>
<td>Control-D</td>
<td>删除插入点右边的字符。也可以使用 Fn-Delete。</td>
</tr>
<tr>
<td>参考<a href="https://support.apple.com/zh-cn/HT201236" target="_blank" rel="noopener">苹果官网</a></td>
<td></td>
</tr>
</tbody></table>
<p>需要注意的一点是，以上快捷键只在文稿编辑的时候才起作用，这无可厚非，但我还是希望方向键能在系统的任何地方使用，顺便映射了一下翻页键。</p>
<h3 id="翻页和左右键键位。"><a href="#翻页和左右键键位。" class="headerlink" title="翻页和左右键键位。"></a>翻页和左右键键位。</h3><table>
<thead>
<tr>
<th>键位</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>control+p</td>
<td>上</td>
</tr>
<tr>
<td>control+n</td>
<td>下</td>
</tr>
<tr>
<td>control+f</td>
<td>左</td>
</tr>
<tr>
<td>control+b</td>
<td>右</td>
</tr>
<tr>
<td>control+,</td>
<td>上翻页</td>
</tr>
<tr>
<td>control+.</td>
<td>下翻页</td>
</tr>
</tbody></table>
<h2 id="Vim-Mode-Plus"><a href="#Vim-Mode-Plus" class="headerlink" title="Vim Mode Plus"></a>Vim Mode Plus</h2><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>Vim Mode Plus 主要有两个模式，normal模式和 visual模式，其中normal模式下可以进行光标移动、删除复制粘贴等大部分操作；visual模式是自定义选中模式。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gimzz79twdj30jg0b2gmr.jpg" alt="image-20200911204545242"></p>
<h3 id="进入和退出-NORMAL-模式"><a href="#进入和退出-NORMAL-模式" class="headerlink" title="进入和退出 NORMAL 模式"></a>进入和退出 NORMAL 模式</h3><ul>
<li>通过以下方式进入</li>
<li><ul>
<li>Caps Lock</li>
<li>Left-Control + i</li>
</ul>
</li>
<li>通过以下方式退出:<ul>
<li>i、a</li>
<li>caps lock,</li>
<li>esc,</li>
<li>control+[,</li>
<li>单击鼠标任意按钮</li>
</ul>
</li>
</ul>
<h3 id="NORMAL-模式可用键位说明"><a href="#NORMAL-模式可用键位说明" class="headerlink" title="NORMAL 模式可用键位说明:"></a>NORMAL 模式可用键位说明:</h3><table>
<thead>
<tr>
<th>键位</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>h</td>
<td>向左移动光标</td>
</tr>
<tr>
<td>j</td>
<td>向下移动光标</td>
</tr>
<tr>
<td>k</td>
<td>向上移动光标</td>
</tr>
<tr>
<td>l</td>
<td>向右移动光标</td>
</tr>
<tr>
<td>e</td>
<td>将光标移动到下一个词尾</td>
</tr>
<tr>
<td>b</td>
<td>将光标移动到上一个词开头</td>
</tr>
<tr>
<td>0</td>
<td>将光标移动到行首（在任何选项卡之前）</td>
</tr>
<tr>
<td>^</td>
<td>将光标移动到行首（在任何标签之后）</td>
</tr>
<tr>
<td>$</td>
<td>将光标移到行尾</td>
</tr>
<tr>
<td>g,g</td>
<td>将光标移动到文档的开始</td>
</tr>
<tr>
<td>G</td>
<td>将光标移到文档末尾</td>
</tr>
<tr>
<td>{</td>
<td>将光标移到段落的开头</td>
</tr>
<tr>
<td>}</td>
<td>将光标移到段落末尾</td>
</tr>
</tbody></table>
<ul>
<li>注意：这些键位可与 shift，control，option和/或 command 配饰使用，例如 在 normal 模式下 Control + h/l 可以左右切换桌面。</li>
</ul>
<p><strong>删除组合键：</strong></p>
<table>
<thead>
<tr>
<th>键位</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>d,d / y,y / c,c</td>
<td>删除/复制/剪切整行</td>
</tr>
<tr>
<td>d,e / y,e / c,e</td>
<td>删除/复制/剪切到下一个词尾</td>
</tr>
<tr>
<td>d,b / … / …</td>
<td>删除/复制/剪切到单词的前一个开头</td>
</tr>
<tr>
<td>…</td>
<td>同上，适用于上述所有其他导航键</td>
</tr>
</tbody></table>
<p><strong>左右删除:</strong></p>
<table>
<thead>
<tr>
<th>键位</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>向右删除</td>
</tr>
<tr>
<td>X</td>
<td>向左删除</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>键位</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>p or P</td>
<td>粘贴到光标处</td>
</tr>
<tr>
<td>u</td>
<td>撤销</td>
</tr>
<tr>
<td>control+r</td>
<td>重做</td>
</tr>
</tbody></table>
<h3 id="在特定的位置退出正常模式"><a href="#在特定的位置退出正常模式" class="headerlink" title="在特定的位置退出正常模式:"></a>在特定的位置退出正常模式:</h3><table>
<thead>
<tr>
<th>键位</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>在光标处退出 NORMAL 模式</td>
</tr>
<tr>
<td>I</td>
<td>在行的开头退出 NORMAL 模式</td>
</tr>
<tr>
<td>A</td>
<td>在行尾退出 NORMAL 模式</td>
</tr>
<tr>
<td>o</td>
<td>在光标下方的新行上退出 NORMAL 模式</td>
</tr>
<tr>
<td>O</td>
<td>在光标上方的新行上退出 NORMAL 模式</td>
</tr>
</tbody></table>
<h3 id="VISUAL-模式可用键位说明"><a href="#VISUAL-模式可用键位说明" class="headerlink" title="VISUAL 模式可用键位说明"></a>VISUAL 模式可用键位说明</h3><p>  <strong>在 NORMAL 模式下，您可以通过 v 切换到 VISUAL 模式</strong>：</p>
<table>
<thead>
<tr>
<th>键位</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>v</td>
<td>退出 VISUAL 模式，进入   NORMAL 模式</td>
</tr>
<tr>
<td>h</td>
<td>向左选择</td>
</tr>
<tr>
<td>j</td>
<td>想下选择</td>
</tr>
<tr>
<td>…</td>
<td>同上，适用于上述所有其他导航键</td>
</tr>
<tr>
<td>d</td>
<td>删除 (“剪切”) 选择并进入 NORMAL 模式</td>
</tr>
<tr>
<td>y</td>
<td>选中 (“复制”) 所选内容并进入 NORMAL 模式</td>
</tr>
<tr>
<td>c</td>
<td>(“剪切”) 选择并完全退出 Vim 模式</td>
</tr>
<tr>
<td>x</td>
<td>删除选择并进入 NORMAL 模式</td>
</tr>
</tbody></table>
<h2 id="Mouse-keys-full"><a href="#Mouse-keys-full" class="headerlink" title="Mouse keys (full)"></a>Mouse keys (full)</h2><p>此模式可以模拟鼠标所有按键操作。可以通过 <code>left_option</code>进入，同时按下<code>left_option</code> + 其他组合键使用。</p>
<h3 id="键位绑定："><a href="#键位绑定：" class="headerlink" title="键位绑定："></a>键位绑定：</h3><table>
<thead>
<tr>
<th>键位</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>h:</td>
<td>向左移动光标</td>
</tr>
<tr>
<td>j:</td>
<td>向下移动光标</td>
</tr>
<tr>
<td>k:</td>
<td>向上移动光标</td>
</tr>
<tr>
<td>l:</td>
<td>向右移动光标</td>
</tr>
<tr>
<td>v:</td>
<td>鼠标左键</td>
</tr>
<tr>
<td>b:</td>
<td>中间键</td>
</tr>
<tr>
<td>n:</td>
<td>鼠标右键</td>
</tr>
<tr>
<td>f:</td>
<td>快速模式（通过f + hjkl快速移动鼠标）</td>
</tr>
<tr>
<td>d:</td>
<td>慢速模式（通过d + hjkl缓慢移动鼠标）</td>
</tr>
<tr>
<td>s:</td>
<td>滚动模式（按s + hjkl滚动）</td>
</tr>
</tbody></table>
<h2 id="使用我的配置"><a href="#使用我的配置" class="headerlink" title="使用我的配置"></a>使用我的配置</h2><ol>
<li><p>下载并安装 <a href="https://karabiner-elements.pqrs.org/" target="_blank" rel="noopener">karabiner-elements</a></p>
</li>
<li><p>备份默认配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mv ~&#x2F;.config&#x2F;karabiner&#x2F; karabiner.bak</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载此配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;zuorn&#x2F;EmacsVim ~&#x2F;.config&#x2F;karabiner</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 添加 SEO</title>
    <url>/year/12/19/Hexo-%E6%B7%BB%E5%8A%A0-SEO/</url>
    <content><![CDATA[<ul>
<li>站内地图<br>站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站</li>
</ul>
<a id="more"></a>

<ul>
<li>安装插件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>

<ul>
<li>_config.yml添加如下配置</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 自动生成sitemap</span><br><span class="line">sitemap:</span><br><span class="line">path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">baidu_path: baidusitemap.xml</span><br></pre></td></tr></table></figure>

<ul>
<li><p>修改 node_modules\hexo-generator-baidu-sitemap\baidusitemap.ejs<br>文件，将url换成自己的地址</p>
</li>
<li><p>修改 node_modules\hexo-generator-sitemap\sitemap.xml文件，将url换成自己的地址</p>
</li>
<li><p>编译blog</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>博客public目录生成sitemap.xml以及baidusitemap.xml就表示成功了。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客配置代码高亮</title>
    <url>/year/09/10/Hexo%E5%8D%9A%E5%AE%A2%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/</url>
    <content><![CDATA[<h4 id="博客根目录安装"><a href="#博客根目录安装" class="headerlink" title="博客根目录安装"></a>博客根目录安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -S hexo-prism-plugin --save</span><br></pre></td></tr></table></figure>
<h4 id="编辑-config-yml-默认true改成false-："><a href="#编辑-config-yml-默认true改成false-：" class="headerlink" title="编辑/_config.yml(默认true改成false)："></a>编辑/_config.yml(默认true改成false)：</h4><a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">highlight：</span><br><span class="line">   <span class="built_in">enable</span>：<span class="literal">false</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 编辑/_config.yml添加以下内容：</span></span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">prism_plugin:</span><br><span class="line">  mode: <span class="string">'preprocess'</span>    <span class="comment"># realtime/preprocess</span></span><br><span class="line">  theme: <span class="string">'default'</span></span><br><span class="line">  line_number: <span class="literal">false</span>    <span class="comment"># default false</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo常用命令</title>
    <url>/year/09/08/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo -g <span class="comment">#安装</span></span><br><span class="line">npm update hexo -g <span class="comment">#更新</span></span><br><span class="line">hexo init <span class="comment">#初始化</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo publish [layout] &lt;title&gt; <span class="comment">#发表草稿。</span></span><br></pre></td></tr></table></figure>

<h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo n <span class="string">"name"</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo g <span class="comment">#生成静态网页</span></span><br><span class="line">hexo p <span class="comment">#发表草稿。</span></span><br><span class="line">hexo s <span class="comment">#启动服务</span></span><br><span class="line">hexo d <span class="comment">#部署网站 参数：-g 部署之前先生成静态文件。</span></span><br></pre></td></tr></table></figure>

<h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><p> Hexo 3.0 把服务器独立成了个别模块，您必须先安装才能使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-server --save <span class="comment">#安装服务</span></span><br><span class="line">    </span><br><span class="line">hexo s <span class="comment">#启动服务</span></span><br><span class="line">hexo server -p 5000 <span class="comment">#更改端口</span></span><br><span class="line">hexo s -s <span class="comment">#静态模式</span></span><br><span class="line">hexo s -i 192.168.1.1 <span class="comment">#自定义ip</span></span><br><span class="line">    </span><br><span class="line">hexo clean <span class="comment">#清除缓存</span></span><br></pre></td></tr></table></figure>

<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><pre><code class="bash">hexo d -g
hexo g -d</code></pre>
<p>两者作用完全相同。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac OS安装 OpenCV(python3)</title>
    <url>/year/01/03/Mac-OS%E5%AE%89%E8%A3%85-OpenCV-python3/</url>
    <content><![CDATA[<p>运行命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install opencv3 --with-python3 --c++11 --with-contrib  </span><br><span class="line">brew link --force opencv3</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python3  </span><br><span class="line">Python <span class="number">3.5</span><span class="number">.1</span> (default, May <span class="number">20</span> <span class="number">2016</span>, <span class="number">12</span>:<span class="number">52</span>:<span class="number">19</span>)  </span><br><span class="line">[GCC <span class="number">4.2</span><span class="number">.1</span> Compatible Apple LLVM <span class="number">7.3</span><span class="number">.0</span> (clang<span class="number">-703.0</span><span class="number">.31</span>)] on darwin  </span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> cv2</span><br></pre></td></tr></table></figure>

<p>如果没有报错，说明安装成功了，恭喜你！先解释一下上面的命令<br>brew install opencv3 这条命令用来指明安装python3版本的，（有opencv ，opencv3两种python版本，前一种对应python2），<br>–with-python3用来告诉homebrew用来让opencv支持python3，</p>
<p>–c++11 用来告诉homebrew提供c++11支持，<br>–with-contrib 用来安装opencv的contrib支持。</p>
<p>如果上面的步骤进行之后，还是没有安装成功opencv（其实opencv已经安装了，只是没有正确的和python3关联起来），可以重新试一下下面的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew unlink opencv3 &amp;&amp; brew link --force opencv3</span><br></pre></td></tr></table></figure>

<p>再次试一下是否成功，如果成功了，恭喜你不用再往下面看了，如果没有成功，接着看，我们下面的任务就是正确地使python3和opencv关联起来。注意到我们上面使用homebrew安装了程序，homebrew安装的程序位置都在 下面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/usr/local/Cellar/</span><br></pre></td></tr></table></figure>

<p>所以我们需要找到的就是opencv的cv2*.so文件，（参考我前面ubuntu安装opencv最后也是关联cv2.so文件），最终我的so文件位置为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/usr/local/Cellar/opencv3/<span class="number">3.1</span><span class="number">.0</span>_4/lib/python3<span class="number">.5</span>/site-packages/cv2.cpython<span class="number">-35</span>m-darwin.so</span><br></pre></td></tr></table></figure>
<p>下面就是和python3环境关联，还有和虚拟virtualenv开发环境关联。<br>我关联的是虚拟环境，python实体环境也是同理，只要转到python3 的site-packages文件夹下面和原来上面的so建立一个软链接就行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cd /usr/local/lib/python3<span class="number">.5</span>/site-packages  </span><br><span class="line">ln -s /usr/local/Cellar/opencv3/<span class="number">3.1</span><span class="number">.0</span>_4/lib/python3<span class="number">.5</span>/site-packages/cv2.cpython<span class="number">-35</span>m-darwin.so cv2.so</span><br></pre></td></tr></table></figure>
<p>激活virtualenv虚拟环境，输入python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv2.__version__  </span><br><span class="line"><span class="string">'3.1.0'</span></span><br></pre></td></tr></table></figure>
<p>运行以下命令，则说明安装成功。</p>
<p>参考：<a href="https://gravityjack.com/news/opencv-python-3-homebrew/" target="_blank" rel="noopener">戳这里</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown入门</title>
    <url>/year/09/08/Markdown%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">Markdown</a>是一种<a href="https://zh.wikipedia.org/wiki/%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">轻量级标记语言</a>，它的优点在于易于阅读、易于撰写的纯文字格式， 并且可以自由转换成多种格式。目前也被越来越多的写作爱好者，撰稿者广泛使用。</p>
</blockquote>
<a id="more"></a>

<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Markdown旨在尽可能容易阅读和易于写入。</p>
<p>然而，可读性首先被强调。标记格式的文档应该按照原样发布，而不是像标签或格式化说明一样标记。虽然Markdown的语法受到几个现有的文本到HTML过滤器的影响，包括Setext，atx，Textile，reStructuredText， Grutatext和EtText - Markdown语法的最大灵感来源是纯文本电子邮件的格式。</p>
<p>为此，Markdown的语法完全由标点符号组成，标点符号被仔细选择，看起来就像它们的意思。例如，一个字上的星号实际上看起来像<em>强调</em>。标记列表看起来好像列表。</p>
<h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><p>Markdown作为一种轻量级标记语言，它的语法简洁明了、学习起来容易。</p>
<p>参考：<br><a href="https://daringfireball.net/projects/markdown/syntax" target="_blank" rel="noopener">官方说明</a><br><a href="http://wowubuntu.com/markdown/#list" target="_blank" rel="noopener">Markdown 中文版语法说明 </a></p>
<h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line"># 第一级标题</span><br><span class="line">## 第二级标题</span><br><span class="line">###### 第六级标题</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<h1 id="第一级标题"><a href="#第一级标题" class="headerlink" title="第一级标题"></a>第一级标题</h1><h2 id="第二级标题"><a href="#第二级标题" class="headerlink" title="第二级标题"></a>第二级标题</h2><h6 id="第六级标题"><a href="#第六级标题" class="headerlink" title="第六级标题"></a>第六级标题</h6><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">*这些文字会生成*</span><br><span class="line">_这些文字会生成<span class="string">`_</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**这些文字会生成**</span></span><br><span class="line"><span class="string">__这些文字会生成`</span>__</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><em>这些文字会生成</em><br><em>这些文字会生成`</em></p>
<p><strong>这些文字会生成</strong><br><strong>这些文字会生成`</strong></p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">* 列表一</span><br><span class="line">* 列表二</span><br><span class="line">* 列表三</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<ul>
<li>列表一</li>
<li>列表二</li>
<li>列表三</li>
</ul>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 列表一</span><br><span class="line"><span class="number">2.</span> 列表二</span><br><span class="line"><span class="number">3.</span> 列表三</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<ol>
<li>列表一</li>
<li>列表二</li>
<li>列表三</li>
</ol>
<h3 id="任务列表（Task-lists）"><a href="#任务列表（Task-lists）" class="headerlink" title="任务列表（Task lists）"></a>任务列表（Task lists）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">- [ ] 任务一 未做任务</span><br><span class="line">- [x] 任务二 已做任务</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<ul>
<li><input disabled="" type="checkbox"> 任务一 未做任务</li>
<li><input checked="" disabled="" type="checkbox"> 任务二 已做任务</li>
</ul>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">![图片名称](地址)</span><br></pre></td></tr></table></figure>

<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[名称](链接地址)</span><br></pre></td></tr></table></figure>
<h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">某某说:</span><br><span class="line">&gt; balabala</span><br></pre></td></tr></table></figure>
<p>效果：<br>某某说:</p>
<blockquote>
<p>balabala</p>
</blockquote>
<h2 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`代码`</span></span><br></pre></td></tr></table></figure>
<p>效果如下：<br><code>代码</code></p>
<h2 id="多行或者一段代码"><a href="#多行或者一段代码" class="headerlink" title="多行或者一段代码"></a>多行或者一段代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">代码段</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">代码段</span><br></pre></td></tr></table></figure>

<h2 id="顺序图或流程图"><a href="#顺序图或流程图" class="headerlink" title="顺序图或流程图"></a>顺序图或流程图</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">张三-&gt;李四: 嘿，小四儿, 你妈喊你回家吃饭呢！</span><br><span class="line">Note right of 李四: 李四愣了一下，说：</span><br><span class="line">李四--&gt;张三: 哦，知道啦！</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line">op&#x3D;&gt;operation: 我的操作</span><br><span class="line">cond&#x3D;&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure></code></pre><p>效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">张三-&gt;李四: 嘿，小四儿, 你妈喊你回家吃饭呢！</span><br><span class="line">Note right of 李四: 李四愣了一下，说：</span><br><span class="line">李四--&gt;张三: 哦，知道啦！</span><br></pre></td></tr></table></figure>

<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><p>Markdown 语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">表头一 | 表头二</span><br><span class="line">--------- | -------------</span><br><span class="line">第一列第一格 | 格第二列第一格</span><br><span class="line">第一列第二格 | 格第二列第二格</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<table>
<thead>
<tr>
<th>表头一</th>
<th>表头二</th>
</tr>
</thead>
<tbody><tr>
<td>第一列第一格</td>
<td>格第二列第一格</td>
</tr>
<tr>
<td>第一列第二格</td>
<td>格第二列第二格</td>
</tr>
</tbody></table>
<h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">~~删除这些~~</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><del>删除这些</del></p>
<h4 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h4><p>以下三种方式都可以生成分隔线：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">- - -</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<hr>
<hr>
<hr>
<h4 id="脚注（Footnote）"><a href="#脚注（Footnote）" class="headerlink" title="脚注（Footnote）"></a>脚注（Footnote）</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">这是一个脚注：[^sample_footnote]</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p>这是一个脚注：<a href="这里是脚注信息">^sample_footnote</a></p>
<h2 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h2><p>常见的Markdown工具有<a href="https://ulyssesapp.com/" target="_blank" rel="noopener">Ulysses</a>，<a href="http://25.io/mou/" target="_blank" rel="noopener">Mou</a>，<a href="http://www.sublimetext.com/3" target="_blank" rel="noopener">Sublime Text 3</a>等等。</p>
<p>个人比较喜欢<a href="https://itunes.apple.com/cn/app/mweb-%E4%B8%93%E4%B8%9A%E7%9A%84markdown%E5%86%99%E4%BD%9C-%E8%AE%B0%E7%AC%94%E8%AE%B0-%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%94%9F%E6%88%90%E8%BD%AF%E4%BB%B6/id954188948?mt=12" target="_blank" rel="noopener">mweb</a>，几乎所有的语法都有对应的快捷键，而且还能一键生成&amp;上传至博客。</p>
<p>具体使用方法见<a href="http://zh.mweb.im/help.html" target="_blank" rel="noopener">官方文档</a>。</p>
<p>另外还有一个<a href="https://itunes.apple.com/cn/app/mweb-lite-%E4%B8%93%E4%B8%9A%E7%9A%84markdown%E5%86%99%E4%BD%9C%E8%BD%AF%E4%BB%B6/id979033429?mt=12" target="_blank" rel="noopener">免费版的</a>，<br><img src="http://ovlnt0xy1.bkt.clouddn.com/mweb.png" alt=""></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Next主题指定文章隐藏侧栏</title>
    <url>/year/01/22/Next%E4%B8%BB%E6%8E%A8%E6%8C%87%E5%AE%9A%E6%96%87%E7%AB%A0%E9%9A%90%E8%97%8F%E4%BE%A7%E6%A0%8F/</url>
    <content><![CDATA[<h4 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h4><p>可能你需要加一个单独的页面，比如about页面，希望隐藏next主题的侧栏，那么请看下去。</p>
<a id="more"></a>

<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>根据<a href="https://github.com/iissnan/hexo-theme-next/issues/943" target="_blank" rel="noopener">issues-943</a>找到了my-project/themes/next/layout/_marcro/sidebar.swig中找到下一列信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">set</span> display_toc = is_post and theme.toc.enable or is_page and theme.toc.enable %&#125;</span><br></pre></td></tr></table></figure>

<p>修改为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">set</span> display_toc = is_post and theme.toc.enable and !page.no_toc or is_page and theme.toc.enable and !page.no_toc %&#125;</span><br></pre></td></tr></table></figure>


<p>这样你就可以在不想要显示目录的文章头部加一行：<code>no_toc: true</code>即可。</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>cvim</title>
    <url>/year/09/09/cvim/</url>
    <content><![CDATA[<blockquote>
<p>当我在填写网页内容的时候，我的手不得不从鼠标和键盘上来回切换，于是我开始寻找解决这个问题的办法，<a href="https://chrome.google.com/webstore/detail/cvim/ihlenndgcmojhcghmfjfneahoeklbjjh" target="_blank" rel="noopener">cvim</a>很好的解决了这个问题。</p>
</blockquote>
<a id="more"></a>

<h3 id="什么是cvim？"><a href="#什么是cvim？" class="headerlink" title="什么是cvim？"></a>什么是<a href="https://chrome.google.com/webstore/detail/cvim/ihlenndgcmojhcghmfjfneahoeklbjjh" target="_blank" rel="noopener">cvim</a>？</h3><p>cvim适用于<a href="https://www.google.com/chrome/index.html" target="_blank" rel="noopener">Google Chrome</a>的<a href="https://vim.sourceforge.io/download.php" target="_blank" rel="noopener">Vim</a>。</p>
<h4 id="作者的话："><a href="#作者的话：" class="headerlink" title="作者的话："></a>作者的话：</h4><blockquote>
<p>我讨厌使用鼠标，尤其是在学习Vim之后。使用我的桌面（Linux），我有很多键绑定，使事情变得更容易：我用Alt + w打开Chrome，我用Alt + Shift + d关闭一个窗口，我打开一个Alt + t的终端。这对Chrome很难处理，因为它没有自定义键盘快捷键的部分，但仍然需要使用鼠标来执行点击链接。 cVim旨在尽可能地消除此问题，Chrome扩展API将允许它。</p>
</blockquote>
<h3 id="cvim的优势是什么？"><a href="#cvim的优势是什么？" class="headerlink" title="cvim的优势是什么？"></a>cvim的优势是什么？</h3><ul>
<li>支持自定义搜索引擎</li>
<li>支持插入符/Visual模式 （！！超赞有木有！！）</li>
<li>支持正则表达式！！</li>
<li>命令支持tab补全！</li>
<li>支持自定义键映射！！（也就是你可以自己写vimrc，这才是完整的vim好不好！！可以备份到github）</li>
<li>自定义命令</li>
</ul>
<h3 id="如何获取cvim"><a href="#如何获取cvim" class="headerlink" title="如何获取cvim"></a>如何获取cvim</h3><p><a href="https://chrome.google.com/webstore/category/extensions" target="_blank" rel="noopener">chrome web sotre</a>搜索<a href="https://chrome.google.com/webstore/detail/cvim/ihlenndgcmojhcghmfjfneahoeklbjjh" target="_blank" rel="noopener">cvim</a>安装即可，或者点击本文<a href="https://chrome.google.com/webstore/detail/cvim/ihlenndgcmojhcghmfjfneahoeklbjjh" target="_blank" rel="noopener">cvim</a>直接安装。</p>
<h3 id="cvim用法："><a href="#cvim用法：" class="headerlink" title="cvim用法："></a>cvim用法：</h3><p>我这里分别从正常模式、链接提示、标签栏导航、视觉／插入模式、命令模式说明。</p>
<h4 id="正常模式："><a href="#正常模式：" class="headerlink" title="正常模式："></a>正常模式：</h4><ul>
<li>j， s 向下滚动</li>
<li>k， w 向上滑动</li>
<li>h 向左滚动</li>
<li>l 向右滚动</li>
<li>d 滚动一半页面</li>
<li>u， e 滚动一半页面</li>
<li>gg 滚动到页面顶部</li>
<li>G 滚动到页面的底部</li>
<li>gi 转到第一个输入框</li>
<li>gI 转到最后一个输入框</li>
</ul>
<h4 id="链接提示："><a href="#链接提示：" class="headerlink" title="链接提示："></a>链接提示：</h4><ul>
<li>f 打开当前选项卡中的链接</li>
<li>F 在新标签页中打开链接</li>
<li>W 在新窗口中打开链接</li>
<li>A 重复最后提示命令</li>
<li>q 触发悬停事件</li>
<li>Q 触发不起眼的事件</li>
<li>mf 打开多个链接</li>
<li>gy 从链接复制URL到剪贴板</li>
<li>yy 将当前页面的URL复制到剪贴板</li>
<li>yY 将当前帧的URL复制到剪贴板</li>
</ul>
<h4 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h4><ul>
<li>: 打开命令栏</li>
<li>/ 打开搜索栏</li>
<li>? 打开搜索栏（反向搜索）</li>
<li>I 搜索浏览器历史记录</li>
<li>zr 重新启动Google Chrome</li>
<li>i 进入插入模式</li>
<li>r 重新加载当前选项卡（刷新）</li>
<li>gR 重新加载当前选项卡+本地缓存</li>
<li>z<Enter> 切换图像缩放（与仅在图像页面上单击图像相同）</li>
<li>yh 从查找模式复制当前匹配的文本（如果有）</li>
<li>b 搜寻书签(相当于命令:bookmarks）</li>
<li>p 打开剪贴板选择</li>
<li>gj 隐藏下载栏</li>
<li>gq 停止加载当前选项卡</li>
<li>gQ 停止加载所有标签</li>
</ul>
<h4 id="标签导航："><a href="#标签导航：" class="headerlink" title="标签导航："></a>标签导航：</h4><ul>
<li>gt，K，R 导航到下一个选项卡</li>
<li>gT，J，E 导航到上一个选项卡</li>
<li>g0， g$ 转到第一个/最后一个选项卡</li>
<li>x 关闭当前选项卡</li>
<li>X 打开最后关闭的标签页</li>
<li>H， S 返回上一个标签</li>
<li>L， D 前进下一个标签</li>
<li>B 搜索另一个活动选项卡</li>
<li>&lt; 向左移动当前标签</li>
<li><blockquote>
<p>向右移动当前标签</p>
</blockquote>
</li>
<li>查找模式(/进入）：</li>
<li>n 下一个搜索结果</li>
<li>N 以前的搜索结果</li>
<li>v 进入视觉/插入模式（突出显示当前搜索/选择）</li>
<li>V 从插入模式/当前突出显示的搜索进入视线模式</li>
</ul>
<h4 id="视觉／插入模式（i插入、v视觉）："><a href="#视觉／插入模式（i插入、v视觉）：" class="headerlink" title="视觉／插入模式（i插入、v视觉）："></a>视觉／插入模式（i插入、v视觉）：</h4><ul>
<li><Esc> 将视觉模式退出插入模式/退出插入模式到正常模式</li>
<li>v 在视觉/插入模式之间切换</li>
<li>h，j，k，l 移动插入位置/扩展视觉选择</li>
<li>y 配合当前的选择</li>
<li>n 选择下一个搜索结果</li>
<li>N 选择先前的搜索结果</li>
<li>p 打开当前选项卡中的突出显示</li>
<li>P 在新标签中打开突出显示的文本</li>
</ul>
<h4 id="命令模式-打开命令栏）："><a href="#命令模式-打开命令栏）：" class="headerlink" title="命令模式(:打开命令栏）："></a>命令模式(:打开命令栏）：</h4><ul>
<li>. 重复最后一个命令</li>
<li>:new url 打开一个新窗口</li>
<li>:bookmarks url  从书签中打开一条新的标签</li>
<li>:open url 打开一个新标签</li>
<li>:history url 打开一条历史标签</li>
<li>:quit 关闭当前标签</li>
<li>:qall 关闭当前窗口（注意：是关闭当前的窗口，不是关闭标签)</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>把”时间“变成”历史“</title>
    <url>/year/07/05/Time-becomes-History/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggg0zcma45j30sr0c0kb8.jpg" alt=""></p>
<a id="more"></a>

<h5 id="选择不等于自由"><a href="#选择不等于自由" class="headerlink" title="选择不等于自由"></a>选择不等于自由</h5><p>当我们在面临一个选择的时候，有两种状况。 第一，当我们不得不接受某种约束，而只能在各种无聊的事情中进行选择的时候，这种伪自由的选择或者是迫于生存的压力，或者是受治于规章制度，其实都是不自由的体现。 而另一种状况就是自暴自弃、无所事事，或者说是顺其自然，结果都是不自由。 试想这样一种社会，它给予每个个体前所未有的选择的权利，可供选择的行动却糟糕透顶。于是选择只有上述两种状况：“不得不”和“自暴自弃”。 </p>
<h5 id="个体存在的历史性"><a href="#个体存在的历史性" class="headerlink" title="个体存在的历史性"></a>个体存在的历史性</h5><p>在我们的生活当中，我们不免有许多选择的时刻，比如为了温饱而选择一份按部就班的工作。这样选择的结果，这种按部就班的行动实际只占用“时间”，而不能成为我们自己的“历史”。 人的生活本意不是准备这样度过的，自由不是用来糊弄过时间的，自由的价值就在于把“时间”变成“历史”，而人也只有当他把属于他的时间变成历史，这个人才能真正作为一个人存在。如果存在没有历史性，那只不过是一种自然存在。 </p>
<h5 id="“螺丝钉”的危险性"><a href="#“螺丝钉”的危险性" class="headerlink" title="“螺丝钉”的危险性"></a>“螺丝钉”的危险性</h5><p>现代社会的危险性在于：它以一种非惩罚性的方式，或不太令人反感而把人标准化，使人成为产品，从而剥夺人的真正自由。 </p>
<h5 id="自由不是价值和目的。"><a href="#自由不是价值和目的。" class="headerlink" title="自由不是价值和目的。"></a>自由不是价值和目的。</h5><p>自由本身不是价值和目的，而是价值和目的的前提。因此，当自由被用来追求各种价值时，那些追求的价值的活动，有相当大的一部分是互相冲突的，这就是说自由本身虽是无矛盾的，但自由的活动却是有矛盾的。</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 安装和配置加速</title>
    <url>/year/04/06/docker-anzhuang/</url>
    <content><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g36jt91zduj327w0r4168.jpg" alt=""></p>
<a id="more"></a>

<p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p>
<p>Docker CE 分为 stable, test, 和 nightly 三个更新频道。每六个月发布一个 stable 版本 (18.09, 19.03, 19.09…)。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Docker有多种安装方式本人推荐 Mac OS 和 windows 通过下载安装包安装，Linux使用官方的shell脚本安装。</p>
<h4 id="Linux安装："><a href="#Linux安装：" class="headerlink" title="Linux安装："></a>Linux安装：</h4><p>获取最新版本的 Docker 安装包并执行安装：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wget -qO- https:<span class="comment">//get.docker.com/ | sh</span></span><br></pre></td></tr></table></figure>

<p>启动 docker 服务：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sudo service docker start</span><br></pre></td></tr></table></figure>

<h4 id="Mac-OS安装："><a href="#Mac-OS安装：" class="headerlink" title="Mac OS安装："></a>Mac OS安装：</h4><p>下载安装文件： <a href="https://hub.docker.com/editions/community/docker-ce-desktop-mac" target="_blank" rel="noopener">https://hub.docker.com/editions/community/docker-ce-desktop-mac</a></p>
<p>和其他软件一样，双击并拖入应用程序目录即可。</p>
<h4 id="windows-安装"><a href="#windows-安装" class="headerlink" title="windows 安装"></a>windows 安装</h4><p>下载安装文件：<a href="https://hub.docker.com/editions/community/docker-ce-desktop-windows" target="_blank" rel="noopener">https://hub.docker.com/editions/community/docker-ce-desktop-windows</a></p>
<p>和其他软件一样，双击下一步下一步即可。</p>
<h4 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h4><p>推荐加速服务：</p>
<ul>
<li>docker中国： <a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a></li>
<li><a href="https://account.aliyun.com/login/login.htm?oauth_callback=https%3A%2F%2Fcr.console.aliyun.com%2Fcn-hangzhou%2Fmirrors" target="_blank" rel="noopener">阿里云加速器（需要账号获取）</a></li>
<li><a href="https://kirk-enterprise.github.io/hub-docs/#/user-guide/mirror" target="_blank" rel="noopener">七牛云加速器 https://reg-mirror.qiniu.com</a></li>
</ul>
<h5 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h5><p>对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://registry.docker-cn.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新启动docker服务</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h5 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h5><p>使用 Windows 10 的系统，在系统右下角托盘 Docker 图标内右键菜单选择 Settings，打开配置窗口后左侧导航菜单选择 Daemon。在 Registry mirrors 一栏中填写加速器地址 <a href="https://registry.docker-cn.com，之后点击" target="_blank" rel="noopener">https://registry.docker-cn.com，之后点击</a> Apply 保存后 Docker 就会重启并应用配置的镜像地址了。</p>
<h5 id="Mac-OS"><a href="#Mac-OS" class="headerlink" title="Mac OS"></a>Mac OS</h5><p>使用 macOS 的用户，在任务栏点击 Docker Desktop 应用图标 -&gt; Perferences… -&gt; Daemon -&gt; Registry mirrors。在列表中填写加速器地址 <a href="https://registry.docker-cn.com。修改完成之后，点击" target="_blank" rel="noopener">https://registry.docker-cn.com。修改完成之后，点击</a> Apply &amp; Restart 按钮，Docker 就会重启并应用配置的镜像地址了。</p>
<h4 id="检查是否生效"><a href="#检查是否生效" class="headerlink" title="检查是否生效"></a>检查是否生效</h4><p>执行 <code>docker info</code> ，如果从结果中看到了如下内容，说明配置成功。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line"> https:<span class="comment">//registry.docker-cn.com</span></span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>centos 7 开放端口</title>
    <url>/year/03/23/centos-7-%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<p>centos 7 开放端口</p>
<a id="more"></a>


<ul>
<li><p>查看已打开的端口  <code># netstat -anp</code></p>
</li>
<li><p>查看想开的端口是否已开 <code># firewall-cmd --query-port=666/tcp</code></p>
<p>若此提示 <code>FirewallD is not running</code><br>表示为不可知的防火墙 需要查看状态并开启防火墙</p>
</li>
<li><p>查看防火墙状态  <code># systemctl status firewalld</code><br><code>running</code> 状态即防火墙已经开启<br><code>dead</code> 状态即防火墙未开启</p>
<ul>
<li><p>开启防火墙，<code># systemctl start firewalld</code>  没有任何提示即开启成功</p>
</li>
<li><p>开启防火墙 <code># service firewalld start</code></p>
</li>
<li><p>关闭防火墙 <code># systemctl stop firewalld</code><br>centos7.3 上述方式可能无法开启，可以先<code>#systemctl unmask firewalld.service</code> 然后 <code># systemctl start firewalld.service</code></p>
</li>
</ul>
</li>
<li><p>查看想开的端口是否已开 <code># firewall-cmd --query-port=666/tcp</code>    提示no表示未开</p>
</li>
<li><p>开永久端口号 <code>firewall-cmd --add-port=666/tcp --permanent</code>   提示    success 表示成功</p>
</li>
<li><p>重新载入配置  # firewall-cmd –reload    比如添加规则之后，需要执行此命令</p>
</li>
<li><p>再次查看想开的端口是否已开  # firewall-cmd –query-port=666/tcp  提示yes表示成功</p>
</li>
<li><p>若移除端口 <code># firewall-cmd --permanent --remove-port=666/tcp</code></p>
</li>
<li><p>修改iptables  有些版本需要安装iptables-services <code># yum install iptables-services</code> 然后修改进目录 <code>/etc/sysconfig/iptables</code>   修改内容.</p>
</li>
<li><p>systemctl restart iptables.service 重启即可生效。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>大厦崩塌</title>
    <url>/year/05/20/dasha/</url>
    <content><![CDATA[<p>今天，大厦崩塌<br>我的假枪里没有一颗子弹<br>我的整个世界消失在<br>漆黑的夜的噩梦里</p>
<a id="more"></a>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=386844&auto=1&height=66"></iframe>


]]></content>
      <categories>
        <category>不可分类</category>
      </categories>
      <tags>
        <tag>不可分类</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 创建 PXC 高可用集群并配置 Harpoxy 负载均衡</title>
    <url>/year/05/23/docker-pxc/</url>
    <content><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g3b6n7xz6kj327w0j8qah.jpg" alt=""></p>
<a id="more"></a>

<h2 id="创建-PXC-集群环境"><a href="#创建-PXC-集群环境" class="headerlink" title="创建 PXC 集群环境"></a>创建 PXC 集群环境</h2><h3 id="拉取-percona-xtradb-cluster-镜像"><a href="#拉取-percona-xtradb-cluster-镜像" class="headerlink" title="拉取 percona-xtradb-cluster 镜像"></a>拉取 percona-xtradb-cluster 镜像</h3><p>官方镜像地址：<a href="https://hub.docker.com/r/percona/percona-xtradb-cluster" target="_blank" rel="noopener">https://hub.docker.com/r/percona/percona-xtradb-cluster</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull percona&#x2F;percona-xtradb-cluster</span><br></pre></td></tr></table></figure>
<p>percona/percona-xtradb-cluster 太长，我们换个名字叫做pxc，操作如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker tag percona&#x2F;percona-xtradb-cluster pxc</span><br></pre></td></tr></table></figure>

<p>并将开始拉去的镜像删除，操作如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rmi percona&#x2F;percona-xtradb-cluster</span><br></pre></td></tr></table></figure>

<h4 id="创建docker网络"><a href="#创建docker网络" class="headerlink" title="创建docker网络"></a>创建docker网络</h4><p>出于安全考虑，将PXC集群放置于docker内部网络中。只需将宿主的端口与之映射并开放出来即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network create --subnet&#x3D;172.18.0.0&#x2F;24 net1</span><br></pre></td></tr></table></figure>

<p>其中，–subnet=172.18.0.0/24自定义网段172.18.0.0，24是指24位子网掩码 net1 网段名称。</p>
<p>执行成功后，我们可以通过<code>sudo docker inspect net1</code>查看内部网络信息。</p>
<h4 id="创建docker卷"><a href="#创建docker卷" class="headerlink" title="创建docker卷"></a>创建docker卷</h4><p>docker容器的运行规则：通过目录映射的方法，将业务数据写入到宿主机中。好处是如果容器故障，只需将容器删除，重新启用一个容器即可，这样就不会丢失原来的数据。 由于PXC较为特殊，无法直接使用映射目录的方法做映射（使用后会闪退），故使用docker卷。 在命令行使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker volume create --name v1</span><br><span class="line">docker volume create --name v2</span><br><span class="line">docker volume create --name v3</span><br></pre></td></tr></table></figure>
<p>计划创建3个数据库节点，所以这里对应创建3个数据卷。</p>
<h3 id="创建第一个容器节点："><a href="#创建第一个容器节点：" class="headerlink" title="创建第一个容器节点："></a>创建第一个容器节点：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3306:3306 -v v1:&#x2F;var&#x2F;lib&#x2F;mysql \</span><br><span class="line">    -e MYSQL_ROOT_PASSWORD&#x3D;123456 \</span><br><span class="line">    -e CLUSTER_NAME&#x3D;PXC \</span><br><span class="line">    -e XTRABACKUP_PASSWORD&#x3D;123456 \</span><br><span class="line">    --privileged \</span><br><span class="line">    --name&#x3D;node1 \</span><br><span class="line">    --net&#x3D;net1 \</span><br><span class="line">    --ip 172.18.0.2 \</span><br><span class="line">    pxc</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-d 默认在后台运行, -p 3306（宿主）:3306（容器） 端口映射，将容器3306端口映射到宿主3306端口 -v 目录映射，将第四步创建的v1映射到容器/var/lib/mysql -e MYSQL_ROOT_PASSROWD 创建的用户实例的密码，默认实例root -e CLUSTER_NAME 集群名称， -e XTRABACKUP_PASSWORD 数据库之间同步使用的密码 –privileged 权限.给予最高权限 –name 给容器容命名 –net 使用内部网段 –ip 内部网段分到的地址</p>
</blockquote>
<h4 id="测试连接："><a href="#测试连接：" class="headerlink" title="测试连接："></a>测试连接：</h4><p>需要注意的是容器启动的速度虽然很快，但是pxc初始化是需要一点时间的（大概两分钟左右），必须等第一个容器初始化完成后再启动第二个pxc容器，不然会报错。</p>
<p>测试连接成功后就可以启动其他pxc容器了</p>
<p>在启动其他容器的时候需要更改映射的宿主机端口、容器的名称，还有指定 IP 地址。</p>
<h3 id="创建第二个容器节点："><a href="#创建第二个容器节点：" class="headerlink" title="创建第二个容器节点："></a>创建第二个容器节点：</h3><blockquote>
<p>注意：在启动其他容器的时候需要更改映射的宿主机端口、容器的名称，还有指定 IP 地址。</p>
<p> -e CLUSTER_JOIN=node1 用于连接第一个数据库节点</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3307:3306 -v v2:&#x2F;var&#x2F;lib&#x2F;mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD&#x3D;123456 \</span><br><span class="line">-e CLUSTER_NAME&#x3D;PXC \</span><br><span class="line">-e XTRABACKUP_PASSWORD&#x3D;123456 \</span><br><span class="line">-e CLUSTER_JOIN&#x3D;node1 \</span><br><span class="line">--privileged \</span><br><span class="line">--name&#x3D;node2 \</span><br><span class="line">--net&#x3D;net1 \</span><br><span class="line">--ip 172.18.0.3 \</span><br><span class="line">pxc</span><br></pre></td></tr></table></figure>


<h3 id="创建第三个容器节点："><a href="#创建第三个容器节点：" class="headerlink" title="创建第三个容器节点："></a>创建第三个容器节点：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3308:3306 -v v3:&#x2F;var&#x2F;lib&#x2F;mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD&#x3D;123456 \</span><br><span class="line">-e CLUSTER_NAME&#x3D;PXC \</span><br><span class="line">-e XTRABACKUP_PASSWORD&#x3D;123456 \</span><br><span class="line">-e CLUSTER_JOIN&#x3D;node1 \</span><br><span class="line">--privileged \</span><br><span class="line">--name&#x3D;node3 \</span><br><span class="line">--net&#x3D;net1 \</span><br><span class="line">--ip 172.18.0.4 \</span><br><span class="line">pxc</span><br></pre></td></tr></table></figure>




<h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><p>用数据库连接工具连接三个数据库，在node创建数据库<code>test</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">database</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure>

<p>如果其他数据库都同步过来那就没有问题了。</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g3a21d0wupj30si0b2jsk.jpg" alt=""></p>
<h2 id="Harpoxy-负载均衡"><a href="#Harpoxy-负载均衡" class="headerlink" title="Harpoxy 负载均衡"></a>Harpoxy 负载均衡</h2><p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g3a1w7txi0j31dk0maagw.jpg" alt=""></p>
<h3 id="创建-haproxy-配置文件，并放到指定的宿主机目录。"><a href="#创建-haproxy-配置文件，并放到指定的宿主机目录。" class="headerlink" title="创建 haproxy 配置文件，并放到指定的宿主机目录。"></a>创建 haproxy 配置文件，并放到指定的宿主机目录。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global</span><br><span class="line">        #工作目录</span><br><span class="line">        chroot &#x2F;usr&#x2F;local&#x2F;etc&#x2F;haproxy</span><br><span class="line">        #日志文件，使用rsyslog服务中local5日志设备（&#x2F;var&#x2F;log&#x2F;local5），等级info</span><br><span class="line">        log 127.0.0.1 local5 info</span><br><span class="line">        #守护进程运行</span><br><span class="line">        daemon</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">        log     global</span><br><span class="line">        mode    http</span><br><span class="line">        #日志格式</span><br><span class="line">        option  httplog</span><br><span class="line">        #日志中不记录负载均衡的心跳检测记录</span><br><span class="line">        option  dontlognull</span><br><span class="line">        #连接超时（毫秒）</span><br><span class="line">        timeout connect 5000</span><br><span class="line">        #客户端超时（毫秒）</span><br><span class="line">        timeout client  50000</span><br><span class="line">        #服务器超时（毫秒）</span><br><span class="line">        timeout server  50000</span><br><span class="line"></span><br><span class="line">#监控界面   </span><br><span class="line">listen  admin_stats</span><br><span class="line">        #监控界面的访问的IP和端口</span><br><span class="line">        bind  0.0.0.0:8888</span><br><span class="line">        #访问协议</span><br><span class="line">        mode        http</span><br><span class="line">        #URI相对地址</span><br><span class="line">        stats uri   &#x2F;dbs</span><br><span class="line">        #统计报告格式</span><br><span class="line">        stats realm     Global\ statistics</span><br><span class="line">        #登陆帐户信息</span><br><span class="line">        stats auth  admin:123456</span><br><span class="line">#数据库负载均衡</span><br><span class="line">listen  proxy-mysql</span><br><span class="line">        #访问的IP和端口</span><br><span class="line">        bind  0.0.0.0:3306  </span><br><span class="line">        #网络协议</span><br><span class="line">        mode  tcp</span><br><span class="line">        #负载均衡算法（轮询算法）</span><br><span class="line">        #轮询算法：roundrobin</span><br><span class="line">        #权重算法：static-rr</span><br><span class="line">        #最少连接算法：leastconn</span><br><span class="line">        #请求源IP算法：source</span><br><span class="line">        balance  roundrobin</span><br><span class="line">       #日志格式</span><br><span class="line">        option  tcplog</span><br><span class="line">        #在MySQL中创建一个没有权限的haproxy用户，密码为空。Haproxy使用这个账户对MySQL数据库心跳检测</span><br><span class="line">        option  mysql-check user haproxy</span><br><span class="line">        server  MySQL_1 172.18.0.2:3306 check weight 1 maxconn 2000  </span><br><span class="line">        server  MySQL_2 172.18.0.3:3306 check weight 1 maxconn 2000  </span><br><span class="line">        server  MySQL_2 172.18.0.4:3306 check weight 1 maxconn 2000  </span><br><span class="line">        #使用keepalive检测死链</span><br><span class="line">        option  tcpka</span><br></pre></td></tr></table></figure>

<h3 id="启动-haproxy-容器"><a href="#启动-haproxy-容器" class="headerlink" title="启动 haproxy 容器"></a>启动 haproxy 容器</h3><blockquote>
<p>/Users/xinaogudu/hproxy 是我放置配置文件的目录。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -dit -p 4001:8888 -p 4002:3306 \</span><br><span class="line">-v &#x2F;Users&#x2F;xinaogudu&#x2F;hproxy:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;haproxy \</span><br><span class="line">--privileged \</span><br><span class="line">--net&#x3D;net1 \</span><br><span class="line">--name h1 \</span><br><span class="line">--ip 172.18.0.5 \</span><br><span class="line">haproxy</span><br></pre></td></tr></table></figure>

<h3 id="进入-haproxy-容器指明配置文件"><a href="#进入-haproxy-容器指明配置文件" class="headerlink" title="进入 haproxy 容器指明配置文件"></a>进入 haproxy 容器指明配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it h1 bash</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 指定 haproxy 配置文件位置</span><br><span class="line">haproxy -c -f &#x2F;usr&#x2F;local&#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg</span><br></pre></td></tr></table></figure>



<h3 id="在数据库中创建一个没有密码的-haproxy-用户用于心跳检测。"><a href="#在数据库中创建一个没有密码的-haproxy-用户用于心跳检测。" class="headerlink" title="在数据库中创建一个没有密码的 haproxy 用户用于心跳检测。"></a>在数据库中创建一个没有密码的 haproxy 用户用于心跳检测。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create user &#39;haproxy&#39;@&#39;%&#39; identified by &#39;&#39;;</span><br></pre></td></tr></table></figure>


<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="登录-haproxy-监控：http-localhost-4001-dbs"><a href="#登录-haproxy-监控：http-localhost-4001-dbs" class="headerlink" title="登录 haproxy 监控：http://localhost:4001/dbs"></a>登录 haproxy 监控：<a href="http://localhost:4001/dbs" target="_blank" rel="noopener">http://localhost:4001/dbs</a></h3><p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g3b67er48cj327y0tqwoh.jpg" alt=""></p>
<h3 id="用数据库管理工具连接-haproxy-端口测试："><a href="#用数据库管理工具连接-haproxy-端口测试：" class="headerlink" title="用数据库管理工具连接 haproxy 端口测试："></a>用数据库管理工具连接 haproxy 端口测试：</h3><p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g3b6ajpic6j317m0sq43v.jpg" alt=""></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>dokcer</tag>
        <tag>PXC</tag>
        <tag>Haproxy</tag>
      </tags>
  </entry>
  <entry>
    <title>docker run 后容器状态是 Exited 解析</title>
    <url>/year/05/22/docker-exited/</url>
    <content><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g3a6eaacp1j31720c4tf9.jpg" alt=""></p>
<a id="more"></a>
<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>运行：<code>docker run -dit -p 4001:8888 -p 4002:3306 -v /Users/xinaogudu/hproxy:/usr/local/etc/haproxy --privileged --net=net1 --name h1 --ip 172.18.0.5  haproxy</code> 后容器状态是 <code>Exited</code></p>
<h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><blockquote>
<p>容器的生命周期，要把 docker 容器看做是一个单独的进程及运行环境。容器不等价于一个虚拟的操作系统。Docker的开发人员也一直主张docker容器应该只运行一个进程。</p>
</blockquote>
<p>再根据 <a href="https://hub.docker.com/_/haproxy" target="_blank" rel="noopener">hproxy官方镜像</a> 描述，镜像里是没有默认配置的，也就没有进程。这就不难解释为什么docker run 之后容器是 Exited 状态了。</p>
<p><a href="https://hub.docker.com/_/haproxy" target="_blank" rel="noopener">hproxy官方镜像</a> 描述:</p>
<blockquote>
<p>Since no two users of HAProxy are likely to configure it exactly alike, this image does not come with any default configuration.</p>
</blockquote>
<p>对于 hproxy 官方是推荐 build 创建自己的镜像然后 docker run 的时候直接指定配置文件的。</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g3a615jd6zj319b0u00vu.jpg" alt=""></p>
<h2 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h2><p>所以解决办法有两种，一种是在 docker run 后加 bash 这样启动就有一个进程，容器就不是 Exited 状态了，另一种是按照官方的办法。build 自己的镜像然后再启动时指定文。</p>
<p>在 docker run 后加 bash ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -dit -p 4001:8888 -p 4002:3306 \</span><br><span class="line">    -v &#x2F;Users&#x2F;xinaogudu&#x2F;hproxy:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;haproxy \</span><br><span class="line">    --privileged \</span><br><span class="line">    --net&#x3D;net1 \</span><br><span class="line">    --name h1 \</span><br><span class="line">    --ip 172.18.0.5  \</span><br><span class="line">    haproxy bash</span><br></pre></td></tr></table></figure>




<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p><a href="https://segmentfault.com/a/1190000010940432" target="_blank" rel="noopener">Docker随笔记—docker run执行后，容器的状态是Exited的一些困惑</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 学习笔记 （一） 基本原理</title>
    <url>/year/04/06/docker1/</url>
    <content><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g36jt91zduj327w0r4168.jpg" alt=""></p>
<a id="more"></a>

<p>Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。</p>
<p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">namespace</a>，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/OS-level_virtualisation" target="_blank" rel="noopener">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/" target="_blank" rel="noopener">LXC</a>，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 <a href="https://github.com/docker/libcontainer" target="_blank" rel="noopener">libcontainer</a>，从 1.11 开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc" target="_blank" rel="noopener">runC</a> 和 <a href="https://github.com/containerd/containerd" target="_blank" rel="noopener">containerd</a>。</p>
<p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p>
<p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g36x93iv5nj312e0ectbz.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g36x9fdtbnj311u0ao779.jpg" alt=""></p>
<h2 id="Docker的优点："><a href="#Docker的优点：" class="headerlink" title="Docker的优点："></a>Docker的优点：</h2><p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。</p>
<h4 id="更高效的利用系统资源"><a href="#更高效的利用系统资源" class="headerlink" title="更高效的利用系统资源"></a>更高效的利用系统资源</h4><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p>
<h4 id="更快速的启动时间"><a href="#更快速的启动时间" class="headerlink" title="更快速的启动时间"></a>更快速的启动时间</h4><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p>
<h4 id="一致的运行环境"><a href="#一致的运行环境" class="headerlink" title="一致的运行环境"></a>一致的运行环境</h4><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。</p>
<h4 id="持续交付和部署"><a href="#持续交付和部署" class="headerlink" title="持续交付和部署"></a>持续交付和部署</h4><p>对开发和运维（<a href="https://zh.wikipedia.org/wiki/DevOps" target="_blank" rel="noopener">DevOps</a>）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p>
<p>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 <a href="https://en.wikipedia.org/wiki/Continuous_integration" target="_blank" rel="noopener">持续集成(Continuous Integration)</a> 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 <a href="https://en.wikipedia.org/wiki/Continuous_delivery" target="_blank" rel="noopener">持续部署(Continuous Delivery/Deployment)</a> 系统进行自动部署。</p>
<p>而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p>
<h4 id="更轻松的迁移"><a href="#更轻松的迁移" class="headerlink" title="更轻松的迁移"></a>更轻松的迁移</h4><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>
<h4 id="更轻松的维护和扩展"><a href="#更轻松的维护和扩展" class="headerlink" title="更轻松的维护和扩展"></a>更轻松的维护和扩展</h4><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 <a href="https://hub.docker.com/search/?type=image&image_filter=official" target="_blank" rel="noopener">官方镜像</a>，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本</p>
<h4 id="对比传统虚拟机"><a href="#对比传统虚拟机" class="headerlink" title="对比传统虚拟机"></a>对比传统虚拟机</h4><table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td>启动</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>硬盘使用</td>
<td>一般为 MB</td>
<td>一般为 GB</td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>弱于原生</td>
</tr>
<tr>
<td>系统支持量</td>
<td>单机支持上千个容器</td>
<td>一般几十个</td>
</tr>
</tbody></table>
<h2 id="Docker-引擎"><a href="#Docker-引擎" class="headerlink" title="Docker 引擎"></a>Docker 引擎</h2><p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g36xkjrcmsj31ra0kk78n.jpg" alt=""></p>
<ul>
<li>Server是一个常驻进程</li>
<li>REST API 实现了client和server间的交互协议<br><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g36ynbf1xvj314g0b6alc.jpg" alt=""></li>
<li>CLI 实现容器和镜像的管理，为用户提供统一的操作界面<br><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g36yobf5mdj314q0ae14y.jpg" alt=""></li>
</ul>
<h2 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h2><p>Docker使用C/S架构，Client 通过接口与Server进程通信实现容器的构建，运行和发布。client和server可以运行在同一台集群，也可以通过跨主机实现远程通信。</p>
<p>、<br><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g36xlx75hwj31si0sue0v.jpg" alt=""></p>
<h2 id="Docker-基本概念"><a href="#Docker-基本概念" class="headerlink" title="Docker 基本概念"></a>Docker 基本概念</h2><p>Docker 包括三个基本概念</p>
<ul>
<li>镜像（Image）</li>
<li>容器（Container）</li>
<li>仓库（Repository）</li>
</ul>
<p>理解了这三个概念，就理解了 Docker 的整个生命周期。</p>
<h3 id="镜像："><a href="#镜像：" class="headerlink" title="镜像："></a>镜像：</h3><p>镜像（Image）就是一个只读的模板。Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统。</p>
<p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<h5 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h5><p>因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p>
<p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<p>关于镜像构建，将会在后续相关章节中做进一步的讲解。</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性。</p>
<p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。</p>
<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，<strong>任何保存于容器存储层的信息都会随容器删除而丢失</strong>。</p>
<p>按照 Docker 最佳实践的要求，<strong>容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。</strong>所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p>
<p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>
<h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><h4 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h4><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。</p>
<p>一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。</p>
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p>
<p>仓库名经常以 两段式路径 形式出现，比如 zuorn/tomcat，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的应用程序名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p>
<h4 id="Docker-Registry-公开服务"><a href="#Docker-Registry-公开服务" class="headerlink" title="Docker Registry 公开服务"></a>Docker Registry 公开服务</h4><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p>
<p>最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，这也是默认的 Registry，并拥有大量的高质量的官方镜像。</p>
<h4 id="私有-Docker-Registry"><a href="#私有-Docker-Registry" class="headerlink" title="私有 Docker Registry"></a>私有 Docker Registry</h4><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a href="https://hub.docker.com/_/registry/" target="_blank" rel="noopener">Docker Registry</a> 镜像，可以直接使用做为私有 Registry 服务。</p>
<p>开源的 Docker Registry 镜像只提供了 <a href="https://docs.docker.com/registry/spec/api/" target="_blank" rel="noopener">Docker Registry API</a> 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 <a href="https://docs.docker.com/datacenter/dtr/2.0/" target="_blank" rel="noopener">Docker Trusted Registry</a> 中，提供了这些高级功能。</p>
<p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，<a href="https://github.com/goharbor/harbor" target="_blank" rel="noopener">Harbor</a> 和 <a href="https://www.sonatype.com/nexus-repository-sonatype" target="_blank" rel="noopener">Sonatype Nexus</a>。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker学习笔记（二） —— 使用Dockerfile 定制镜像</title>
    <url>/year/05/15/docker2/</url>
    <content><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g36jt91zduj327w0r4168.jpg" alt=""></p>
<blockquote>
<p>Dockerfile 是一个文本文件，其内包含了一条条的 指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
</blockquote>
<a id="more"></a>
<h3 id="Dockerfile-指令"><a href="#Dockerfile-指令" class="headerlink" title="Dockerfile 指令"></a>Dockerfile 指令</h3><hr>
<h4 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h4><p>ROM 就是指定 基础镜像，Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。</p>
<p>FROM scratch 表示一个空白镜像。所以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p>
<h4 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h4><p>RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：</p>
<ul>
<li>shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式</li>
<li>exec 格式：RUN [“可执行文件”, “参数1”, “参数2”]，这更像是函数调用中的格式。</li>
</ul>
<p>需要注意的是，Dockerfile 中每一个指令都会建立一层，所以每个Run都会创建一层镜像，如果有多个命令可以尽量写在一个RUN里面。可以使用<code>&amp;&amp;</code> 串联起来</p>
<h4 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h4><ul>
<li>COPY [–chown=<user>:<group>] &lt;源路径&gt;… &lt;目标路径&gt;</li>
<li>COPY [–chown=<user>:<group>] [“&lt;源路径1&gt;”,… “&lt;目标路径&gt;”]</li>
</ul>
<p>&lt;目标路径&gt; 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。<br>在使用该指令的时候可以加上 –chown=<user>:<group> 选项来改变文件的所属用户及所属组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">COPY --chown=<span class="number">55</span>:mygroup files* <span class="regexp">/mydir/</span></span><br><span class="line">COPY --chown=bin files* <span class="regexp">/mydir/</span></span><br><span class="line">COPY --chown=<span class="number">1</span> files* <span class="regexp">/mydir/</span></span><br><span class="line">COPY --chown=<span class="number">10</span>:<span class="number">11</span> files* <span class="regexp">/mydir/</span></span><br></pre></td></tr></table></figure>

<h4 id="ADD-更高级的复制"><a href="#ADD-更高级的复制" class="headerlink" title="ADD 更高级的复制"></a>ADD 更高级的复制</h4><p>ADD 和 COPY 的格式和性质都是基本一致的。区别在于：</p>
<ul>
<li>比如 &lt;源路径&gt; 可以是一个 URLDocker 引擎会试图去下载这个链接的文件放到 &lt;目标路径&gt; 去。下载后的文件权限自动设置为 600。</li>
<li>&lt;源路径&gt; 为一个 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，ADD 指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt; 去</li>
</ul>
<p>如果权限需要调整的话就需要另外的一层RUN，所以并不推荐使用。<br>对于复制文件，应该尽可能的使用COPY。</p>
<h4 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h4><p>与RUN相似，有两种格式：</p>
<ul>
<li>shell 格式：CMD &lt;命令&gt;</li>
<li>exec 格式：CMD [“可执行文件”, “参数1”, “参数2”…]</li>
</ul>
<p>容器就是进程，所以在启动容器的时候需要指定所运行的程序及参数。CMD 指令就是用于指定默认容器主进程的启动命令的。</p>
<p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令。</p>
<p>需要注意的是 Docker 不是虚拟机，<strong>容器中的命令都应该以前台执行</strong>而不是像虚拟机、物理机里面那样，用 systemd 去启动后台服务，<strong>容器内没有后台服务的概念</strong>。</p>
<p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<h5 id="栗子："><a href="#栗子：" class="headerlink" title="栗子："></a>栗子：</h5><ul>
<li>错误的写法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">CMD service nginx start</span><br></pre></td></tr></table></figure>

<ul>
<li>正确的写法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">CMD [<span class="string">"nginx"</span>, <span class="string">"-g"</span>, <span class="string">"daemon off;"</span>]</span><br></pre></td></tr></table></figure>

<h4 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h4><p>ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 –entrypoint 来指定。</p>
<p>当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; <span class="string">"&lt;CMD&gt;"</span></span><br></pre></td></tr></table></figure>
<p>ENTRYPOINT的作用：</p>
<ul>
<li>应用运行前的准备工作，比如mysql镜像在启动时执行相关的sql，可以写一个脚本，然后放入 ENTRYPOINT 中去执行，这个脚本会将接到的参数（也就是 <CMD>）作为命令，在脚本最后执行。</li>
</ul>
<h4 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h4><p>格式：</p>
<ul>
<li>ENV <key> <value></li>
<li>ENV <key1>=<value1> <key2>=<value2>…</li>
</ul>
<p>支持环境变量的指令：ADD、COPY、ENV、EXPOSE、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD。</p>
<h4 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h4><p>格式：ARG &lt;参数名&gt;[=&lt;默认值&gt;]</p>
<p>构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 docker history 还是可以看到所有值的。</p>
<p>Dockerfile 中的 ARG 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 docker build 中用 –build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。</p>
<h4 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h4><p>格式：</p>
<ul>
<li>VOLUME [“&lt;路径1&gt;”, “&lt;路径2&gt;”…]</li>
<li>VOLUME &lt;路径&gt;</li>
</ul>
<p>容器运行时，应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷（VOLUME）中。在Dockerfile中，可以事先指定某些目录为挂载为你命卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">VOLUME /data</span><br></pre></td></tr></table></figure>

<p>这里的 /data 目录就会在运行时自动挂载为匿名卷，任何想 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">docker run -d -v mydata:<span class="regexp">/data xxxx</span></span><br></pre></td></tr></table></figure>
<p>在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。</p>
<h4 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h4><p>格式：</p>
<ul>
<li>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;…]。</li>
</ul>
<p>EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。</p>
<h4 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h4><p>格式：WORKDIR &lt;工作目录路径&gt;</p>
<p>使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），<strong>以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录</strong>。</p>
<p>如果需要改变以后各层的工作目录的位置，应该使用 WORKDIR 指令。</p>
<h4 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h4><p>格式：</p>
<ul>
<li>USER 指定当前用户</li>
</ul>
<p>USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份。</p>
<p>和 WORKDIR 一样，USER 只是切换到指定的用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<h4 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h4><p>格式：</p>
<ul>
<li>HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令</li>
<li>HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li>
</ul>
<p>当在一个镜像指定了 HEALTHCHECK 指令后，用其启动容器，初始状态会为 starting，在 HEALTHCHECK 指令检查成功后变为 healthy，如果连续一定次数失败，则会变为 unhealthy。</p>
<p>HEALTHCHECK 支持下列选项：</p>
<ul>
<li>–interval=&lt;间隔&gt;：两次健康检查的间隔，默认为 30 秒；</li>
<li>–timeout=&lt;时长&gt;：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li>
<li>–retries=&lt;次数&gt;：当连续失败指定次数后，则将容器状态视为 unhealthy，默认 3 次。</li>
</ul>
<p>和 CMD, ENTRYPOINT 一样，HEALTHCHECK 只可以出现一次，如果写了多个，只有最后一个生效。</p>
<h4 id="ONBUILD-为他人做嫁衣裳"><a href="#ONBUILD-为他人做嫁衣裳" class="headerlink" title="ONBUILD 为他人做嫁衣裳"></a>ONBUILD 为他人做嫁衣裳</h4><p>格式：</p>
<ul>
<li>ONBUILD &lt;其它指令&gt;。</li>
</ul>
<p>ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN, COPY 等，而这些指令，<strong>在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</strong></p>
<h3 id="docker-build-构建命令"><a href="#docker-build-构建命令" class="headerlink" title="docker build 构建命令"></a>docker build 构建命令</h3><p>格式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><p>-build-arg=[] :设置镜像创建时的变量；</p>
</li>
<li><p>–cpu-shares :设置 cpu 使用权重；</p>
</li>
<li><p>–cpu-period :限制 CPU CFS周期；</p>
</li>
<li><p>–cpu-quota :限制 CPU CFS配额；</p>
</li>
<li><p>–cpuset-cpus :指定使用的CPU id；</p>
</li>
<li><p>–cpuset-mems :指定使用的内存 id；</p>
</li>
<li><p>–disable-content-trust :忽略校验，默认开启；</p>
</li>
<li><p>-f :指定要使用的Dockerfile路径；</p>
</li>
<li><p>–force-rm :设置镜像过程中删除中间容器；</p>
</li>
<li><p>–isolation :使用容器隔离技术；</p>
</li>
<li><p>–label=[] :设置镜像使用的元数据；</p>
</li>
<li><p>-m :设置内存最大值；</p>
</li>
<li><p>–memory-swap :设置Swap的最大值为内存+swap，”-1”表示不限swap；</p>
</li>
<li><p>–no-cache :创建镜像的过程不使用缓存；</p>
</li>
<li><p>–pull :尝试去更新镜像的新版本；</p>
</li>
<li><p>–quiet, -q :安静模式，成功后只输出镜像 ID；</p>
</li>
<li><p>–rm :设置镜像成功后删除中间容器；</p>
</li>
<li><p>–shm-size :设置/dev/shm的大小，默认值是64M；</p>
</li>
<li><p>–ulimit :Ulimit配置。</p>
</li>
<li><p>–tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</p>
</li>
<li><p>–network: 默认 default。在构建期间设置RUN指令的网络模式</p>
</li>
</ul>
<h4 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h4><p>docker build 命令最后有一个 .。. 表示当前目录，而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 <strong>上下文路径</strong>。那么什么是上下文呢？</p>
<p>首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p>
<p>当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p>
<p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 学习笔记（三）网络配置</title>
    <url>/year/05/19/docker3/</url>
    <content><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g36jt91zduj327w0r4168.jpg" alt=""></p>
<a id="more"></a>


<h3 id="容器与外部网络的连接"><a href="#容器与外部网络的连接" class="headerlink" title="容器与外部网络的连接"></a>容器与外部网络的连接</h3><hr>
<p>容器在启动时可以通过 -P 或 -p 参数来指定端口映射。</p>
<p>当使用 -P 标记时，Docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端口。</p>
<p><code>-p</code> 则指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有<br><code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p>
<h4 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="映射所有接口地址"></a>映射所有接口地址</h4><p>使用 <code>hostPort:containerPort</code> 格式本地的 5000 端口映射到容器的 5000 端口，可以执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ docker run -d -p <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>:<span class="number">5000</span> ubuntu</span><br></pre></td></tr></table></figure>
<h5 id="映射到指定地址的任意端口"><a href="#映射到指定地址的任意端口" class="headerlink" title="映射到指定地址的任意端口"></a>映射到指定地址的任意端口</h5><p>使用 <code>ip::containerPort</code> 绑定 <code>localhost</code> 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ docker run -d -p <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>::<span class="number">5000</span> ubuntu</span><br></pre></td></tr></table></figure>

<p>使用 udp 标记来指定 udp 端口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">docker run -d -p <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>:<span class="number">5000</span>/udp ubuntu</span><br></pre></td></tr></table></figure>

<h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><hr>
<p>随着 <code>Docker</code> 网络的完善，强烈建议将容器加入自定义的 <code>Docker</code> 网络来连接多个容器。</p>
<h4 id="新建网络"><a href="#新建网络" class="headerlink" title="新建网络"></a>新建网络</h4><p>新建 docker 网络</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ docker network create -d bridge my-net</span><br></pre></td></tr></table></figure>

<p>-d 参数指定 Docker 网络类型，有 <code>bridge overlay</code>。其中 <code>overlay</code> 网络类型用于 <code>Swarm mode</code>。</p>
<h4 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h4><p>运行一个容器并连接到新建的 <code>my-net</code> 网络</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ docker run -it --rm --name busybox1 --network my-net busybox sh</span><br></pre></td></tr></table></figure>

<p>打开新的终端，再运行一个容器并加入到 <code>my-net</code> 网络</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ docker run -it --rm --name busybox2 --network my-net busybox sh</span><br></pre></td></tr></table></figure>

<h4 id="配置DNS"><a href="#配置DNS" class="headerlink" title="配置DNS"></a>配置DNS</h4><hr>
<h4 id="容器访问控制"><a href="#容器访问控制" class="headerlink" title="容器访问控制"></a>容器访问控制</h4><p>容器的访问机制，主要通过 <code>Linux</code>上的 <code>Iptables</code> 防火墙来实现。</p>
<h4 id="容器访问外部网络"><a href="#容器访问外部网络" class="headerlink" title="容器访问外部网络"></a>容器访问外部网络</h4><p> 容器想要访问外部网络，就需要本地系统转发支持，肩擦好转发是否打开。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$sysctl net.ipv4.ip_forward</span><br><span class="line">net.ipv4.ip_forward = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>如果为0，shaming没有开启转发，需要手动打开。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$sysctl -w net.ipv4.ip_forward=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>如果启动 Docker 服务的时候设定<code>--ip-forward=true</code> ，Docker就会自动设定系统的 <code>ip_forward</code><br>参数替换为1。</p>
<h4 id="容器之间的访问"><a href="#容器之间的访问" class="headerlink" title="容器之间的访问"></a>容器之间的访问</h4><p>容器之间相互访问，需要两方面的支持。</p>
<ul>
<li>容器的网络拓扑是否已经互联。默认情况下，所有容器都会被连接到 docker0 网桥上。</li>
<li>本地系统的防火墙软件 – iptables 是否允许通过。</li>
</ul>
<h4 id="访问所有端口"><a href="#访问所有端口" class="headerlink" title="访问所有端口"></a>访问所有端口</h4><p>启动 Docker 服务（即 <code>dockerd</code>）的时候，默认会添加一条转发策略到本地主机 <code>iptables</code> 的 FORWARD 链上。策略为通过（ACCEPT）还是禁止（DROP）取决于配置<code>--icc=true</code>（缺省值）还是 <code>--icc=false</code>。当然，如果手动指定 <code>--iptables=false</code> 则不会添加 <code>iptables</code> 规则。</p>
<p>可见，默认情况下，不同容器之间是允许网络互通的。如果为了安全考虑，可以在 <code>/etc/docker/daemon.json</code>文件中配置 {“icc”: false} 来禁止它。</p>
<h4 id="访问指定端口"><a href="#访问指定端口" class="headerlink" title="访问指定端口"></a>访问指定端口</h4><p>在通过 <code>-icc=false</code>  关闭网络访问后，还可以通过 <code>--link=CONTAINER_NAME:ALIAS</code> 选项来访问开放端口。</p>
<p>可以同时使用 <code>icc=false --iptables=true</code> 参数来关闭允许相互的网络访问，并让 Docker 可以修改系统中的 <code>iptables</code> 规则。</p>
<p>使用 <code>--link=CONTAINER_NAME:ALIAS</code>选项。Docker 会在 <code>iptable</code> 中为 两个容器分别添加一条 ACCEPT 规则，允许相互访问开放的端口（取决于 Dockerfile 中的 EXPOSE 指令）。</p>
<p>注意：<code>--link=CONTAINER_NAME:ALIAS</code> 中的 <code>CONTAINER_NAME</code> 目前必须是 Docker 分配的名字，或使用 –name 参数指定的名字。主机名则不会被识别。</p>
<h3 id="Docker-网络相关的命令列表。"><a href="#Docker-网络相关的命令列表。" class="headerlink" title="Docker 网络相关的命令列表。"></a>Docker 网络相关的命令列表。</h3><hr>
<p>其中有些命令选项只有在 Docker 服务启动的时候才能配置，而且不能马上生效。</p>
<ul>
<li><p>-b BRIDGE 或 –bridge=BRIDGE 指定容器挂载的网桥</p>
</li>
<li><p>–bip=CIDR 定制 docker0 的掩码</p>
</li>
<li><p>-H SOCKET… 或 –host=SOCKET… Docker 服务端接收命令的通道</p>
</li>
<li><p>–icc=true|false 是否支持容器之间进行通信</p>
</li>
<li><p>–ip-forward=true|false 请看下文容器之间的通信</p>
</li>
<li><p>–iptables=true|false 是否允许 Docker 添加 iptables 规则</p>
</li>
<li><p>–mtu=BYTES 容器网络中的 MTU<br>下面2个命令选项既可以在启动服务时指定，也可以在启动容器时指定。在 Docker 服务启动的时候指定则会成为默认值，后面执行 docker run 时可以覆盖设置的默认值。</p>
</li>
<li><p>–dns=IP_ADDRESS… 使用指定的DNS服务器</p>
</li>
<li><p>–dns-search=DOMAIN… 指定DNS搜索域<br>最后这些选项只有在 docker run 执行时使用，因为它是针对容器的特性内容。</p>
</li>
<li><p>-h HOSTNAME 或 –hostname=HOSTNAME 配置容器主机名</p>
</li>
<li><p>–link=CONTAINER_NAME:ALIAS 添加到另一个容器的连接</p>
</li>
<li><p>–net=bridge|none|container:NAME_or_ID|host 配置容器的桥接模式</p>
</li>
<li><p>-p SPEC 或 –publish=SPEC 映射容器端口到宿主主机</p>
</li>
<li><p>-P or –publish-all=true|false 映射容器所有端口到宿主主机</p>
</li>
</ul>
<h3 id="容器访问控制-1"><a href="#容器访问控制-1" class="headerlink" title="容器访问控制"></a>容器访问控制</h3><hr>
<p>容器的访问控制，主要通过 <code>Linux</code> 上的 <code>iptables</code> 防火墙来进行管理和实现。 iptables 是 Linux 上默认的防火墙软件，在大部分发行版中都自带。</p>
<h4 id="容器访问外部网络-1"><a href="#容器访问外部网络-1" class="headerlink" title="容器访问外部网络"></a>容器访问外部网络</h4><p>容器要想访问外部网络，需要本地系统的转发支持。在Linux 系统中，检查转发是否打开。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$sysctl net.ipv4.ip_forward</span><br><span class="line">net.ipv4.ip_forward = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>如果为 0，说明没有开启转发，则需要手动打开。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$sysctl -w net.ipv4.ip_forward=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>如果在启动 Docker 服务的时候设定 –ip-forward=true, Docker 就会自动设定系统的 ip_forward 参数为 1。</p>
<h4 id="容器之间的访问-1"><a href="#容器之间的访问-1" class="headerlink" title="容器之间的访问"></a>容器之间的访问</h4><p>容器之间相互访问，需要两方面的支持。</p>
<ul>
<li>容器的网络拓扑是否已经互联。默认情况下，所有容器都会被连接到 docker0 网桥上。</li>
<li>本地系统的防火墙软件 – iptables 是否允许通过。</li>
</ul>
<h5 id="访问所有端口-1"><a href="#访问所有端口-1" class="headerlink" title="访问所有端口"></a>访问所有端口</h5><p>当启动 Docker 服务（即 dockerd）的时候，默认会添加一条转发策略到本地主机 iptables 的 FORWARD 链上。策略为通过（ACCEPT）还是禁止（DROP）取决于配置–icc=true（缺省值）还是 –icc=false。当然，如果手动指定 –iptables=false 则不会添加 iptables 规则。</p>
<p>默认情况下，不同容器之间是允许网络互通的。如果为了安全考虑，可以在 /etc/docker/daemon.json 文件中配置 {“icc”: false} 来禁止它。</p>
<h5 id="访问指定端口-1"><a href="#访问指定端口-1" class="headerlink" title="访问指定端口"></a>访问指定端口</h5><p>在通过 -icc=false 关闭网络访问后，还可以通过 –link=CONTAINER_NAME:ALIAS 选项来访问容器的开放端口。</p>
<p>可以同时使用 icc=false –iptables=true 参数来关闭允许相互的网络访问，并让 Docker 可以修改系统中的 iptables 规则。</p>
<p>使用 –link=CONTAINER_NAME:ALIAS 选项。Docker 会在 iptable 中为 两个容器分别添加一条 ACCEPT 规则，允许相互访问开放的端口（取决于 Dockerfile 中的 EXPOSE 指令）。</p>
<p>注意：–link=CONTAINER_NAME:ALIAS 中的 CONTAINER_NAME 目前必须是 Docker 分配的名字，或使用 –name 参数指定的名字。主机名则不会被识别。</p>
<h3 id="映射容器端口到宿主机"><a href="#映射容器端口到宿主机" class="headerlink" title="映射容器端口到宿主机"></a>映射容器端口到宿主机</h3><blockquote>
<p>默认情况下，容器可以主动访问到外部网络连接，但是外部连接无法访问到容器。</p>
</blockquote>
<h5 id="容器访问外部实现"><a href="#容器访问外部实现" class="headerlink" title="容器访问外部实现"></a>容器访问外部实现</h5><p>容器所有到外部网络的连接，源地址都会被 NAT 成本地系统的 IP 地址。这是使用 iptables 的源地址伪装操作实现的。</p>
<p>查看主机的 NAT 规则：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ sudo iptables -t nat -nL</span><br><span class="line">...</span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">MASQUERADE  all  --  <span class="number">172.17</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span>       !<span class="number">172.17</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>其中，上述规则将所有源地址在 172.17.0.0/16 网段，目标地址为其他网段（外部网络）的流量动态伪装为从系统网卡发出。MASQUERADE 跟传统 SNAT 的好处是它能动态从网卡获取地址。</p>
<h5 id="外部访问容器实现"><a href="#外部访问容器实现" class="headerlink" title="外部访问容器实现"></a>外部访问容器实现</h5><p>容器允许外部访问，可以在 <code>docker run</code> 时候通过 -p 或 -P 参数来启用。</p>
<p>不管用那种办法，其实也是在本地的 iptable 的 nat 表中添加相应的规则。</p>
<p>使用 -P 时：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ iptables -t nat -nL</span><br><span class="line">...</span><br><span class="line">Chain DOCKER (<span class="number">2</span> references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">DNAT       tcp  --  <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0</span>            <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0</span>            tcp dpt:<span class="number">49153</span> to:<span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span>:<span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>使用 -p 80:80 时：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ iptables -t nat -nL</span><br><span class="line">Chain DOCKER (<span class="number">2</span> references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">DNAT       tcp  --  <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0</span>            <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0</span>            tcp dpt:<span class="number">80</span> to:<span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span>:<span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><p>这里的规则映射了 0.0.0.0，意味着将接受主机来自所有接口的流量。用户可以通过 -p IP:host_port:container_port 或 -p IP::port 来指定允许访问容器的主机上的 IP、接口等，以制定更严格的规则。</p>
</li>
<li><p>如果希望永久绑定到某个固定的 IP 地址，可以在 Docker 配置文件 /etc/docker/daemon.json 中添加如下内容。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"ip"</span>: <span class="string">"0.0.0.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="配置-docker0-网桥"><a href="#配置-docker0-网桥" class="headerlink" title="配置 docker0 网桥"></a>配置 docker0 网桥</h3><hr>
<p>Docker 服务默认会创建一个 <code>docker0</code> 网桥（其上有一个 docker0 内部接口），它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。</p>
<p>Docker 默认指定了 <code>docker0</code> 接口 的 IP 地址和子网掩码，让主机和容器之间可以通过网桥相互通信，它还给出了 MTU（接口允许接收的最大传输单元），通常是 1500 Bytes，或宿主主机网络路由上支持的默认值。这些值都可以在服务启动的时候进行配置。</p>
<ul>
<li><code>-bip=CIDR IP</code>地址加掩码格式，例如 192.168.1.5/24</li>
<li><code>--mtu=BYTES</code>覆盖默认的 Docker mtu 配置</li>
</ul>
<p>也可以在配置文件中配置 DOCKER_OPTS，然后重启服务。</p>
<p>由于目前 Docker 网桥是 Linux 网桥，用户可以使用 brctl show 来查看网桥和端口连接信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ sudo brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">docker0         <span class="number">8000.3</span>a1d7362b4ee       no              veth65f9</span><br><span class="line">                                             vethdda6</span><br></pre></td></tr></table></figure>
<p>注：<code>brctl</code> 命令在 <code>Debian、Ubuntu</code> 中可以使用 <code>sudo apt-get install bridge-utils</code> 来安装。</p>
<p>每次创建一个新容器的时候，Docker 从可用的地址段中选择一个空闲的 IP 地址分配给容器的 eth0 端口。使用本地主机上 <code>docker0</code> 接口的 IP 作为所有容器的默认网关。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ sudo docker run -i -t --rm base /bin/bash</span><br><span class="line">$ ip addr show eth0</span><br><span class="line"><span class="number">24</span>: eth0: <span class="xml"><span class="tag">&lt;<span class="name">BROADCAST,UP,LOWER_UP</span>&gt;</span> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span></span><br><span class="line"><span class="xml">    link/ether 32:6f:e0:35:57:91 brd ff:ff:ff:ff:ff:ff</span></span><br><span class="line"><span class="xml">    inet 172.17.0.3/16 scope global eth0</span></span><br><span class="line"><span class="xml">       valid_lft forever preferred_lft forever</span></span><br><span class="line"><span class="xml">    inet6 fe80::306f:e0ff:fe35:5791/64 scope link</span></span><br><span class="line"><span class="xml">       valid_lft forever preferred_lft forever</span></span><br><span class="line"><span class="xml">$ ip route</span></span><br><span class="line"><span class="xml">default via 172.17.42.1 dev eth0</span></span><br><span class="line"><span class="xml">172.17.0.0/16 dev eth0  proto kernel  scope link  src 172.17.0.3</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义网桥"><a href="#自定义网桥" class="headerlink" title="自定义网桥"></a>自定义网桥</h3><hr>
<p>除了默认的 docker0 网桥，用户也可以指定网桥来连接各个容器。</p>
<p>在启动 Docker 服务的时候，使用 -b BRIDGE或–bridge=BRIDGE 来指定使用的网桥。</p>
<p>如果服务已经运行，那需要先停止服务，并删除旧的网桥。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl stop docker</span><br><span class="line">$ sudo ip link <span class="keyword">set</span> dev docker0 down</span><br><span class="line">$ sudo brctl delbr docker0</span><br></pre></td></tr></table></figure>

<p>然后创建一个网桥 <code>bridge0</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ sudo brctl addbr bridge0</span><br><span class="line">$ sudo ip addr add <span class="number">192.168</span><span class="number">.5</span><span class="number">.1</span>/<span class="number">24</span> dev bridge0</span><br><span class="line">$ sudo ip link <span class="keyword">set</span> dev bridge0 up</span><br></pre></td></tr></table></figure>

<p>查看确认网桥创建并启动。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ ip addr show bridge0</span><br><span class="line"><span class="number">4</span>: bridge0: <span class="xml"><span class="tag">&lt;<span class="name">BROADCAST,MULTICAST</span>&gt;</span> mtu 1500 qdisc noop state UP group default</span></span><br><span class="line"><span class="xml">    link/ether 66:38:d0:0d:76:18 brd ff:ff:ff:ff:ff:ff</span></span><br><span class="line"><span class="xml">    inet 192.168.5.1/24 scope global bridge0</span></span><br><span class="line"><span class="xml">       valid_lft forever preferred_lft forever</span></span><br></pre></td></tr></table></figure>
<p>在 Docker 配置文件 /etc/docker/daemon.json 中添加如下内容，即可将 Docker 默认桥接到创建的网桥上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"bridge"</span>: <span class="string">"bridge0"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动 Docker 服务。</p>
<p>新建一个容器，可以看到它已经桥接到了 bridge0 上。</p>
<p>可以继续用 <code>brctl show</code> 命令查看桥接的信息。另外，在容器中可以使用 <code>ip addr</code> 和 <code>ip route</code> 命令来查看 IP 地址配置和路由信息。</p>
<h3 id="编辑网络配置文件"><a href="#编辑网络配置文件" class="headerlink" title="编辑网络配置文件"></a>编辑网络配置文件</h3><hr>
<p>Docker 1.2.0 开始支持在运行中的容器里编辑 <code>/etc/hosts, /etc/hostname</code> 和 <code>/etc/resolv.conf</code> 文件。</p>
<p>但是这些修改是临时的，只在运行的容器中保留，容器终止或重启后并不会被保存下来，也不会被 <code>docker commit</code> 提交。</p>
<h3 id="创建一个点到点的连接"><a href="#创建一个点到点的连接" class="headerlink" title="创建一个点到点的连接"></a>创建一个点到点的连接</h3><p>默认情况下，Docker 会将所有容器连接到由 docker0 提供的虚拟子网中。</p>
<p>用户有时候需要两个容器之间可以直连通信，而不用通过主机网桥进行桥接。</p>
<p>解决办法很简单：创建一对 peer 接口，分别放到两个容器中，配置成点到点链路类型即可。</p>
<p>首先启动 2 个容器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ docker run -i -t --rm --net=none base /bin/bash</span><br><span class="line">root@<span class="number">1</span>f1f4c1f931a:<span class="regexp">/#</span></span><br><span class="line"><span class="regexp">$ docker run -i -t --rm --net=none base /</span>bin/bash</span><br><span class="line">root@<span class="number">12e343489</span>d2f:<span class="regexp">/#</span></span><br></pre></td></tr></table></figure>

<p>找到进程号，然后创建网络命名空间的跟踪文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ docker inspect -f <span class="string">'&#123;&#123;.State.Pid&#125;&#125;'</span> <span class="number">1</span>f1f4c1f931a</span><br><span class="line"><span class="number">2989</span></span><br><span class="line">$ docker inspect -f <span class="string">'&#123;&#123;.State.Pid&#125;&#125;'</span> <span class="number">12e343489</span>d2f</span><br><span class="line"><span class="number">3004</span></span><br><span class="line">$ sudo mkdir -p /<span class="keyword">var</span>/run/netns</span><br><span class="line">$ sudo ln -s /proc/<span class="number">2989</span>/ns/net /<span class="keyword">var</span>/run/netns/<span class="number">2989</span></span><br><span class="line">$ sudo ln -s /proc/<span class="number">3004</span>/ns/net /<span class="keyword">var</span>/run/netns/<span class="number">3004</span></span><br></pre></td></tr></table></figure>

<p>创建一对 peer 接口，然后配置路由</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ sudo ip link add A type veth peer name B</span><br><span class="line"></span><br><span class="line">$ sudo ip link <span class="keyword">set</span> A netns 2989</span><br><span class="line">$ sudo ip netns exec 2989 ip addr add 10.1.1.1/32 dev A</span><br><span class="line">$ sudo ip netns exec 2989 ip link <span class="keyword">set</span> A up</span><br><span class="line">$ sudo ip netns exec 2989 ip route add 10.1.1.2/32 dev A</span><br><span class="line"></span><br><span class="line">$ sudo ip link <span class="keyword">set</span> B netns 3004</span><br><span class="line">$ sudo ip netns exec 3004 ip addr add 10.1.1.2/32 dev B</span><br><span class="line">$ sudo ip netns exec 3004 ip link <span class="keyword">set</span> B up</span><br><span class="line">$ sudo ip netns exec 3004 ip route add 10.1.1.1/32 dev B</span><br></pre></td></tr></table></figure>

<p>现在这 2 个容器就可以相互 ping 通，并成功建立连接。点到点链路不需要子网和子网掩码。</p>
<p>此外，也可以不指定 –net=none 来创建点到点链路。这样容器还可以通过原先的网络来通信。</p>
<p>利用类似的办法，可以创建一个只跟主机通信的容器。但是一般情况下，更推荐使用 –icc=false 来关闭容器之间的通信。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 学习笔记 （四） 数据管理</title>
    <url>/year/05/19/docker4/</url>
    <content><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g36jt91zduj327w0r4168.jpg" alt=""></p>
<a id="more"></a>

<p>在默认情况下，容器内所有文件都存储在可写容器层中，这意味着：</p>
<ul>
<li>当该容器不再存在时，数据不会持久存在，并且如果另一个容器需要数据，则可能很难从容器中获取数据。</li>
<li>容器的可写层紧密耦合到运行容器的主机。无法轻松地将数据移动到其他位置。</li>
<li>写入容器的可写层需要 存储驱动程序来管理文件系统。存储驱动程序使用Linux内核提供联合文件系统。与使用直接写入主机文件系统的数据卷相比，这种额外的抽象降低了性能 。</li>
</ul>
<p>Docker有两个容器选项可以在主机中存储文件，因此即使在容器停止之后文件仍然会存在：volumes和 bind mounts。在Linux上运行Docker，可以使用tmpfs mount临时挂载。</p>
<p>无论哪种方式，数据在容器内都是相同的。它作为目录或容器文件系统中的单个文件公开。</p>
<p>Volumes，Bind mounts和tmpfs 装载之间差异的简单方法是考虑数据在Docker主机上的位置。</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g36owkutjrj30u00eyq5e.jpg" alt=""></p>
<h3 id="三者的区别"><a href="#三者的区别" class="headerlink" title="三者的区别"></a>三者的区别</h3><ul>
<li><p>Volumes存储在由Docker（/var/lib/docker/volumes/在Linux上）管理的主机文件系统的一部分中。非Docker进程不应修改文件系统的这一部分。卷是在Docker中保留数据的最佳方式。</p>
</li>
<li><p>Bind mounts可以存储在主机系统的任何位置。它们甚至可能是重要的系统文件或目录。Docker主机或Docker容器上的非Docker进程可以随时修改它们。</p>
</li>
<li><p>tmpfs挂载仅存储在主机系统的内存中，永远不会写入主机系统的文件系统。</p>
</li>
</ul>
<h3 id="Volumes的特点"><a href="#Volumes的特点" class="headerlink" title="Volumes的特点"></a>Volumes的特点</h3><p>卷是在Docker容器和服务中持久保存数据的首选方法。卷的一些用例包括：</p>
<ul>
<li><p>在多个运行容器之间共享数据。如果未显式创建它，则会在第一次将其装入容器时创建卷。当该容器停止或被移除时，该卷仍然存在。多个容器可以同时安装相同的卷，可以是读写也可以是只读。仅在您明确删除卷时才会删除卷。</p>
<p>  当Docker主机不能保证具有给定的目录或文件结构时。卷可帮助您将Docker主机的配置与容器运行时分离。</p>
</li>
<li><p>如果要将容器的数据存储在远程主机或云提供程序上，而不是本地存储。</p>
</li>
<li><p>当您需要将数据从一个Docker主机备份，还原或迁移到另一个Docker主机时，卷是更好的选择。您可以使用卷停止容器，然后备份卷的目录（例如/var/lib/docker/volumes/<volume-name>）。</p>
</li>
</ul>
<h3 id="Bind-mounts的特点"><a href="#Bind-mounts的特点" class="headerlink" title="Bind mounts的特点"></a>Bind mounts的特点</h3><ul>
<li><p>将配置文件从主机共享到容器。这就是Docker默认通过/etc/resolv.conf从主机安装到每个容器中来为容器提供DNS解析的方式 。</p>
</li>
<li><p>在Docker主机上的开发环境和容器之间共享源代码或构建工件。例如，您可以将Maven target/ 目录挂载到容器中，每次在Docker主机上构建Maven项目时，容器都可以访问重建的工件。</p>
<p>  如果以这种方式使用Docker进行开发，您的生产Dockerfile会将生产就绪工件直接复制到映像中，而不是依赖于绑定装载。</p>
</li>
<li><p>当Docker主机的文件或目录结构保证与容器所需的绑定安装一致时。</p>
</li>
</ul>
<h3 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h3><ul>
<li>tmpfs 不希望数据在主机或容器内持久存在时，最好使用挂载。这可能是出于安全原因，或者在应用程序需要编写大量非持久状态数据时保护容器的性能。</li>
</ul>
<h3 id="Volumes和Bind-mounts需要注意"><a href="#Volumes和Bind-mounts需要注意" class="headerlink" title="Volumes和Bind mounts需要注意"></a>Volumes和Bind mounts需要注意</h3><ul>
<li><p>如果将空卷装入容器中存在文件或目录的目录中，则会将这些文件或目录传播（复制）到卷中。同样，如果启动容器并指定尚不存在的卷，则会为您创建一个空卷。这是预先填充另一个容器所需数据的好方法。</p>
</li>
<li><p>如果将绑定装载或非空卷装入容器中存在某些文件或目录的目录中，则装载会遮盖这些文件或目录，就像将文件保存到/mntLinux主机上然后安装USB驱动器进入/mnt。/mnt在卸载USB驱动器之前，USB驱动器的内容会遮挡内容。隐藏的文件不会被删除或更改，但在安装绑定装载或卷时无法访问。</p>
</li>
</ul>
<h3 id="数据卷（Volumes）"><a href="#数据卷（Volumes）" class="headerlink" title="数据卷（Volumes）"></a>数据卷（Volumes）</h3><p>数据卷 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>
<ul>
<li><p>数据卷 可以在容器之间共享和重用</p>
</li>
<li><p>对 数据卷 的修改会立马生效</p>
</li>
<li><p>对 数据卷 的更新，不会影响镜像</p>
</li>
<li><p>数据卷 默认会一直存在，即使容器被删除</p>
</li>
</ul>
<blockquote>
<p>注意：数据卷 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 数据卷。</p>
</blockquote>
<h4 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ docker volume create my-vol</span><br></pre></td></tr></table></figure>

<h4 id="查看所有的-数据卷"><a href="#查看所有的-数据卷" class="headerlink" title="查看所有的 数据卷"></a>查看所有的 数据卷</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> $ docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               my-vol</span><br></pre></td></tr></table></figure>

<h4 id="在主机里使用以下命令可以查看指定-数据卷-的信息"><a href="#在主机里使用以下命令可以查看指定-数据卷-的信息" class="headerlink" title="在主机里使用以下命令可以查看指定 数据卷 的信息"></a>在主机里使用以下命令可以查看指定 数据卷 的信息</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ docker volume inspect my-vol</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"CreatedAt"</span>: <span class="string">"2019-05-19T08:22:09Z"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="string">"Labels"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="string">"Mountpoint"</span>: <span class="string">"/var/lib/docker/volumes/my-vol/_data"</span>,</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"my-vol"</span>,</span><br><span class="line">        <span class="string">"Options"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"local"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h4><p>在用 docker run 命令的时候，使用 -v和–mount 标记来将 数据卷 挂载到容器里。在一次 docker run 中可以挂载多个 数据卷。</p>
<h5 id="v或–mount的区别："><a href="#v或–mount的区别：" class="headerlink" title="-v或–mount的区别："></a>-v或–mount的区别：</h5><p>如果要指定数据卷的选项，则必须使用–mount。</p>
<ul>
<li><p>-v或–volume：由三个字段组成，用冒号字符（:）分隔。字段必须按正确的顺序排列，并且每个字段的含义不是很明显。</p>
<ul>
<li>对于命名卷，第一个字段是卷的名称，并且在给定主机上是唯一的。对于匿名卷，省略第一个字段。</li>
<li>第二个字段是文件或目录在容器中安装的路径。</li>
<li>第三个字段是可选的，是逗号分隔的选项列表，例如ro。这些选项将在下面讨论。</li>
</ul>
</li>
<li><p>–mount：由多个键值对组成，以逗号分隔，每个键<key>=<value>组由一个元组组成。该–mount语法比更详细的-v或–volume，但按键的顺序并不显著，并且标志的价值更容易理解。</p>
<ul>
<li>type是挂载类型，可以是bind，volume，或 tmpfs。本主题讨论卷，因此挂载类型始终是volume。</li>
<li>source，对于命名卷，这是卷的名称。对于匿名卷，省略此字段。可以指定为source 或src。</li>
<li>destination 文件或目录在容器中的路径。可以指定为destination，dst或target。</li>
<li>readonly（如果存在）导致绑定装入以只读方式装入容器中。</li>
<li>volume-opt 选项可以多次指定，它采用由选项名称及其值组成的键值对。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：如果启动的容器不存在挂载卷的路径，Docker会自动创建。</p>
</blockquote>
<ul>
<li>-v</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">  --name devtest \</span><br><span class="line">  -v myvol2:<span class="regexp">/app \</span></span><br><span class="line"><span class="regexp">  nginx:latest</span></span><br></pre></td></tr></table></figure>

<ul>
<li>–mount</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">  --name devtest \</span><br><span class="line">  --mount source=myvol2,target=<span class="regexp">/app \</span></span><br><span class="line"><span class="regexp">  nginx:latest</span></span><br></pre></td></tr></table></figure>

<h4 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h4><p>删除容器后，Docker数据卷仍然存在。</p>
<ul>
<li>例如，命名卷：具有来自容器外部的特定源awesome:/bar</li>
<li>匿名卷没有特定的源，因此在删除容器时，可以用–rm指令删除。</li>
</ul>
<h4 id="删除匿名卷"><a href="#删除匿名卷" class="headerlink" title="删除匿名卷"></a>删除匿名卷</h4><p>要自动删除匿名卷，需要使用–rm选项。例如，创建匿名/foo卷。删除容器后，Docker守护进程会删除/foo卷但不会删除awesome卷。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">docker run --rm -v /foo -v awesome:<span class="regexp">/bar busybox top</span></span><br></pre></td></tr></table></figure>

<h4 id="删除所有未使用的数据卷并释放空间："><a href="#删除所有未使用的数据卷并释放空间：" class="headerlink" title="删除所有未使用的数据卷并释放空间："></a>删除所有未使用的数据卷并释放空间：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">docker volume prune</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>find 命令</title>
    <url>/year/10/11/find-%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p>
<a id="more"></a>

<h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><blockquote>
<p>find(选项)(参数)</p>
</blockquote>
<h4 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h4><blockquote>
<p>-amin&lt;分钟&gt;：查找在指定时间曾被存取过的文件或目录，单位以分钟计算；</p>
<p>-anewer&lt;参考文件或目录&gt;：查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录；</p>
<p>-atime&lt;24小时数&gt;：查找在指定时间曾被存取过的文件或目录，单位以24小时计算；</p>
<p>-cmin&lt;分钟&gt;：查找在指定时间之时被更改过的文件或目录；</p>
<p>-cnewer&lt;参考文件或目录&gt;查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；</p>
<p>-ctime&lt;24小时数&gt;：查找在指定时间之时被更改的文件或目录，单位以24小时计算；</p>
<p>-daystart：从本日开始计算时间； -depth：从指定目录下最深层的子目录开始查找；</p>
<p>-expty：寻找文件大小为0 Byte的文件，或目录下没有任何子目录或文件的空目录；</p>
<p>-exec&lt;执行指令&gt;：假设find指令的回传值为True，就执行该指令；</p>
<p>-false：将find指令的回传值皆设为False；</p>
<p>-fls&lt;列表文件&gt;：此参数的效果和指定“-ls”参数类似，但会把结果保存为指定的列表文件； -follow：排除符号连接；</p>
<p>-fprint&lt;列表文件&gt;：此参数的效果和指定“-print”参数类似，但会把结果保存成指定的列表文件； -fprint0&lt;列表文件&gt;：此参数的效果和指定“</p>
<p>-print0”参数类似，但会把结果保存成指定的列表文件；</p>
<p>-fprintf&lt;列表文件&gt;&lt;输出格式&gt;：此参数的效果和指定“-printf”参数类似，但会把结果保存成指定的列表文件；</p>
<p>-fstype&lt;文件系统类型&gt;：只寻找该文件系统类型下的文件或目录；</p>
<p>-gid&lt;群组识别码&gt;：查找符合指定之群组识别码的文件或目录；</p>
<p>-group&lt;群组名称&gt;：查找符合指定之群组名称的文件或目录； -help或——help：在线帮助；</p>
<p>-ilname&lt;范本样式&gt;：此参数的效果和指定“-lname”参数类似，但忽略字符大小写的差别； -iname&lt;范本样式&gt;：此参数的效果和指定“-name”参数类似，但忽略字符大小写的差别；</p>
<p>-inum：查找符合指定的inode编号的文件或目录；</p>
<p>-ipath&lt;范本样式&gt;：此参数的效果和指定“-path”参数类似，但忽略字符大小写的差别；</p>
<p>-iregex&lt;范本样式&gt;：此参数的效果和指定“-regexe”参数类似，但忽略字符大小写的差别；</p>
<p>-links&lt;连接数目&gt;：查找符合指定的硬连接数目的文件或目录；</p>
<p>-iname&lt;范本样式&gt;：指定字符串作为寻找符号连接的范本样式；</p>
<p>-ls：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出；</p>
<p>-maxdepth&lt;目录层级&gt;：设置最大目录层级；</p>
<p>-mindepth&lt;目录层级&gt;：设置最小目录层级；</p>
<p>-mmin&lt;分钟&gt;：查找在指定时间曾被更改过的文件或目录，单位以分钟计算；</p>
<p>-mount：此参数的效果和指定“-xdev”相同； -mtime&lt;24小时数&gt;：查找在指定时间曾被更改过的文件或目录，单位以24小时计算；</p>
<p>-name&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式；</p>
<p>-newer&lt;参考文件或目录&gt;：查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；</p>
<p>-nogroup：找出不属于本地主机群组识别码的文件或目录；</p>
<p>-noleaf：不去考虑目录至少需拥有两个硬连接存在；</p>
<p>-nouser：找出不属于本地主机用户识别码的文件或目录；</p>
<p>-ok&lt;执行指令&gt;：此参数的效果和指定“-exec”类似，但在执行指令之前会先询问用户，若回答“y”或“Y”，则放弃执行命令；</p>
<p>-path&lt;范本样式&gt;：指定字符串作为寻找目录的范本样式；</p>
<p>-perm&lt;权限数值&gt;：查找符合指定的权限数值的文件或目录；</p>
<p>-print：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有“./”字符串；</p>
<p>-print0：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为全部的名称皆在同一行；</p>
<p>-printf&lt;输出格式&gt;：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式可以自行指定；</p>
<p>-prune：不寻找字符串作为寻找文件或目录的范本样式;</p>
<p>-regex&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式；</p>
<p>-size&lt;文件大小&gt;：查找符合指定的文件大小的文件； -true：将find指令的回传值皆设为True；</p>
<p>-typ&lt;文件类型&gt;：只寻找符合指定的文件类型的文件；</p>
<p>-uid&lt;用户识别码&gt;：查找符合指定的用户识别码的文件或目录；</p>
</blockquote>
<blockquote>
<p>-used&lt;日数&gt;：查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算；</p>
<p>-user&lt;拥有者名称&gt;：查找符和指定的拥有者名称的文件或目录；</p>
<p>-version或——version：显示版本信息；</p>
<p>-xdev：将范围局限在先行的文件系统中；</p>
<p>-xtype&lt;文件类型&gt;：此参数的效果和指定“-type”参数类似，差别在于它针对符号连接检查。</p>
</blockquote>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>起始目录：查找文件的起始目录。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><strong>根据文件或者正则表达式进行匹配</strong></p>
<p>列出当前目录及子目录下所有文件和文件夹</p>
<blockquote>
<p>find .</p>
</blockquote>
<p>在<code>/home</code>目录下查找以.txt结尾的文件名</p>
<blockquote>
<p>find /home -name “*.txt”</p>
</blockquote>
<p>同上，但忽略大小写</p>
<blockquote>
<p>find /home iname “*.txt”</p>
</blockquote>
<p>当前目录及子目录下查找所有以.txt和.pdf结尾的文件</p>
<blockquote>
<p>find . ( -name “<em>.txt” -o -name “</em>.pdf” )<br>或<br>find . -name “<em>.txt” -o -name “</em>.pdf”</p>
</blockquote>
<p>匹配文件路径或者文件</p>
<blockquote>
<p>find /usr/ -path “<em>local</em>“</p>
</blockquote>
<p>基于正则表达式匹配文件路径</p>
<blockquote>
<p>find . -regex “.*(.txt|.pdf)$”</p>
</blockquote>
<p>同上，但忽略大小写</p>
<blockquote>
<p>find . -iregex “.*(.txt|.pdf)$”</p>
</blockquote>
<h4 id="否定参数"><a href="#否定参数" class="headerlink" title="否定参数"></a>否定参数</h4><p>找<code>/home</code>路径下不是以.txt结尾的文件</p>
<blockquote>
<p>find /home ! -name “*.txt”</p>
</blockquote>
<p>根据文件类型进行搜索</p>
<blockquote>
<p>find . -type 类型参数</p>
</blockquote>
<h5 id="类型参数列表"><a href="#类型参数列表" class="headerlink" title="类型参数列表"></a>类型参数列表</h5><ul>
<li>f 普通文件</li>
<li>l 符号连接</li>
<li>d 目录</li>
<li>c 字符设备</li>
<li>b 块设备</li>
<li>s 套接字</li>
<li>p Fifo</li>
</ul>
<h4 id="基于目录深度搜索"><a href="#基于目录深度搜索" class="headerlink" title="基于目录深度搜索"></a>基于目录深度搜索</h4><p>向下最大深度限制为3</p>
<blockquote>
<p>find . -maxdepth 3 -type f</p>
</blockquote>
<p>搜索出深度距离当前目录至少2个子目录的所有文件</p>
<blockquote>
<p>find . -mindepth 2 -type f</p>
</blockquote>
<p>根据文件时间戳进行搜索</p>
<blockquote>
<p>find . -type f 时间戳</p>
</blockquote>
<p>UNIX/Linux文件系统每个文件都有三种时间戳：</p>
<ul>
<li>访问时间（-atime/天，-amin/分钟）：用户最近一次访问时间。</li>
<li>修改时间（-mtime/天，-mmin/分钟）：文件最后一次修改时间。</li>
<li>变化时间（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。</li>
</ul>
<p>搜索最近七天内被访问过的所有文件</p>
<blockquote>
<p>find . -type f -atime -7</p>
</blockquote>
<p>搜索恰好在七天前被访问过的所有文件</p>
<blockquote>
<p>find . -type f -atime 7</p>
</blockquote>
<p>搜索超过七天内被访问过的所有文件</p>
<blockquote>
<p>find . -type f -atime +7</p>
</blockquote>
<p>搜索访问时间超过10分钟的所有文件</p>
<blockquote>
<p>find . -type f -amin +10</p>
</blockquote>
<p>找出比file.log修改时间更长的所有文件</p>
<blockquote>
<p>find . -type f -newer file.log</p>
</blockquote>
<p>文件大小单元：</p>
<ul>
<li>b —— 块（512字节）</li>
<li>c —— 字节</li>
<li>w —— 字（2字节）</li>
<li>k —— 千字节</li>
<li>M —— 兆字节</li>
<li>G —— 吉字节</li>
</ul>
<p>搜索大于10KB的文件</p>
<blockquote>
<p>find . -type f -size +10k</p>
</blockquote>
<p>搜索小于10KB的文件</p>
<blockquote>
<p>find . -type f -size -10k \</p>
</blockquote>
<p>搜索等于10KB的文件</p>
<blockquote>
<p>find . -type f -size 10k</p>
</blockquote>
<h4 id="删除匹配文件"><a href="#删除匹配文件" class="headerlink" title="删除匹配文件"></a>删除匹配文件</h4><p>删除当前目录下所有.txt文件</p>
<blockquote>
<p>find . -type f -name “*.txt” -delete</p>
</blockquote>
<h3 id="根据文件权限-所有权进行匹配"><a href="#根据文件权限-所有权进行匹配" class="headerlink" title="根据文件权限/所有权进行匹配"></a>根据文件权限/所有权进行匹配</h3><p>当前目录下搜索出权限为777的文件</p>
<blockquote>
<p>find . -type f -perm 777</p>
</blockquote>
<p>找出当前目录下权限不是644的php文件</p>
<blockquote>
<p>find . -type f -name “*.php” ! -perm 644</p>
</blockquote>
<p>找出当前目录用户tom拥有的所有文件</p>
<blockquote>
<p>find . -type f -user tom</p>
</blockquote>
<p>找出当前目录用户组sunk拥有的所有文件</p>
<blockquote>
<p>find . -type f -group sunk</p>
</blockquote>
<h4 id="借助-exec选项与其他命令结合使用"><a href="#借助-exec选项与其他命令结合使用" class="headerlink" title="借助-exec选项与其他命令结合使用"></a>借助-exec选项与其他命令结合使用</h4><p>找出当前目录下所有root的文件，并把所有权更改为用户tom</p>
<blockquote>
<p>find .-type f -user root -exec chown tom {} ;</p>
</blockquote>
<p>上例中，{} 用于与-exec选项结合使用来匹配所有文件，然后会被替换为相应的文件名。 找出自己家目录下所有的.txt文件并删除</p>
<blockquote>
<p>find $HOME/. -name “*.txt” -ok rm {} ;</p>
</blockquote>
<p>上例中，-ok和-exec行为一样，不过它会给出提示，是否执行相应的操作。 查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中</p>
<blockquote>
<p>find . -type f -name “*.txt” -exec cat {} ;&gt; all.txt</p>
</blockquote>
<p>将30天前的.log文件移动到old目录中</p>
<blockquote>
<p>find . -type f -mtime +30 -name “*.log” -exec cp {} old ;</p>
</blockquote>
<p>找出当前目录下所有.txt文件并以“File:文件名”的形式打印出来</p>
<blockquote>
<p>find . -type f -name “*.txt” -exec printf “File: %s\n” {} ;</p>
</blockquote>
<p>因为单行命令中-exec参数中无法使用多个命令，以下方法可以实现在-exec之后接受多条命令</p>
<blockquote>
<p>-exec ./text.sh {} ;</p>
</blockquote>
<p>搜索但跳出指定的目录 查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk</p>
<blockquote>
<p>find . -path “./sk” -prune -o -name “*.txt” -print</p>
</blockquote>
<p>####find其他技巧收集</p>
<p>要列出所有长度为零的文件</p>
<blockquote>
<p>find . -empty</p>
</blockquote>
<p>转自: <a href="http://man.linuxde.net/find" target="_blank" rel="noopener">http://man.linuxde.net/find</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>github pages + Hexo博客域名绑定</title>
    <url>/year/04/13/github-pages-Hexo-%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h2 id="终于有自己的域名了！"><a href="#终于有自己的域名了！" class="headerlink" title="终于有自己的域名了！"></a>终于有自己的域名了！</h2><p><img src="http://ovlnt0xy1.bkt.clouddn.com/2018-04-13-15236108756974.jpg" alt=""></p>
<a id="more"></a>

<p>经过几番折腾，终于绑定好了域名，现在总结一下</p>
<h4 id="申请个人域名："><a href="#申请个人域名：" class="headerlink" title="申请个人域名："></a>申请个人域名：</h4><ul>
<li>首先你要有个域名，在<a href="https://wanwang.aliyun.com/" target="_blank" rel="noopener">万网</a>购买即可。（当然要注册阿里云账号。）</li>
<li><strong>域名实名认证</strong>，具体看<a href="https://help.aliyun.com/knowledge_detail/48263.html?spm=a2c4g.11186623.2.26.rUjij3" target="_blank" rel="noopener">这里</a>。</li>
<li>在<a href="https://whois.aliyun.com/?spm=5176.whzuorntop.10.4.218b39c62rDWWb" target="_blank" rel="noopener">域名信息查询（WHOIS）</a>确保自己的域名状态正常（如图）就可以开始配置啦！<br><img src="http://ovlnt0xy1.bkt.clouddn.com/2018-04-13-15236121614574.jpg" alt=""></li>
</ul>
<h4 id="域名添加dns解析："><a href="#域名添加dns解析：" class="headerlink" title="域名添加dns解析："></a>域名添加dns解析：</h4><ul>
<li>添加记录类型为<code>CNAME</code>、主机记录为<code>www</code> 、记录值为自己github二级域名的解析。</li>
<li>添加记录类型为<code>A</code>、主机记录为<code>@</code> 、记录值为自己github的ip地址的解析。 </li>
</ul>
<p>通过ping 自己的gihub二级域名可获取ip<br><img src="http://ovlnt0xy1.bkt.clouddn.com/2018-04-13-15236134421366.jpg" alt=""></p>
<p><img src="http://ovlnt0xy1.bkt.clouddn.com/2018-04-13-15236126374864.jpg" alt=""><br>添加完成勾选点击启用，状态为–即可。</p>
<h4 id="创建CNAME文件："><a href="#创建CNAME文件：" class="headerlink" title="创建CNAME文件："></a>创建CNAME文件：</h4><p>在hexo本地目录<code>source</code>下新建CNAME（无后缀）文件并填入自己的域名，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">zuorn.top</span><br><span class="line">www.zuorn.top</span><br></pre></td></tr></table></figure>

<p>重新生成上传：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>

<h4 id="github域名绑定："><a href="#github域名绑定：" class="headerlink" title="github域名绑定："></a>github域名绑定：</h4><p>打开博客在github中的地址，点击<code>Settings</code>，修改<code>Custom domain</code>为我们自己的域名保存即可。</p>
<p><img src="http://ovlnt0xy1.bkt.clouddn.com/2018-04-13-15236140425982.jpg" alt=""></p>
<p>这个时候在浏览器当中输入域名就可以顺利打开了。</p>
<p><img src="http://ovlnt0xy1.bkt.clouddn.com/2018-04-13-15236143444491.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>黑暗面</title>
    <url>/year/10/28/heianmian/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk4hy9ccocj315o0ld0v8.jpg" alt="img"></p>
<a id="more"></a>

<p>今天看了一部科幻惊悚片——《彗星来的那一夜》。老实讲，第一次看到这个名字我以为是部爱情片，或者至少也应该是个温暖的故事。可观影体验真的很让人头晕，一方面是电影呈现的画面抖动，另一方面是让人摸不着头脑的叙事，所以在刚看完我是一头雾水的。</p>
<p>现在明白了一些，也明白的不多，因为电影解读的角度可以很多，而且电影涉及的物理学理论真的很难让人有去深入了解的欲望，不过其中的一个点很有趣。就是在多重宇宙，或者平行宇宙由于某些原因相互重叠的情况下，你接触到了好多个平行宇宙中的自己，其中有的宇宙里的你是人生赢家，有的则彻头彻尾的失败，而你正好有机会混入另一个你人生得意的宇宙里来替代自己，而让那个宇宙里的自己来承担自己所面临的不怎么如意的人生，你会这么做吗？</p>
<p>我的直觉反应当然是不会，可是在我深思之后及电影的表达来看… 可能是会的。</p>
<p>电影里的一句台词很值得思考——“我们认为某一个世界里存在着另一个更黑暗的自己，其实，我们就是那个黑暗面。”</p>
<p>我不知道该怎么理解这句话，我首先想到的是自我同一性的问题。即其他宇宙里的我是不是我？如果是，那么问题就比较简单了，也就是说我作为多个我的存在，实际同属于一个我，那么我的黑暗也同属于任何一个平行宇宙里的我的黑暗，自然明亮也是。可问题似乎不是这样，明显其中的我与我存在着巨大的差异，自然有相对黑暗的我和相对光明的我，可为什么我就是那个黑暗面呢？难道说其他的我都比我要光明吗？我想也不是这样。自然每个不同的我自身都存在着黑暗的可能，或者说每个不同的自我都存在着黑暗面。可为什么说我，这个平行宇宙里的我就是那个黑暗面呢？难道每个宇宙里面的我不都是黑暗面吗？</p>
<p>想到这里我意识到自己忽略了一个很重要的前提，就是句子的前半句，我们以为某个世界里存在着某个更黑暗的自己。或许电影表达的是当我们这样想的时候已经印证了我们就是那个黑暗面。</p>
<p>另外电影开头的部分的一句台词讲述了电影结尾即将要发生的事情——“不，这不是我丈夫，因为昨天我刚把丈夫杀死了，所以我才知道不是他。”</p>
<p>可能别人以为她发疯，可看完电影我只能说细思极恐。不是由于她杀死了自己的丈夫，而是他的丈夫也是一个黑暗面。</p>
<hr>
<p>没有最黑暗而只有更黑暗的自己。你的观点很有趣，就好比我打算干一件坏事时拿那些比自己干的坏事更坏的人来做对比，然后就心安理得的坏事了。可这是用于同一个人吗？因为我曾经干过更坏的事情所以现在干些小坏事也心安理得吗？</p>
<p>曾经的我是我吗？显然是的。可为什么曾经我就是我呢？问题在于连续性，就是曾经的我和现在的我无论在那种角度来看都判若两人，但现在的我确实是曾经的我变化而来的，而这种变化是连续的，所以我们只能认为曾经的那个我也是自己。</p>
<p>再来看平行宇宙中的例子，就好像从我的一开始就有无数个分支同时存在，互不干扰的发生着种种变化。可由于某种原因（量子相干性）某天这种互不干扰纠缠在了一起，于是我神奇的见到我自己，或者说我见到了我自己的分支。当然这并不是主要的问题，因为我有多少个分支就对应有着多少个我所在的宇宙的分支。问题在于道德，在这种相干性的神奇影响下我见到了我自己，从而也唤起了我内心的恶。并且这种恶超越了法律的边界。</p>
<p>我以谋杀另一个宇宙的自己并取而代之，而大家都以为在我所在的宇宙中是我遭遇了不幸。于是我过上了别人的人生。这正是我所理解的黑暗面。</p>
<p>当然，这只是电影，饭后余思的故事。在真实的生活中自然不会有这种怪异的事情发生。可是的确有另外一种怪异的事情却确实的存在，就是多重人格。</p>
<p>想象一个多重人格的患者，他在某些时刻是A人格而某些时刻是B人格。他究竟是谁？假如他犯罪又该怎样去审判？或者我们又如何确切的知道自己不是一个多重人格的患者呢？当我作出那些令人费解的事情时，怎么又能确切的知道那件事就是自己所做而非在自身存在的另一个自己所为而共享了记忆呢？或者干脆自己的从来都没有支配过自己，而始终是一个记忆的容器。</p>
<p>那个容器是自己吗？</p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title>Hammerspoon - 岂止于窗口管理</title>
    <url>/year/07/06/hammerspoon/</url>
    <content><![CDATA[<blockquote>
<p>为什么要费尽心思的用键盘替代鼠标操作。</p>
</blockquote>
<p>在使用电脑的过程中，最优先的操作方式应该是<strong>键盘</strong>，而次等的方式才是鼠标，因为鼠标需要使用者在键盘和鼠标之间来回切换，因此影响效率。而 <strong>“纯键盘操作”</strong> 需要使用者记忆大量的键位和操作模式，所以<strong>纯键盘</strong>从来都是高阶操作。</p>
<p>鼠标长久以来都是顺应人的本能去设计的。但高阶操作是什么？高阶操作就是训练人克服本能，用<strong>更有效</strong>、<strong>更科学</strong>的但<strong>非本能</strong>的方式去应对，所以才需要大量的练习，大量的实战，从而形成<a href="https://baike.baidu.com/item/%E8%82%8C%E8%82%89%E8%AE%B0%E5%BF%86" target="_blank" rel="noopener">肌肉记忆</a>和<a href="https://baike.baidu.com/item/%E6%80%9D%E7%BB%B4%E5%AE%9A%E5%8A%BF?fromtitle=%E6%80%9D%E7%BB%B4%E6%83%AF%E6%80%A7&fromid=3457840" target="_blank" rel="noopener">思维定势</a>去对抗本能。vim 如此,Hammerspoon 也如此。</p>
<p>有些了解过 Hammerspoon 可能把它看作一款窗口管理工具，用此来替代 Magent 等付费工具，但 Hammerspoon 的玩法绝不仅于此，本文将介绍 Hammerspoon 及我的配置。</p>
<a id="more"></a>



<h3 id="Hammerspoon介绍"><a href="#Hammerspoon介绍" class="headerlink" title="Hammerspoon介绍"></a>Hammerspoon介绍</h3><blockquote>
<p><a href="http://www.hammerspoon.org/" target="_blank" rel="noopener">Hammerspoon</a> 是一款<strong>免费开源</strong>的 app，通过桥接操作系统与 Lua 脚本引擎的方式，让我们可以通过编写 <a href="http://www.lua.org/docs.html" target="_blank" rel="noopener">Lua</a> 代码来实现操作应用程序、窗口、鼠标、文本、音频设备、电池、屏幕、剪切板、定位、wifi等。基本囊括了系统的各方面。</p>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li><p>通过 Homebrew 安装：<br>（如果不了解 <code>Homebrew</code> 看<a href="https://zuorn.top/year/05/22/homebrew-yuan/" target="_blank" rel="noopener">这里</a>。）</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew cask install hammerspoon</span><br></pre></td></tr></table></figure></li>
<li><p>手动下载安装：<a href="https://github.com/Hammerspoon/hammerspoon/releases/tag/0.9.75" target="_blank" rel="noopener">https://github.com/Hammerspoon/hammerspoon/releases/tag/0.9.75</a> 然后将应用程序拖到<code>/Applications/</code>。</p>
</li>
</ul>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4q4yawr88j30ee0bydgm.jpg" alt=""></p>
<p>第一次打开需要授予辅助功能权限，点击 <code>Enable Accessibility</code>即可。此时在 <code>~/.hammerspoon/init.lua</code> 写入自己的配置文件在 Hammerspoon 单栏图标并选择 <code>Reload Config</code> 重载配置即可生效。</p>
<h2 id="配置与升级"><a href="#配置与升级" class="headerlink" title="配置与升级:"></a>配置与升级:</h2><p>将配置文件克隆到本地根目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;zuorn&#x2F;hammerspoon_config ~&#x2F;.hammerspoon</span><br></pre></td></tr></table></figure>
<p>重新加载配置文件即可生效。</p>
<p>如果提示：already exists and is not an empty directory.<br>先删除目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf ~&#x2F;.hammerspoon</span><br></pre></td></tr></table></figure>

<p>升级：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;.hammerspoon &amp;&amp; git pull</span><br></pre></td></tr></table></figure>

<h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><blockquote>
<p>本配置基于 vim 风格，实现了窗口管理，剪切板，倒计时，快速启动等功能。所有模式按照指定快捷键进入，所有模式都可以用 <code>esc</code> 或 <code>q</code>退出。在进入对应模式之前只有模式快捷键生效，进入对应模式之后此模式的操作快捷键生效。</p>
</blockquote>
<p>可以按下快捷键 <code>shift</code> + <code>option</code> + <code>/</code> 显示帮助面板查看各个模式快捷键。再按照提示切换模式。</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4q4xvmcbvj316o0i00ul.jpg" alt=""></p>
<h3 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h3><p>按下前缀键 <code>Option</code> + <code>R</code> 进入窗口管理模式：</p>
<ul>
<li><p>使用 <code>h、j、k、l</code> 移动为上下左右的半屏</p>
</li>
<li><p>使用 <code>y、u、i、o</code>（即 hjkl 上方按键）移动为左上/左下/右上/右下的四分之一窗口</p>
</li>
<li><p>使用 <code>c</code> 居中，按下 <code>=、-</code> 进行窗口大小缩放</p>
</li>
<li><p>使用 <code>w、s、a、d</code> 向上下左右移动窗口</p>
</li>
<li><p>使用 <code>H、J、K、L</code> 向左/下增减窗口大小</p>
</li>
<li><p>使用方向键 <code>上、下、左、右</code> 移动到相应方向上的显示器（多块显示器的话）</p>
</li>
<li><p>使用 <code>[,]</code> 左三分之二屏和右三分之二屏</p>
</li>
<li><p>使用 <code>空格</code> 将窗口投送到另外一块屏幕（假如有两块以上显示器的话）</p>
</li>
<li><p>使用 <code>t</code> 光标移动到所在窗口的中间位置</p>
</li>
<li><p>使用 <code>tab</code> 显示帮助面板，查看键位图</p>
</li>
<li><p>使用 q 或 Esc 退出管理</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4pz9dhogwj31c00u04aw.jpg" alt="">   </p>
</li>
</ul>
<h3 id="应用快速切换"><a href="#应用快速切换" class="headerlink" title="应用快速切换"></a>应用快速切换</h3><p>按下前缀键 <code>Option</code> + <code>tab</code> 显示窗口提示，按下对应应用显示的字母快速切换。<br><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4q4x5cxatj31z40u0k5e.jpg" alt=""></p>
<h3 id="展示应用快捷键"><a href="#展示应用快捷键" class="headerlink" title="展示应用快捷键"></a>展示应用快捷键</h3><p>按下快捷键 <code>Option</code> + <code>s</code> 展示当前应用快捷键。</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4q4wsyk6lj31z40u0n5i.jpg" alt=""></p>
<h3 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h3><p>按下快捷键 <code>Option</code> + <code>a</code> 打开快速启动，按下对应字母快速打开应用。</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4q4w5a6e8j31z40u0gvs.jpg" alt=""></p>
<h3 id="AClock-显示当前时间"><a href="#AClock-显示当前时间" class="headerlink" title="AClock - 显示当前时间"></a>AClock - 显示当前时间</h3><p>按下 <code>Option</code> + <code>t</code> 显示当前时间。</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4q4utqg63j31z40u0tng.jpg" alt=""></p>
<h3 id="倒计时（番茄钟）"><a href="#倒计时（番茄钟）" class="headerlink" title="倒计时（番茄钟）"></a>倒计时（番茄钟）</h3><p>按下 <code>Option</code> + <code>i</code> 打开倒计时面板，按下对应数字开始计时。</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4q4w5a6e8j31z40u0gvs.jpg" alt=""></p>
<h3 id="系统剪切板"><a href="#系统剪切板" class="headerlink" title="系统剪切板"></a>系统剪切板</h3><p>按下 <code>Option</code> + <code>c</code> 打开剪切板面板。</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4q4u4g2jgj31z40u0gvb.jpg" alt=""></p>
<p>功能：</p>
<ul>
<li>保存会话</li>
<li>恢复上一个会话</li>
<li>在浏览器中打开</li>
<li>使用百度搜索</li>
<li>使用谷歌搜索</li>
<li>保存到桌面</li>
<li>使用 github 搜索</li>
<li>在 Sublime Text 打开</li>
</ul>
<h3 id="顶部菜单栏实时显示网速"><a href="#顶部菜单栏实时显示网速" class="headerlink" title="顶部菜单栏实时显示网速"></a>顶部菜单栏实时显示网速</h3><p>没有对应快捷键，默认开启。</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4q4tni77ej30ks0a2myp.jpg" alt=""></p>
<h3 id="其他快捷键"><a href="#其他快捷键" class="headerlink" title="其他快捷键"></a>其他快捷键</h3><ul>
<li>粘贴 chrome 或 safari 打开最前置的网址：<code>option</code> + <code>v</code></li>
<li>显示 Hammerspoon 控制台： <code>option</code> + <code>v</code></li>
<li>锁定电脑快捷键：<code>option</code> + <code>l</code></li>
<li>重新加载配置文件： <code>cmd</code> +  <code>shift</code> + <code>ctrl</code> + <code>r</code></li>
<li>临时禁用所有快捷键(注意：只能手动接禁。)：<code>cmd</code> +  <code>shift</code> + <code>ctrl</code> + <code>q</code></li>
</ul>
<h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>拷贝私有配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp ~&#x2F;.hammerspoon&#x2F;config-example.lua ~&#x2F;.hammerspoon&#x2F;private&#x2F;config.lua</span><br></pre></td></tr></table></figure>
<p>按照注释编辑私有配置文件 <code>~/.hammerspoon/private/config.lua</code> 即可。</p>
<h2 id="其他功能（后续实现）"><a href="#其他功能（后续实现）" class="headerlink" title="其他功能（后续实现）"></a>其他功能（后续实现）</h2><ul>
<li>按下前缀键滚动鼠标滚轮调节系统音量</li>
<li>添加鼠标模式，进入鼠标模式后按下对应按键实现鼠标所有按键。</li>
<li>切换 wifi 提醒</li>
<li>显示已安装卷的列表以及桌面上每个指示可用空间的饼图</li>
<li>连接/断开耳机时播放/暂停音乐播放器</li>
<li>添加音乐控制模式，进入后通过按键控制 网易云音乐 和 iTunes</li>
</ul>
<h4 id="可自定义范围："><a href="#可自定义范围：" class="headerlink" title="可自定义范围："></a>可自定义范围：</h4><ul>
<li><p>指定要启用模块</p>
<p>  找到配置文件启用模块，注释对应模块可禁止用对应功能。</p>
</li>
<li><p>绑定快速启动 app 及快捷键</p>
</li>
<li><p>自定义模式快捷键</p>
</li>
<li><p>自定义 hammerspoon 快捷键绑定</p>
</li>
</ul>
<h2 id="自己写配置"><a href="#自己写配置" class="headerlink" title="自己写配置"></a>自己写配置</h2><p>Lua 是一种非常简单的语言，没有编程经验也很容易上手。hammerspoon 官方也提供了一份<a href="http://www.hammerspoon.org/go/" target="_blank" rel="noopener">教程</a>，或者看看<a href="https://www.runoob.com/lua/lua-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a>。</p>
<p>官方还有很多现成的 <a href="https://www.hammerspoon.org/Spoons/" target="_blank" rel="noopener">Spoons 勺子？</a> 可以用，有些直接拿来绑定一下键位就可以直接用了，如果觉得官方勺子不符合自己的需求，你也可以把它改成自己想要的样子。多看看官方文档和相关的文章，以及官方勺子的源码，就很容易定制一个属于自己独一无二的神器。</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="https://www.hammerspoon.org/Spoons/" target="_blank" rel="noopener">Hammerspoon Spoons</a></li>
<li><a href="https://github.com/ashfinal/awesome-hammerspoon" target="_blank" rel="noopener">awesome-hammerspoon</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo n 时默认打开markdown编辑器</title>
    <url>/year/04/10/hexo-n-%E6%97%B6%E5%80%99%E9%BB%98%E8%AE%A4%E6%89%93%E5%BC%80markdown%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<p><img src="https://blog-1256335675.cos.ap-chengdu.myqcloud.com/2019-06-18-006tKfTcgy1fqa9b4cyrwj30m608mq3g.jpg" alt=""></p>
<a id="more"></a>

<p>首先：</p>
<blockquote>
<ul>
<li>在Hexo目录下的<code>scripts</code>目录中创建一个<code>JavaScript</code>脚本文件。</li>
</ul>
</blockquote>
<ul>
<li>如果没有这个<code>scripts</code>目录，则新建一个。</li>
<li><code>scripts</code>目录新建的<code>JavaScript</code>脚本文件可以任意取名。</li>
</ul>
<p>通过这个脚本，我们用其来监听hexo new这个动作，并在检测到hexo new之后，执行编辑器打开的命令。</p>
<p>windows平台的Hexo用户，则将下列内容写入你的脚本：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).exec;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hexo 2.x 用户复制这段</span></span><br><span class="line">hexo.on(<span class="string">'new'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">path</span>)</span>&#123;</span><br><span class="line">  spawn(<span class="string">'start  "markdown编辑器绝对路径.exe" '</span> + path);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hexo 3 用户复制这段</span></span><br><span class="line">hexo.on(<span class="string">'new'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  spawn(<span class="string">'start  "markdown编辑器绝对路径.exe" '</span> + data.path);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Mac平台Hexo用户，则将下列内容写入你的脚本：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> exec = <span class="built_in">require</span>(<span class="string">'child_process'</span>).exec;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hexo 2.x 用户复制这段</span></span><br><span class="line">hexo.on(<span class="string">'new'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">path</span>)</span>&#123;</span><br><span class="line">    exec(<span class="string">'open -a "markdown编辑器绝对路径.app" '</span> + path);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hexo 3 用户复制这段</span></span><br><span class="line">hexo.on(<span class="string">'new'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    exec(<span class="string">'open -a "markdown编辑器绝对路径.app" '</span> + data.path);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>保存并退出脚本之后，在命令行中键入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">"auto open editor test"</span></span><br></pre></td></tr></table></figure>

<p>就可以顺利打开自动生成的md文件了。</p>
<p>原文转自：<a href="https://notes.wanghao.work/2015-06-29-Hexo%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E6%97%B6%E8%87%AA%E5%8A%A8%E6%89%93%E5%BC%80%E7%BC%96%E8%BE%91%E5%99%A8.html" target="_blank" rel="noopener">这里～</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo速度优化，gulp压缩静态资源</title>
    <url>/year/01/25/hexo%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%EF%BC%8Cgulp%E5%8E%8B%E7%BC%A9%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<blockquote>
<p>hexo生成的的public文件夹里的源文件有很多空白，这些空白占据一定空间。<a href="https://www.gulpjs.com.cn/" target="_blank" rel="noopener">gulp</a>可以高效的压缩这些静态资源，从而提高访问速度。</p>
</blockquote>
<a id="more"></a>

<h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><p>安装<code>gulp</code>工具</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install gulp</span><br></pre></td></tr></table></figure>
<p>安装gulp模块：</p>
<pre><code>gulp-htmlclean // 清理html
gulp-htmlmin // 压缩html
gulp-minify-css // 压缩css
gulp-uglify // 混淆js</code></pre><p>安装命令：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify --save</span><br></pre></td></tr></table></figure>

<h4 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h4><p>在站点根目录下新建<code>gulpfile.js</code>文件，内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Plugins模块获取</span></span><br><span class="line"><span class="keyword">var</span> minifycss = <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlclean = <span class="built_in">require</span>(<span class="string">'gulp-htmlclean'</span>);</span><br><span class="line"><span class="comment">//压缩css</span></span><br><span class="line">gulp.task(<span class="string">'minify-css'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>)</span><br><span class="line">.pipe(minifycss())</span><br><span class="line">.pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//压缩html</span></span><br><span class="line">gulp.task(<span class="string">'minify-html'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.html'</span>)</span><br><span class="line">.pipe(htmlclean())</span><br><span class="line">.pipe(htmlmin(&#123;</span><br><span class="line">removeComments: <span class="literal">true</span>,</span><br><span class="line">minifyJS: <span class="literal">true</span>,</span><br><span class="line">minifyCSS: <span class="literal">true</span>,</span><br><span class="line">minifyURLs: <span class="literal">true</span>,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">.pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//压缩js 不压缩min.js</span></span><br><span class="line">gulp.task(<span class="string">'minify-js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> gulp.src([<span class="string">'./public/**/*.js'</span>, <span class="string">'!./public/**/*.min.js'</span>])</span><br><span class="line">.pipe(uglify())</span><br><span class="line">.pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.0以前的写法 </span></span><br><span class="line"><span class="comment">//gulp.task('default', [</span></span><br><span class="line">  <span class="comment">//  'minify-html', 'minify-css', 'minify-js'</span></span><br><span class="line"><span class="comment">//]);</span></span><br><span class="line"><span class="comment">//4.0以后的写法</span></span><br><span class="line"><span class="comment">// 执行 gulp 命令时执行的任务</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, gulp.parallel(<span class="string">'minify-html'</span>, <span class="string">'minify-css'</span>, <span class="string">'minify-js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something after a, b, and c are finished.</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>命令：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hexo clean <span class="comment">//先清理文件</span></span><br><span class="line">hexo g  <span class="comment">//编译生成静态文件</span></span><br><span class="line">gulp  <span class="comment">//gulp插件执行压缩任务</span></span><br><span class="line">hexo s <span class="comment">//开启服务</span></span><br></pre></td></tr></table></figure>

<p>当然，通过一个命令也可以：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hexo g &amp;&amp; gulp -d</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>《荒原狼》 - 摘抄</title>
    <url>/year/05/27/hyl/</url>
    <content><![CDATA[<blockquote>
<p>人们对“人”这个概念的理解始终只不过是短暂的市民协议而已。</p>
</blockquote>
<a id="more"></a>

<h3 id="对抗自己"><a href="#对抗自己" class="headerlink" title="对抗自己"></a>对抗自己</h3><hr>
<p>憎恨自己，整整一生。他把全部的天才的想象、全部的思维能力都用来反对自己，反对这个无辜而高尚的对象。不管怎么样，他把辛酸的讽刺、尖刻的批评、一切仇恨与恶意首先向自己发泄。</p>
<p>他是一个受苦的天才，按尼采的某些说法，他磨炼造就了受苦的天才能力，能够没完没了地忍受可怕的痛苦。他的悲观的基础不是鄙视世界，而是鄙视自己，因为在他无情鞭笞、尖锐批评各种机构、各式任务时，从不把自己排除在外，他的箭头总是先对准自己，他憎恨和否定的第一个人就是自己…</p>
<p>他的心灵正在走向死亡。</p>
<h3 id="双重人格"><a href="#双重人格" class="headerlink" title="双重人格"></a>双重人格</h3><hr>
<p>处于两种时代交替时期的人，他们是去了安全感，不在感到清白无辜，他们的命运就是怀疑人生，把人生是否哟意义这个问题作为个人的痛苦和劫数加以体验。</p>
<p>他们的理想不是牺牲自我，而是保持自我，他们努力追求的既不是高尚的德行，当个圣人，也不是它的对立面，他们最不能忍受的是不达目的决不罢休的精神，他虽然侍奉上帝，但又想满足自己的欲望。他虽然愿意做个仁人君子，但又想在人世间过舒适安逸的日子。总而言之，他们企图在两个极端的中间，在没有狂风暴雨的温和舒适的地带安居乐业，他们成功地做到了这一点，不过放弃了某些东西：他们的生活和感情缺乏那种走极端、不达目的不罢休的人所具有的紧张与强度。只有牺牲自我才能积极地生活。</p>
<h3 id="反受其害"><a href="#反受其害" class="headerlink" title="反受其害"></a>反受其害</h3><hr>
<p>上帝造人是叫他生活，不是叫他思考！因为，谁思考，谁把思考当作首要的大事，他固然能在思考方面有所建树，然而他却颠倒了陆地与水域的关系，所以他总有一天会被淹死。</p>
<p>他得到了他为本性所使而苦苦追求的东西，但是得之太多反受其害了。开始，这是他的梦想和幸福，后来就变成了他痛苦的命运。追求权力的人毁于权力，追求金钱的人毁于金钱，低声下气的人毁于卑躬屈膝，追求享乐的人毁于行乐。正是同样的道理，荒原狼毁于我行我素。他达到了目的，他越来越随心所欲，没有人能给他发号施令，他不用看别人的眼色行事，他的一言一行都由他自己自由决定。因为每个意志坚强的人都能得到他真正的内心冲动驱使他追求的东西。哈里得到了他的自由，但是他突然发现，他的自由就是死亡，他现在非常孤独，外界谁也不来打扰他，这使他觉得非常可怕，各式人等都和他毫不相干，连他自己也和自己没有什么关系，他在越来越稀薄的与人无关的孤独的空气中慢慢窒息而死。现在的情况是，孤独和绝对自主已经不再是他的愿望和目的，而是他的厄运，是对他的判决了，用魔术呼唤出来的东西再也收不回去了。现在，当他充满渴望、怀着良好的意愿，伸开双臂准备接受约束，准备和他人共同生活时，已经无济于事了，现在谁也不来理会他了。其实，并不是人们憎恨他，讨厌他。相反，他有许多朋友。许多人喜欢他。但是他得到的始终只是同情和友好的态度。人们请他作客，赠礼给他，给他写亲切的书信，但没有人真正接近他，他和其他人没有任何亲近感，没有人愿意并能够和他一起生活。包围他的是孤独的空气和宁静的气氛，周围的一切都从他身边溜走，他没有能力建立各种关系，意志和渴望都不能帮助他克服这种无能。这是他生活的重要特征之一。</p>
<h3 id="原则性的错觉"><a href="#原则性的错觉" class="headerlink" title="原则性的错觉"></a>原则性的错觉</h3><hr>
<p>原则性的错觉。所有的“解释”，所有的心理学，所有的探讨都需要辅助手段，需要理论、神话、谎言；一个正直的作者应该在他论述的结尾尽量澄清这些谎言。假如我说有“上”“下”之分，那么这就是一种观点，要求进一步得到解释，因为只有在思想中，在抽象概念中才有上下之分。世界本身并没有上下。 简而言之，“荒原狼”也同于此理，只是一种幻觉。如果说哈里觉得自己是一个狼人，自认为是由互相敌视的、对立的两种性格组成的，那么，这只是一种简化的神话。哈里根本不是狼人，假如我们表面上似乎不假思索地接受了他的谎言，接受了他自己虚构并信以为真的谎言，真的把他看作双重性格的人，看作荒原狼，并且据此加以解释的话，那么，我们是因为希望容易为人理解的缘故利用了一种错觉，这种错觉现在应该得到纠正。</p>
<h3 id="整体"><a href="#整体" class="headerlink" title="整体"></a>整体</h3><hr>
<p>所有的人似乎都具有一种天生的、必然的需要，把自我想象为一个整体。这种狂热尽管会经常地受到巨大的冲击而动摇，但它每次都能复原如旧。坐在杀人犯面前的法官直盯着他的眼睛，在某一瞬间，他听见杀人犯用他（法官）的声音说话，他在自己的内心深处也发现有杀人犯的感情、能力和可能性，但他很快又变成了一个整体，又成了法官，转身回到想象中的自我的躯壳中，行使他的职责，判处杀人犯死刑。</p>
<h3 id="自杀"><a href="#自杀" class="headerlink" title="自杀"></a>自杀</h3><hr>
<p>只把那些真正自尽的人成为自杀者是错误的。这类人中是由于偶然的原因才成为自杀者的，自杀并不一定是他们的本性。在这些没有个性、没有明显的特点、没有经历命运折磨的普普通通的人中，有些人用自杀了却了医生，但就他们的本性与特点来说，他们并不属于自杀者的类型；相反，那些按本质属于自杀者的人中却有许多人 – 也就是大部分人 – 从不曾损伤过自己的一根毫毛。</p>
<p>任何失望、痛苦、恶劣的生活境遇会马上唤醒潜伏在他身上以一死而求解脱的愿望。久而久之，他却把这种倾向，发展成一套有益于生的哲学。他想，那扇太平门始终为他敞开着，这种想法给他力量，使他好奇，去饱尝各种痛苦与劣境，在他遭遇不幸的时候，有时他会有一种类似幸灾乐祸的感觉，他想：“我倒要看看，一个人到底能够忍受多少苦难！一旦到了忍无可忍的地步，我把太平门移开就拜托了劫数。“许多自杀者就是因为有这样的想法而获得巨大的力量。</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>更换 HomeBrew 镜像源及常用命令</title>
    <url>/year/05/22/homebrew-yuan/</url>
    <content><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g39tijtyf5j31fe0do0ut.jpg" alt=""></p>
<blockquote>
<p>解决 brew install xxx 慢的问题。</p>
</blockquote>
<a id="more"></a>

<p>HomeBrew 官网： <a href="https://brew.sh" target="_blank" rel="noopener">https://brew.sh</a></p>
<h2 id="更换brew镜像源"><a href="#更换brew镜像源" class="headerlink" title="更换brew镜像源"></a>更换brew镜像源</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入brew主目录</span><br><span class="line">$ cd &#96;brew --repo&#96;</span><br><span class="line"></span><br><span class="line"># 更换镜像</span><br><span class="line">$ git remote set-url origin https:&#x2F;&#x2F;git.coding.net&#x2F;homebrew&#x2F;homebrew.git</span><br><span class="line"></span><br><span class="line"># 测试效果</span><br><span class="line">$ brew update</span><br></pre></td></tr></table></figure>


<h3 id="几个镜像"><a href="#几个镜像" class="headerlink" title="几个镜像:"></a>几个镜像:</h3><ul>
<li><a href="https://git.coding.net/homebrew/homebrew.git" target="_blank" rel="noopener">https://git.coding.net/homebrew/homebrew.git</a> - Coding</li>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git</a> - 清华</li>
<li><a href="https://mirrors.ustc.edu.cn/brew.git" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/brew.git</a> - 中科大</li>
</ul>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul>
<li><a href="https://blog.csdn.net/lwplwf/article/details/79097565" target="_blank" rel="noopener">Mac下更换Homebrew镜像源</a></li>
</ul>
<h2 id="附——常用命令"><a href="#附——常用命令" class="headerlink" title="附——常用命令"></a>附——常用命令</h2><p>安装卸载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew search text 搜索本地远程仓库的软件，已安装会显示绿色的勾</span><br><span class="line">brew install &lt;formula&gt; 安装指定软件</span><br><span class="line">brew unistall &lt;formula 卸载指定软件</span><br><span class="line">brew list 显示所有的已安装的软件</span><br></pre></td></tr></table></figure>

<p>升级软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew update 自动升级homebrew（从github下载最新版本）</span><br><span class="line">brew outdated 检测已经过时的软件</span><br><span class="line">brew upgrade 升级所有已过时的软件，即列出的以过时软件</span><br><span class="line">brew upgrade &lt;formula&gt;升级指定的软件</span><br><span class="line">brew pin &lt;formula&gt; 禁止指定软件升级</span><br><span class="line">brew unpin &lt;formula&gt; 解锁禁止升级</span><br><span class="line">brew upgrade --all 升级所有的软件包，包括未清理干净的旧版本的包</span><br></pre></td></tr></table></figure>


<p>清理相关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew cleanup -n 列出需要清理的内容</span><br><span class="line">brew cleanup &lt;formula&gt; 清理指定的软件过时包</span><br><span class="line">brew cleanup 清理所有的过时软件</span><br><span class="line">brew unistall &lt;formula&gt; 卸载指定软件</span><br><span class="line">brew unistall &lt;fromula&gt; --force 彻底卸载指定软件，包括旧版本</span><br></pre></td></tr></table></figure>

<h4 id="参考：HomeBrew常规使用教程"><a href="#参考：HomeBrew常规使用教程" class="headerlink" title="参考：HomeBrew常规使用教程"></a>参考：<a href="https://juejin.im/post/5a559b9f6fb9a01cba42772f" target="_blank" rel="noopener">HomeBrew常规使用教程</a></h4>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>iterm2快捷键</title>
    <url>/year/09/19/iterm2%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h3 id="标签："><a href="#标签：" class="headerlink" title="标签："></a>标签：</h3><blockquote>
<p>新建标签：command + t</p>
</blockquote>
<blockquote>
<p>关闭标签：command + w</p>
</blockquote>
<blockquote>
<p>切换标签：command + 数字 command + 左右方向键</p>
</blockquote>
<blockquote>
<p>切换全屏：command + enter</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>查找：command + f</p>
</blockquote>
<h3 id="分屏："><a href="#分屏：" class="headerlink" title="分屏："></a>分屏：</h3><blockquote>
<p>垂直分屏：command + d</p>
</blockquote>
<blockquote>
<p>水平分屏：command + shift + d</p>
</blockquote>
<blockquote>
<p>切换屏幕：command + option + 方向键 command + [ 或 command + ]</p>
</blockquote>
<blockquote>
<p>查看历史命令：command + ;</p>
</blockquote>
<blockquote>
<p>查看剪贴板历史：command + shift + h</p>
</blockquote>
<h3 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h3><blockquote>
<p>清除当前行：ctrl + u</p>
</blockquote>
<blockquote>
<p>到行首：ctrl + a</p>
</blockquote>
<blockquote>
<p>到行尾：ctrl + e</p>
</blockquote>
<blockquote>
<p>前进后退：ctrl + f/b (相当于左右方向键)</p>
</blockquote>
<blockquote>
<p>上一条命令：ctrl + p</p>
</blockquote>
<blockquote>
<p>搜索命令历史：ctrl + r</p>
<p>删除当前光标的字符：ctrl + d</p>
</blockquote>
<blockquote>
<p>删除光标之前的字符：ctrl + h</p>
</blockquote>
<blockquote>
<p>删除光标之前的单词：ctrl + w</p>
</blockquote>
<blockquote>
<p>删除到文本末尾：ctrl + k</p>
</blockquote>
<blockquote>
<p>交换光标处文本：ctrl + t</p>
</blockquote>
<blockquote>
<p>清屏1：command + r</p>
</blockquote>
<blockquote>
<p>清屏2：ctrl + l</p>
</blockquote>
<blockquote>
<p>自带有哪些很实用的功能/快捷键</p>
</blockquote>
<blockquote>
<p>⌘ + 数字在各 tab 标签直接来回切换</p>
</blockquote>
<blockquote>
<p>选择即复制 + 鼠标中键粘贴，这个很实用</p>
</blockquote>
<blockquote>
<p>⌘ + f 所查找的内容会被自动复制</p>
</blockquote>
<blockquote>
<p>⌘ + d 横着分屏 / ⌘ + shift + d 竖着分屏</p>
</blockquote>
<blockquote>
<p>⌘ + r = clear，而且只是换到新一屏，不会想 clear 一样创建一个空屏</p>
</blockquote>
<blockquote>
<p>ctrl + u 清空当前行，无论光标在什么位置</p>
<p>输入开头命令后 按 ⌘ + ; 会自动列出输入过的命令</p>
</blockquote>
<blockquote>
<p>⌘ + shift + h 会列出剪切板历史</p>
</blockquote>
<blockquote>
<p>可以在 Preferences &gt; keys 设置全局快捷键调出 iterm，这个也可以用过 Alfred 实现</p>
</blockquote>
<h3 id="常用的一些快捷键"><a href="#常用的一些快捷键" class="headerlink" title="常用的一些快捷键"></a>常用的一些快捷键</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">⌘ + <span class="number">1</span> / <span class="number">2</span> 左右 tab 之间来回切换，这个在 前面 已经介绍过了</span><br><span class="line"></span><br><span class="line">⌘← / ⌘→ 到一行命令最左边/最右边 ，这个功能同 C+a / C+e</span><br><span class="line"></span><br><span class="line">⌥← / ⌥→ 按单词前移/后移，相当与 C+f / C+b，其实这个功能在Iterm中已经预定义好了，⌥f / ⌥b，看个人习惯了</span><br><span class="line"></span><br><span class="line">好像就这几个</span><br><span class="line"></span><br><span class="line">设置方法如下</span><br><span class="line"></span><br><span class="line">当然除了这些可以自定义的也不能忘了 linux 下那些好用的组合</span><br><span class="line"></span><br><span class="line">C+a / C+e 这个几乎在哪都可以使用</span><br><span class="line"></span><br><span class="line">C+p / !! 上一条命令</span><br><span class="line"></span><br><span class="line">C+k 从光标处删至命令行尾 (本来 C+u 是删至命令行首，但iterm中是删掉整行)</span><br><span class="line"></span><br><span class="line">C+w A+d 从光标处删至字首/尾</span><br><span class="line"></span><br><span class="line">C+h C+d 删掉光标前后的自负</span><br><span class="line"></span><br><span class="line">C+y 粘贴至光标后</span><br><span class="line"></span><br><span class="line">C+r 搜索命令历史，这个较常用</span><br></pre></td></tr></table></figure>


<h3 id="选中即复制"><a href="#选中即复制" class="headerlink" title="选中即复制"></a>选中即复制</h3><p><strong>iterm2 有 2 种好用的选中即复制模式。</strong></p>
<ul>
<li>一种是用鼠标，在 iterm2 中，选中某个路径或者某个词汇，那么，iterm2 就自动复制了。 　　</li>
<li>另一种是无鼠标模式，command+f,弹出 iterm2 的查找模式，输入要查找并复制的内容的前几个字母，确认找到的是自己的内容之后，输入 tab，查找窗口将自动变化内容，并将其复制。如果输入的是 shift+tab，则自动将查找内容的左边选中并复制。</li>
</ul>
<h3 id="自动完成"><a href="#自动完成" class="headerlink" title="自动完成"></a>自动完成</h3><p>输入打头几个字母，然后输入 command+; iterm2 将自动列出之前输入过的类似命令</p>
<p>###剪切历史<br>输入 <code>command+shift+h</code>，iterm2 将自动列出剪切板的历史记录。如果需要将剪切板的历史记录保存到磁盘，在 <code>Preferences &gt; General &gt; Save copy/paste history to disk</code> 中设置。</p>
<p>原文在<a href="https://cnbin.github.io/blog/2015/06/20/iterm2-kuai-jie-jian-da-quan/" target="_blank" rel="noopener">这里</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>linux vi/vim</title>
    <url>/year/09/08/linux-vi-vim/</url>
    <content><![CDATA[<p>#vi/vim</p>
<h3 id="第一部分：一般模式。"><a href="#第一部分：一般模式。" class="headerlink" title="第一部分：一般模式。"></a>第一部分：一般模式。</h3><p><strong>移动光标的方法</strong></p>
<blockquote>
<ul>
<li>h 或 向左箭头键(←) 光标向左移动一个字符</li>
<li>j 或 向下箭头键(↓) 光标向下移动一个字符</li>
<li>k 或 向上箭头键(↑) 光标向上移动一个字符</li>
<li>l 或 向右箭头键(→) 光标向右移动一个字符</li>
</ul>
</blockquote>
<p>如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！</p>
<a id="more"></a>

<blockquote>
<ul>
<li>[Ctrl] + [f] 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</li>
<li>[Ctrl] + [b] 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</li>
<li>[Ctrl] + [d] 屏幕『向下』移动半页</li>
<li>[Ctrl] + [u] 屏幕『向上』移动半页想</li>
<li><ul>
<li>光标移动到非空格符的下一行</li>
</ul>
</li>
<li><ul>
<li>光标移动到非空格符的上一行</li>
</ul>
</li>
<li>n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20 则光标会向后面移动 20 个字符距离。</li>
<li>0 或功能键[Home] 这是数字『 0 』：移动到这一行的最前面字符处 (常用)</li>
<li>( 或功能键[End] 移动到这一行的最后面字符处(常用)</li>
<li>H 光标移动到这个屏幕的最上方那一行的第一个字符</li>
<li>M 光标移动到这个屏幕的中央那一行的第一个字符</li>
<li>L 光标移动到这个屏幕的最下方那一行的第一个字符</li>
<li>G 移动到这个档案的最后一行(常用)</li>
<li>nG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</li>
<li>gg 移动到这个档案的第一行，相当于 1G 啊！ (常用)</li>
<li>n<Enter> n 为数字。光标向下移动 n 行(常用)</li>
</ul>
</blockquote>
<p><strong>搜索替换</strong></p>
<blockquote>
<ul>
<li>/word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)</li>
<li>?word 向光标之上寻找一个字符串名称为 word 的字符串。</li>
<li>n 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</li>
<li>N 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</li>
<li>使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！</li>
<li>:n1,n2s/word1/word2/g n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则：<br>『:100,200s/vbird/VBIRD/g』。(常用)</li>
<li>:1,)s/word1/word2/g 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</li>
<li>:1,(s/word1/word2/gc 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</li>
</ul>
</blockquote>
<p><strong>删除、复制与粘贴</strong></p>
<blockquote>
<ul>
<li>x, X 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</li>
<li>nx n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</li>
<li>dd 删除游标所在的那一整行(常用)</li>
<li>ndd n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)</li>
<li>d1G 删除光标所在到第一行的所有数据</li>
<li>dG 删除光标所在到最后一行的所有数据</li>
<li>d) 删除游标所在处，到该行的最后一个字符</li>
<li>d0 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</li>
<li>yy 复制游标所在的那一行(常用)</li>
<li>nyy n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</li>
<li>y1G 复制游标所在行到第一行的所有数据</li>
<li>yG 复制游标所在行到最后一行的所有数据</li>
<li>y0 复制光标所在的那个字符到该行行首的所有数据</li>
<li>y$ 复制光标所在的那个字符到该行行尾的所有数据</li>
<li>p, P p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 &gt;行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</li>
<li>J 将光标所在行与下一行的数据结合成同一行</li>
<li>c 重复删除多个数据，例如向下删除 10 行，[ 10cj ]</li>
<li>u 复原前一个动作。(常用)</li>
<li>[Ctrl]+r 重做上一个动作。(常用)</li>
<li>这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</li>
<li>. 不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</li>
</ul>
</blockquote>
<h3 id="第二部份：一般模式切换到编辑模式的可用的按钮说明"><a href="#第二部份：一般模式切换到编辑模式的可用的按钮说明" class="headerlink" title="第二部份：一般模式切换到编辑模式的可用的按钮说明"></a>第二部份：一般模式切换到编辑模式的可用的按钮说明</h3><p><strong>进入插入或取代的编辑模式</strong></p>
<blockquote>
<ul>
<li>i, I 进入插入模式(Insert mode)：</li>
<li>i 为『从目前光标所在处插入』， I 为『在目前所在行的第一个非空格符处开始插入』。 (常用)</li>
<li>a, A 进入插入模式(Insert mode)：</li>
<li>a 为『从目前光标所在的下一个字符处开始插入』， A 为『从光标所在行的最后一个字符处开始插入』。(常用)</li>
<li>o, O 进入插入模式(Insert mode)：<br>这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处插入新的一行』； O 为在目前光标所在处的上一行插入新的一行！(常用)</li>
<li>r, R 进入取代模式(Replace mode)：<br>r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</li>
<li>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！</li>
<li>[Esc] 退出编辑模式，回到一般模式中(常用)</li>
</ul>
</blockquote>
<h3 id="第三部份：一般模式切换到指令行模式的可用的按钮说明"><a href="#第三部份：一般模式切换到指令行模式的可用的按钮说明" class="headerlink" title="第三部份：一般模式切换到指令行模式的可用的按钮说明"></a>第三部份：一般模式切换到指令行模式的可用的按钮说明</h3><p><strong>指令行的储存、离开等指令</strong></p>
<blockquote>
<ul>
<li>:w 将编辑的数据写入硬盘档案中(常用)</li>
<li>:w! 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</li>
<li>:q 离开 vi (常用)</li>
<li>:q! 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</li>
</ul>
</blockquote>
<p>注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</p>
<blockquote>
<ul>
<li>:wq 储存后离开，若为 :wq! 则为强制储存后离开 (常用)</li>
<li>ZZ 这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！</li>
<li>:w [filename] 将编辑的数据储存成另一个档案（类似另存新档）</li>
<li>:r [filename] 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</li>
<li>:n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。</li>
<li>:! command 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如<br>『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！</li>
</ul>
</blockquote>
<p><strong>vim 环境的变更</strong></p>
<blockquote>
<ul>
<li>:set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号</li>
<li>:set nonu 与 set nu 相反，为取消行号！</li>
<li>set cursorline    “选中行高亮</li>
<li>set autoindent    “自动缩进</li>
<li>set shiftwidth=4  “ 缩进位宽=4个空格位</li>
<li>set expandtab     “ tab由空格表示</li>
<li>set tabstop=4     “ tab=4空格</li>
<li>set softtabstop=4 “ 回退可以删除缩进</li>
<li>set laststatus=2 “ 总是显示状态栏</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 基础</title>
    <url>/year/05/29/k8syl/</url>
    <content><![CDATA[<h2 id="Kubernetes-简介"><a href="#Kubernetes-简介" class="headerlink" title="Kubernetes 简介"></a>Kubernetes 简介</h2><p>Kubernetes 是 Google 团队发起并维护的基于 Docker 的开源容器集群管理系统，它不仅支持常见的云平台，而且支持内部数据中心。</p>
<p>建于 Docker 之上的 Kubernetes 可以构建一个容器的调度服务，其目的是让用户透过 Kubernetes 集群来进行云端容器集群的管理，而无需用户进行复杂的设置工作。系统会自动选取合适的工作节点来执行具体的容器集群调度处理工作。其核心概念是 Container Pod。一个 Pod 由一组工作于同一物理工作节点的容器构成。这些组容器拥有相同的网络命名空间、IP以及存储配额，也可以根据实际情况对每一个 Pod 进行端口映射。此外，Kubernetes 工作节点会由主系统进行管理，节点包含了能够运行 Docker 容器所用到的服务。</p>
<a id="more"></a>


<h2 id="Kubermetes-架构"><a href="#Kubermetes-架构" class="headerlink" title="Kubermetes 架构"></a>Kubermetes 架构</h2><p>Kubernetes最初源于谷歌内部的Borg，提供了面向应用的容器集群部署和管理系统。Kubernetes的目标旨在消除编排物理/虚拟计算，网络和存储基础设施的负担，并使应用程序运营商和开发人员完全将重点放在以容器为中心的原语上进行自助运营。Kubernetes 也提供稳定、兼容的基础（平台），用于构建定制化的workflows 和更高级的自动化任务。 Kubernetes 具备完善的集群管理能力，包括多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和服务发现机制、内建负载均衡器、故障发现和自我修复能力、服务滚动升级和在线扩容、可扩展的资源自动调度机制、多粒度的资源配额管理能力。 Kubernetes 还提供完善的管理工具，涵盖开发、部署测试、运维监控等各个环节。</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g3gv96pnybj310f0u0qcf.jpg" alt=""></p>
<p>Kubermetes 主要有一下几个核心组件组成：</p>
<ul>
<li>etcd保存了整个集群的状态；</li>
<li>piserver提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；</li>
<li>controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</li>
<li>scheduler负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；</li>
<li>kubelet负责维护容器的生命周期，同时也负责Volume（CSI）和网络（CNI）的管理；</li>
<li>Container runtime负责镜像管理以及Pod和容器的真正运行（CRI）；</li>
<li>kube-proxy负责为Service提供cluster内部的服务发现和负载均衡；</li>
</ul>
<p>除了核心组件，还有一些推荐的插件，其中有的已经成为CNCF中的托管项目：</p>
<ul>
<li>CoreDNS负责为整个集群提供DNS服务</li>
<li>Ingress Controller为服务提供外网入口</li>
<li>Prometheus提供资源监控</li>
<li>Dashboard提供GUI</li>
<li>Federation提供跨可用区的集群</li>
</ul>
<h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p>下图清晰表明了Kubernetes的架构设计以及组件之间的通信协议。</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g3gvctfgehj31di0u0wmz.jpg" alt=""></p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g3gvdrm3w9j318g0tn420.jpg" alt=""></p>
<h3 id="Master-架构"><a href="#Master-架构" class="headerlink" title="Master 架构"></a>Master 架构</h3><p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g3gveda7osj318g0tntc0.jpg" alt=""></p>
<h3 id="Node架构"><a href="#Node架构" class="headerlink" title="Node架构"></a>Node架构</h3><p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g3gver83usj318g0tnq7e.jpg" alt=""></p>
<h3 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h3><p>Kubernetes设计理念和功能其实就是一个类似Linux的分层架构，如下图所示。<br><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g3gver83usj318g0tnq7e.jpg" alt=""></p>
<ul>
<li>核心层：Kubernetes最核心的功能，对外提供API构建高层的应用，对内提供插件式应用执行环境</li>
<li>应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS解析等）、Service Mesh（部分位于应用层）</li>
<li>管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态Provision等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy等）、Service Mesh（部分位于管理层）</li>
<li>接口层：kubectl命令行工具、客户端SDK以及集群联邦</li>
<li>生态系统：在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴<ul>
<li>Kubernetes外部：日志、监控、配置管理、CI/CD、Workflow、FaaS、OTS应用、ChatOps、GitOps、SecOps等</li>
<li>Kubernetes内部：CRI、CNI、CSI、镜像仓库、Cloud Provider、集群自身的配置和管理等</li>
</ul>
</li>
</ul>
<h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><h3 id="API设计原则"><a href="#API设计原则" class="headerlink" title="API设计原则"></a>API设计原则</h3><p>对于云计算系统，系统API实际上处于系统设计的统领地位，正如本文前面所说，Kubernetes集群系统每支持一项新功能，引入一项新技术，一定会新引入对应的API对象，支持对该功能的管理操作，理解掌握的API，就好比抓住了Kubernetes系统的牛鼻子。Kubernetes系统API的设计有以下几条原则：</p>
<ol>
<li><strong>所有API应该是声明式的。</strong>正如前文所说，声明式的操作，相对于命令式操作，对于重复操作的效果是稳定的，这对于容易出现数据丢失或重复的分布式环境来说是很重要的。另外，声明式操作更容易被用户使用，可以使系统向用户隐藏实现的细节，隐藏实现的细节的同时，也就保留了系统未来持续优化的可能性。此外，声明式的API，同时隐含了所有的API对象都是名词性质的，例如Service、Volume这些API都是名词，这些名词描述了用户所期望得到的一个目标分布式对象。</li>
<li><strong>API对象是彼此互补而且可组合的。</strong>这里面实际是鼓励API对象尽量实现面向对象设计时的要求，即“高内聚，松耦合”，对业务相关的概念有一个合适的分解，提高分解出来的对象的可重用性。事实上，Kubernetes这种分布式系统管理平台，也是一种业务系统，只不过它的业务就是调度和管理容器服务。</li>
<li><strong>高层API以操作意图为基础设计。</strong>如何能够设计好API，跟如何能用面向对象的方法设计好应用系统有相通的地方，高层设计一定是从业务出发，而不是过早的从技术实现出发。因此，针对Kubernetes的高层API设计，一定是以Kubernetes的业务为基础出发，也就是以系统调度管理容器的操作意图为基础设计。</li>
<li><strong>低层API根据高层API的控制需要设计。</strong>设计实现低层API的目的，是为了被高层API使用，考虑减少冗余、提高重用性的目的，低层API的设计也要以需求为基础，要尽量抵抗受技术实现影响的诱惑。</li>
<li><strong>尽量避免简单封装，不要有在外部API无法显式知道的内部隐藏的机制。</strong>简单的封装，实际没有提供新的功能，反而增加了对所封装API的依赖性。内部隐藏的机制也是非常不利于系统维护的设计方式，例如StatefulSet和ReplicaSet，本来就是两种Pod集合，那么Kubernetes就用不同API对象来定义它们，而不会说只用同一个ReplicaSet，内部通过特殊的算法再来区分这个ReplicaSet是有状态的还是无状态。</li>
<li><strong>API操作复杂度与对象数量成正比。</strong>这一条主要是从系统性能角度考虑，要保证整个系统随着系统规模的扩大，性能不会迅速变慢到无法使用，那么最低的限定就是API的操作复杂度不能超过O(N)，N是对象的数量，否则系统就不具备水平伸缩性了。</li>
<li><strong>API对象状态不能依赖于网络连接状态。</strong>由于众所周知，在分布式环境下，网络连接断开是经常发生的事情，因此要保证API对象状态能应对网络的不稳定，API对象的状态就不能依赖于网络连接状态。</li>
<li><strong>尽量避免让操作机制依赖于全局状态，因为在分布式系统中要保证全局状态的同步是非常困难的。</strong></li>
</ol>
<h3 id="控制机制设计原则"><a href="#控制机制设计原则" class="headerlink" title="控制机制设计原则"></a>控制机制设计原则</h3><ul>
<li><strong>控制逻辑应该只依赖于当前状态。</strong>这是为了保证分布式系统的稳定可靠，对于经常出现局部错误的分布式系统，如果控制逻辑只依赖当前状态，那么就非常容易将一个暂时出现故障的系统恢复到正常状态，因为你只要将该系统重置到某个稳定状态，就可以自信的知道系统的所有控制逻辑会开始按照正常方式运行。</li>
<li><strong>假设任何错误的可能，并做容错处理。</strong>在一个分布式系统中出现局部和临时错误是大概率事件。错误可能来自于物理系统故障，外部系统故障也可能来自于系统自身的代码错误，依靠自己实现的代码不会出错来保证系统稳定其实也是难以实现的，因此要设计对任何可能错误的容错处理。</li>
<li><strong>尽量避免复杂状态机，控制逻辑不要依赖无法监控的内部状态。</strong>因为分布式系统各个子系统都是不能严格通过程序内部保持同步的，所以如果两个子系统的控制逻辑如果互相有影响，那么子系统就一定要能互相访问到影响控制逻辑的状态，否则，就等同于系统里存在不确定的控制逻辑。</li>
<li><strong>假设任何操作都可能被任何操作对象拒绝，甚至被错误解析。</strong>由于分布式系统的复杂性以及各子系统的相对独立性，不同子系统经常来自不同的开发团队，所以不能奢望任何操作被另一个子系统以正确的方式处理，要保证出现错误的时候，操作级别的错误不会影响到系统稳定性。</li>
<li><strong>每个模块都可以在出错后自动恢复。</strong>由于分布式系统中无法保证系统各个模块是始终连接的，因此每个模块要有自我修复的能力，保证不会因为连接不到其他模块而自我崩溃。</li>
<li><strong>每个模块都可以在必要时优雅地降级服务。</strong>所谓优雅地降级服务，是对系统鲁棒性的要求，即要求在设计实现模块时划分清楚基本功能和高级功能，保证基本功能不会依赖高级功能，这样同时就保证了不会因为高级功能出现故障而导致整个模块崩溃。根据这种理念实现的系统，也更容易快速地增加新的高级功能，因为不必担心引入高级功能影响原有的基本功能。</li>
</ul>
<h3 id="Kubernetes的核心技术概念和API对象"><a href="#Kubernetes的核心技术概念和API对象" class="headerlink" title="Kubernetes的核心技术概念和API对象"></a>Kubernetes的核心技术概念和API对象</h3><p>API对象是Kubernetes集群中的管理操作单元。Kubernetes集群系统每支持一项新功能，引入一项新技术，一定会新引入对应的API对象，支持对该功能的管理操作。例如副本集Replica Set对应的API对象是RS。</p>
<p>每个API对象都有3大类属性：元数据metadata、规范spec和状态status。元数据是用来标识API对象的，每个对象都至少有3个元数据：namespace，name和uid；除此以外还有各种各样的标签labels用来标识和匹配不同的对象，例如用户可以用标签env来标识区分不同的服务部署环境，分别用env=dev、env=testing、env=production来标识开发、测试、生产的不同服务。规范描述了用户期望Kubernetes集群中的分布式系统达到的理想状态（Desired State），例如用户可以通过复制控制器Replication Controller设置期望的Pod副本数为3；status描述了系统实际当前达到的状态（Status），例如系统当前实际的Pod副本数为2；那么复制控制器当前的程序逻辑就是自动启动新的Pod，争取达到副本数为3。</p>
<p>Kubernetes中所有的配置都是通过API对象的spec去设置的，也就是用户通过配置系统的理想状态来改变系统，这是Kubernetes重要设计理念之一，即所有的操作都是声明式（Declarative）的而不是命令式（Imperative）的。声明式操作在分布式系统中的好处是稳定，不怕丢操作或运行多次，例如设置副本数为3的操作运行多次也还是一个结果，而给副本数加1的操作就不是声明式的，运行多次结果就错了。</p>
<h4 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h4><p>Kubernetes有很多技术概念，同时对应很多API对象，最重要的也是最基础的是Pod。Pod是在Kubernetes集群中运行部署应用或服务的最小单元，它是可以支持多容器的。Pod的设计理念是支持多个容器在一个Pod中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。Pod对多容器的支持是K8最基础的设计理念。比如你运行一个操作系统发行版的软件仓库，一个Nginx容器用来发布软件，另一个容器专门用来从源仓库做同步，这两个容器的镜像不太可能是一个团队开发的，但是他们一块儿工作才能提供一个微服务；这种情况下，不同的团队各自开发构建自己的容器镜像，在部署的时候组合成一个微服务对外提供服务。</p>
<p>Pod是Kubernetes集群中所有业务类型的基础，可以看作运行在Kubernetes集群中的小机器人，不同类型的业务就需要不同类型的小机器人去执行。目前Kubernetes中的业务主要可以分为长期伺服型（long-running）、批处理型（batch）、节点后台支撑型（node-daemon）和有状态应用型（stateful application）；分别对应的小机器人控制器为Deployment、Job、DaemonSet和StatefulSet，本文后面会一一介绍。</p>
<h4 id="副本控制器（Replication-Controller，RC）"><a href="#副本控制器（Replication-Controller，RC）" class="headerlink" title="副本控制器（Replication Controller，RC）"></a>副本控制器（Replication Controller，RC）</h4><p>RC是Kubernetes集群中最早的保证Pod高可用的API对象。通过监控运行中的Pod来保证集群中运行指定数目的Pod副本。指定的数目可以是多个也可以是1个；少于指定数目，RC就会启动运行新的Pod副本；多于指定数目，RC就会杀死多余的Pod副本。即使在指定数目为1的情况下，通过RC运行Pod也比直接运行Pod更明智，因为RC也可以发挥它高可用的能力，保证永远有1个Pod在运行。RC是Kubernetes较早期的技术概念，只适用于长期伺服型的业务类型，比如控制小机器人提供高可用的Web服务。</p>
<h4 id="部署（Deployment）"><a href="#部署（Deployment）" class="headerlink" title="部署（Deployment）"></a>部署（Deployment）</h4><p>部署表示用户对Kubernetes集群的一次更新操作。部署是一个比RS应用模式更广的API对象，可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。滚动升级一个服务，实际是创建一个新的RS，然后逐渐将新RS中副本数增加到理想状态，将旧RS中的副本数减小到0的复合操作；这样一个复合操作用一个RS是不太好描述的，所以用一个更通用的Deployment来描述。以Kubernetes的发展方向，未来对所有长期伺服型的的业务的管理，都会通过Deployment来管理。</p>
<h4 id="服务（Service）"><a href="#服务（Service）" class="headerlink" title="服务（Service）"></a>服务（Service）</h4><p>RC、RS和Deployment只是保证了支撑服务的微服务Pod的数量，但是没有解决如何访问这些服务的问题。一个Pod只是一个运行服务的实例，随时可能在一个节点上停止，在另一个节点以一个新的IP启动一个新的Pod，因此不能以确定的IP和端口号提供服务。要稳定地提供服务需要服务发现和负载均衡能力。服务发现完成的工作，是针对客户端访问的服务，找到对应的的后端服务实例。在K8集群中，客户端需要访问的服务就是Service对象。每个Service会对应一个集群内部有效的虚拟IP，集群内部通过虚拟IP访问一个服务。在Kubernetes集群中微服务的负载均衡是由Kube-proxy实现的。Kube-proxy是Kubernetes集群内部的负载均衡器。它是一个分布式代理服务器，在Kubernetes的每个节点上都有一个；这一设计体现了它的伸缩性优势，需要访问服务的节点越多，提供负载均衡能力的Kube-proxy就越多，高可用节点也随之增多。与之相比，我们平时在服务器端做个反向代理做负载均衡，还要进一步解决反向代理的负载均衡和高可用问题。</p>
<h4 id="任务（Job）"><a href="#任务（Job）" class="headerlink" title="任务（Job）"></a>任务（Job）</h4><p>Job是Kubernetes用来控制批处理型任务的API对象。批处理业务与长期伺服业务的主要区别是批处理业务的运行有头有尾，而长期伺服业务在用户不停止的情况下永远运行。Job管理的Pod根据用户的设置把任务成功完成就自动退出了。成功完成的标志根据不同的spec.completions策略而不同：单Pod型任务有一个Pod成功就标志完成；定数成功型任务保证有N个任务全部成功；工作队列型任务根据应用确认的全局成功而标志成功。</p>
<h4 id="后台支撑服务集（DaemonSet）"><a href="#后台支撑服务集（DaemonSet）" class="headerlink" title="后台支撑服务集（DaemonSet）"></a>后台支撑服务集（DaemonSet）</h4><p>长期伺服型和批处理型服务的核心在业务应用，可能有些节点运行多个同类业务的Pod，有些节点上又没有这类Pod运行；而后台支撑型服务的核心关注点在Kubernetes集群中的节点（物理机或虚拟机），要保证每个节点上都有一个此类Pod运行。节点可能是所有集群节点也可能是通过nodeSelector选定的一些特定节点。典型的后台支撑型服务包括，存储，日志和监控等在每个节点上支持Kubernetes集群运行的服务。</p>
<h4 id="有状态服务集（StatefulSet）"><a href="#有状态服务集（StatefulSet）" class="headerlink" title="有状态服务集（StatefulSet）"></a>有状态服务集（StatefulSet）</h4><p>Kubernetes在1.3版本里发布了Alpha版的PetSet功能，在1.5版本里将PetSet功能升级到了Beta版本，并重新命名为StatefulSet，最终在1.9版本里成为正式GA版本。在云原生应用的体系里，有下面两组近义词；第一组是无状态（stateless）、牲畜（cattle）、无名（nameless）、可丢弃（disposable）；第二组是有状态（stateful）、宠物（pet）、有名（having name）、不可丢弃（non-disposable）。RC和RS主要是控制提供无状态服务的，其所控制的Pod的名字是随机设置的，一个Pod出故障了就被丢弃掉，在另一个地方重启一个新的Pod，名字变了。名字和启动在哪儿都不重要，重要的只是Pod总数；而StatefulSet是用来控制有状态服务，StatefulSet中的每个Pod的名字都是事先确定的，不能更改。StatefulSet中Pod的名字的作用，并不是《千与千寻》的人性原因，而是关联与该Pod对应的状态。</p>
<p>对于RC和RS中的Pod，一般不挂载存储或者挂载共享存储，保存的是所有Pod共享的状态，Pod像牲畜一样没有分别（这似乎也确实意味着失去了人性特征）；对于StatefulSet中的Pod，每个Pod挂载自己独立的存储，如果一个Pod出现故障，从其他节点启动一个同样名字的Pod，要挂载上原来Pod的存储继续以它的状态提供服务。</p>
<p>适合于StatefulSet的业务包括数据库服务MySQL和PostgreSQL，集群化管理服务ZooKeeper、etcd等有状态服务。StatefulSet的另一种典型应用场景是作为一种比普通容器更稳定可靠的模拟虚拟机的机制。传统的虚拟机正是一种有状态的宠物，运维人员需要不断地维护它，容器刚开始流行时，我们用容器来模拟虚拟机使用，所有状态都保存在容器里，而这已被证明是非常不安全、不可靠的。使用StatefulSet，Pod仍然可以通过漂移到不同节点提供高可用，而存储也可以通过外挂的存储来提供高可靠性，StatefulSet做的只是将确定的Pod与确定的存储关联起来保证状态的连续性。</p>
<h4 id="集群联邦（Federation）"><a href="#集群联邦（Federation）" class="headerlink" title="集群联邦（Federation）"></a>集群联邦（Federation）</h4><p>Kubernetes在1.3版本里发布了beta版的Federation功能。在云计算环境中，服务的作用距离范围从近到远一般可以有：同主机（Host，Node）、跨主机同可用区（Available Zone）、跨可用区同地区（Region）、跨地区同服务商（Cloud Service Provider）、跨云平台。Kubernetes的设计定位是单一集群在同一个地域内，因为同一个地区的网络性能才能满足Kubernetes的调度和计算存储连接要求。而联合集群服务就是为提供跨Region跨服务商Kubernetes集群服务而设计的。</p>
<p>每个Kubernetes Federation有自己的分布式存储、API Server和Controller Manager。用户可以通过Federation的API Server注册该Federation的成员Kubernetes Cluster。当用户通过Federation的API Server创建、更改API对象时，Federation API Server会在自己所有注册的子Kubernetes Cluster都创建一份对应的API对象。在提供业务请求服务时，Kubernetes Federation会先在自己的各个子Cluster之间做负载均衡，而对于发送到某个具体Kubernetes Cluster的业务请求，会依照这个Kubernetes Cluster独立提供服务时一样的调度模式去做Kubernetes Cluster内部的负载均衡。而Cluster之间的负载均衡是通过域名服务的负载均衡来实现的。</p>
<p>Federation V1的设计是尽量不影响Kubernetes Cluster现有的工作机制，这样对于每个子Kubernetes集群来说，并不需要更外层的有一个Kubernetes Federation，也就是意味着所有现有的Kubernetes代码和机制不需要因为Federation功能有任何变化。</p>
<p>目前正在开发的Federation V2，在保留现有Kubernetes API的同时，会开发新的Federation专用的API接口，详细内容可以在这里找到。</p>
<h4 id="存储卷（Volume）"><a href="#存储卷（Volume）" class="headerlink" title="存储卷（Volume）"></a>存储卷（Volume）</h4><p>Kubernetes集群中的存储卷跟Docker的存储卷有些类似，只不过Docker的存储卷作用范围为一个容器，而Kubernetes的存储卷的生命周期和作用范围是一个Pod。每个Pod中声明的存储卷由Pod中的所有容器共享。Kubernetes支持非常多的存储卷类型，特别的，支持多种公有云平台的存储，包括AWS，Google和Azure云；支持多种分布式存储包括GlusterFS和Ceph；也支持较容易使用的主机本地目录emptyDir, hostPath和NFS。Kubernetes还支持使用Persistent Volume Claim即PVC这种逻辑存储，使用这种存储，使得存储的使用者可以忽略后台的实际存储技术（例如AWS，Google或GlusterFS和Ceph），而将有关存储实际技术的配置交给存储管理员通过Persistent Volume来配置。</p>
<h4 id="持久存储卷（Persistent-Volume，PV）和持久存储卷声明（Persistent-Volume-Claim，PVC）"><a href="#持久存储卷（Persistent-Volume，PV）和持久存储卷声明（Persistent-Volume-Claim，PVC）" class="headerlink" title="持久存储卷（Persistent Volume，PV）和持久存储卷声明（Persistent Volume Claim，PVC）"></a>持久存储卷（Persistent Volume，PV）和持久存储卷声明（Persistent Volume Claim，PVC）</h4><p>PV和PVC使得Kubernetes集群具备了存储的逻辑抽象能力，使得在配置Pod的逻辑里可以忽略对实际后台存储技术的配置，而把这项配置的工作交给PV的配置者，即集群的管理者。存储的PV和PVC的这种关系，跟计算的Node和Pod的关系是非常类似的；PV和Node是资源的提供者，根据集群的基础设施变化而变化，由Kubernetes集群管理员配置；而PVC和Pod是资源的使用者，根据业务服务的需求变化而变化，有Kubernetes集群的使用者即服务的管理员来配置。</p>
<h4 id="节点（Node）"><a href="#节点（Node）" class="headerlink" title="节点（Node）"></a>节点（Node）</h4><p>Kubernetes集群中的计算能力由Node提供，最初Node称为服务节点Minion，后来改名为Node。Kubernetes集群中的Node也就等同于Mesos集群中的Slave节点，是所有Pod运行所在的工作主机，可以是物理机也可以是虚拟机。不论是物理机还是虚拟机，工作主机的统一特征是上面要运行kubelet管理节点上运行的容器。</p>
<h4 id="密钥对象（Secret）"><a href="#密钥对象（Secret）" class="headerlink" title="密钥对象（Secret）"></a>密钥对象（Secret）</h4><p>Secret是用来保存和传递密码、密钥、认证凭证这些敏感信息的对象。使用Secret的好处是可以避免把敏感信息明文写在配置文件里。在Kubernetes集群中配置和使用服务不可避免的要用到各种敏感信息实现登录、认证等功能，例如访问AWS存储的用户名密码。为了避免将类似的敏感信息明文写在所有需要使用的配置文件中，可以将这些信息存入一个Secret对象，而在配置文件中通过Secret对象引用这些敏感信息。这种方式的好处包括：意图明确，避免重复，减少暴漏机会。</p>
<h4 id="用户帐户（User-Account）和服务帐户（Service-Account）"><a href="#用户帐户（User-Account）和服务帐户（Service-Account）" class="headerlink" title="用户帐户（User Account）和服务帐户（Service Account）"></a>用户帐户（User Account）和服务帐户（Service Account）</h4><p>顾名思义，用户帐户为人提供账户标识，而服务账户为计算机进程和Kubernetes集群中运行的Pod提供账户标识。用户帐户和服务帐户的一个区别是作用范围；用户帐户对应的是人的身份，人的身份与服务的namespace无关，所以用户账户是跨namespace的；而服务帐户对应的是一个运行中程序的身份，与特定namespace是相关的。</p>
<h4 id="命名空间（Namespace）"><a href="#命名空间（Namespace）" class="headerlink" title="命名空间（Namespace）"></a>命名空间（Namespace）</h4><p>命名空间为Kubernetes集群提供虚拟的隔离作用，Kubernetes集群初始有两个命名空间，分别是默认命名空间default和系统命名空间kube-system，除此以外，管理员可以可以创建新的命名空间满足需要。</p>
<h4 id="RBAC访问授权"><a href="#RBAC访问授权" class="headerlink" title="RBAC访问授权"></a>RBAC访问授权</h4><p>Kubernetes在1.3版本中发布了alpha版的基于角色的访问控制（Role-based Access Control，RBAC）的授权模式。相对于基于属性的访问控制（Attribute-based Access Control，ABAC），RBAC主要是引入了角色（Role）和角色绑定（RoleBinding）的抽象概念。在ABAC中，Kubernetes集群中的访问策略只能跟用户直接关联；而在RBAC中，访问策略可以跟某个角色关联，具体的用户在跟一个或多个角色相关联。显然，RBAC像其他新功能一样，每次引入新功能，都会引入新的API对象，从而引入新的概念抽象，而这一新的概念抽象一定会使集群服务管理和使用更容易扩展和重用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从Kubernetes的系统架构、技术概念和设计理念，我们可以看到Kubernetes系统最核心的两个设计理念：一个是容错性，一个是易扩展性。容错性实际是保证Kubernetes系统稳定性和安全性的基础，易扩展性是保证Kubernetes对变更友好，可以快速迭代增加新功能的基础。</p>
<p>按照分布式系统一致性算法Paxos发明人计算机科学家Leslie Lamport的理念，一个分布式系统有两类特性：安全性Safety和活性Liveness。安全性保证系统的稳定，保证系统不会崩溃，不会出现业务错误，不会做坏事，是严格约束的；活性使得系统可以提供功能，提高性能，增加易用性，让系统可以在用户“看到的时间内”做些好事，是尽力而为的。Kubernetes系统的设计理念正好与Lamport安全性与活性的理念不谋而合，也正是因为Kubernetes在引入功能和技术的时候，非常好地划分了安全性和活性，才可以让Kubernetes能有这么快版本迭代，快速引入像RBAC、Federation和PetSet这种新功能。</p>
<p>原文地址：<a href="https://www.infoq.cn/" target="_blank" rel="noopener">《Kubernetes与云原生应用》系列之Kubernetes的系统架构与设计理念</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 10.13 安装中文版 man 命令</title>
    <url>/year/10/04/man/</url>
    <content><![CDATA[<h3 id="为什么需要-man-以及-man-怎么使用"><a href="#为什么需要-man-以及-man-怎么使用" class="headerlink" title="为什么需要 man 以及 man 怎么使用"></a>为什么需要 man 以及 man 怎么使用</h3><p><code>linux</code> 或者 <code>mac</code> 系统的命令行工具非常多，可是我们不能记住所有的这些命令，通常只能记住一些我们常用的。遇到不常用的我们需要来查询一下这个命令是怎么使用的。这时候我们就需要使用到 man 命令了。</p>
<p>使用方法也非常简单，例如我们不清楚 ls 这个命令的使用方法，我们就可以在命令行中输入</p>
 <a id="more"></a>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">man ls</span><br></pre></td></tr></table></figure>



<p>来查看这个命令的详情。</p>
<p>但是默认情况下，输出的内容是英文的。可能很多英文不好的朋友希望有中文版本的 <code>man</code> ，这篇博文就是告诉大家，如何在 mac 上安装中文版本的的 man。</p>
<p>至于 <code>linux</code> 系统则非常简单，查看 <a href="https://github.com/man-pages-zh/manpages-zh" target="_blank" rel="noopener">https://github.com/man-pages-zh/manpages-zh</a> 中对应的版本，即可用简单的命令安装。</p>
<h3 id="下载-manpages-zh-编辑安装"><a href="#下载-manpages-zh-编辑安装" class="headerlink" title="下载 manpages-zh 编辑安装"></a>下载 manpages-zh 编辑安装</h3><p>首先，我们打开上面的 github 地址，点击 releases 下载最新版本的 tar.gz 源码包。目前我下载到的是 1.6.3.2 版本的。</p>
<p>因为需要编译安装，所以你电脑上需要有编译工具，运行下面两个命令安装</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">brew install automake</span><br><span class="line">brew install opencc</span><br></pre></td></tr></table></figure>

<p>我这边是需要安装这两个编译工具，如果你下面编译出错，会提示你需要安装说明编辑工具的。利用 <code>brew</code> 安装即可。</p>
<p>如果你电脑没有安装 brew 工具，请参考 <a href="http://blog.csdn.net/FungLeo/article/details/57567538" target="_blank" rel="noopener">http://blog.csdn.net/FungLeo/article/details/57567538</a> 这篇博文安装</p>
<p>好，准备工作做好，我们接着来。    </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 进入下载目录</span><br><span class="line">cd ~<span class="regexp">/Downloads/</span></span><br><span class="line"># 下载最新版本的源码包</span><br><span class="line">wget https:<span class="comment">//github.com/man-pages-zh/manpages-zh/archive/v1.6.3.2.tar.gz</span></span><br><span class="line"># 解压源码包(atool命令，推荐安装这个工具，统一所有压缩文档的命令）</span><br><span class="line">atool -x v1<span class="number">.6</span><span class="number">.3</span><span class="number">.2</span>.tar.gz</span><br><span class="line"># 或者使用这个命令解压</span><br><span class="line">tar zxvf v1<span class="number">.6</span><span class="number">.3</span><span class="number">.2</span>.tar.gz</span><br><span class="line"># 进入源码包文件夹</span><br><span class="line">cd manpages-zh<span class="number">-1.6</span><span class="number">.3</span><span class="number">.2</span>/</span><br><span class="line"># 编译安装 1</span><br><span class="line">autoreconf --install --force</span><br><span class="line"># 编译安装 2</span><br><span class="line">./configure</span><br><span class="line"># 编译安装 3</span><br><span class="line">make</span><br><span class="line"># 编译安装 4</span><br><span class="line">sudo make install</span><br><span class="line"># 配置别名</span><br><span class="line">echo <span class="string">"alias cman='man -M /usr/local/share/man/zh_CN'"</span> &gt;&gt; ~<span class="regexp">/.bash_profile</span></span><br><span class="line"><span class="regexp"># 使别名生效</span></span><br><span class="line"><span class="regexp">. ~/</span>.bash_profile</span><br></pre></td></tr></table></figure>

<p>这样，我们就安装上了中文版本的 man 工具了。我们可以使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cman ls</span><br></pre></td></tr></table></figure>
<p>来查看中文版本的解释了。但是由于 mac 上的 groff 工具比较老，所以中文会出现乱码。我们来解决一下这个问题。</p>
<h3 id="安装-groff-新版本解决中文乱码的问题"><a href="#安装-groff-新版本解决中文乱码的问题" class="headerlink" title="安装 groff 新版本解决中文乱码的问题"></a>安装 groff 新版本解决中文乱码的问题</h3><p>首先，我们到 <a href="http://git.savannah.gnu.org/cgit/groff.git" target="_blank" rel="noopener">http://git.savannah.gnu.org/cgit/groff.git</a> 这个页面下载 1.22 版本的 groff 安装包。我这边用命令行下载，你如果直接复制我的命令，不能下载，请到上面的地址去看看下载地址是否发生变化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 进入下载目录</span><br><span class="line">cd ~<span class="regexp">/Downloads/</span></span><br><span class="line"># 下载1.22版本的源码包</span><br><span class="line">wget http:<span class="comment">//git.savannah.gnu.org/cgit/groff.git/snapshot/groff-1.22.tar.gz</span></span><br><span class="line"># 解压</span><br><span class="line">atool -x groff<span class="number">-1.22</span>.tar.gz</span><br><span class="line"># 进入目录</span><br><span class="line">cd groff<span class="number">-1.22</span></span><br><span class="line"># 编译安装</span><br><span class="line">./configure</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br><span class="line"># 添加配置</span><br><span class="line">sudo vim /etc/man.conf</span><br></pre></td></tr></table></figure>

<p>进入编辑之后，在文件末尾添加</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">NROFF preconv -e UTF8 | <span class="regexp">/usr/</span>local/bin/nroff -Tutf8 -mandoc -c</span><br></pre></td></tr></table></figure>

<p>最后 <code>:wq</code>保存退出</p>
<p>然后，我们在输入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cman ls</span><br></pre></td></tr></table></figure>













]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>我的 macOS 使用习惯</title>
    <url>/year/06/02/mymac/</url>
    <content><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g3mh8ghljej31c00u0u12.jpg" alt=""></p>
<a id="more"></a>

<h2 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h2><ul>
<li><p><strong>dock 栏设置为自动自动显示和隐藏</strong>。这样不仅可以省出一部分的显示区域来，还能提高专注度，让注意力更好的集中在使用的 app 中。</p>
</li>
<li><p><strong>触发角</strong>，触发角是 macOS 非常好用的一个功能，不用实在太浪费了，我根据自己的习惯设置了三个，个人感觉触发角要比触控板来的更方便些，尤其是在使用鼠标的时候。</p>
<ul>
<li>左下角：启动台</li>
<li>右上角：调度中心</li>
<li>右下角：启动屏幕保护程序（锁屏）</li>
</ul>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g3mhlzr8g8j311i0dy41q.jpg" alt=""></p>
<h2 id="系统增强工具"><a href="#系统增强工具" class="headerlink" title="系统增强工具"></a>系统增强工具</h2><ul>
<li><p><a href="https://www.macbartender.com/" target="_blank" rel="noopener">Bartender 3</a></p>
<p> 隐藏顶部菜单图标。</p>
</li>
<li><p><a href="https://magnet.crowdcafe.com/" target="_blank" rel="noopener">Magnet</a></p>
<p>  可以自定义快捷键来定义窗口大小，非常实用的一个小工具。</p>
</li>
</ul>
<ul>
<li><p><a href="https://toolinbox.net/iPic/" target="_blank" rel="noopener">iPic</a></p>
<p>  很好用的一个图床工具。</p>
</li>
<li><p><a href="https://www.crystalidea.com/macs-fan-control" target="_blank" rel="noopener">Macs Fan Control</a></p>
<p>  可以自定义风扇转速，或者设定一个温度范围。</p>
</li>
<li><p><a href="https://cheatsheet-mac.en.softonic.com/mac" target="_blank" rel="noopener">CheatSheet</a></p>
<p>  在任何 app 内长按 command 键可以显示该 app 所支持的快捷键。</p>
</li>
<li><p><a href="https://zh.xnipapp.com/" target="_blank" rel="noopener">Xnip</a></p>
<p>  好用的截图工具</p>
</li>
<li><p><a href="https://www.alfredapp.com/" target="_blank" rel="noopener">Alfred</a></p>
<p>  替代 macOS 原生快速启动程序，非常强大。</p>
</li>
<li><p><a href="https://www.smoothscroll.net/mac/" target="_blank" rel="noopener">SmoothScroll</a></p>
<p>  让鼠标和在 pc 下一样顺滑。</p>
</li>
<li><p><a href="http://plentycom.jp/en/steermouse/" target="_blank" rel="noopener">SteerMouse</a></p>
<p>  万能鼠标驱动，让你的鼠标健位在 macOS 下全部用起来。</p>
</li>
</ul>
<ul>
<li><p><a href="https://cleanmymac.macpaw.com/21?campaign=cmmx_search_text_brand_zh&ci=244618326&adgroupid=15603389286&adpos=1t1&ck=cleanmymac&targetid=aud-116944497126:kwd-12573386450&match={if:e}&gnetwork=g&creative=156258595642&placement=&placecat=&accname=cmm&gclid=CjwKCAjw583nBRBwEiwA7MKvoEPFfN3Kj3Y0Ydzj-Mv7oGvz8DKVMUya7fTK1FL35jzVHM6xrzk9aRoCUMIQAvD_BwE" target="_blank" rel="noopener">CleanMyMac X</a></p>
<p>  很好的清理工具。</p>
</li>
</ul>
<h2 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h2><ul>
<li><a href="https://www.iterm2.com/" target="_blank" rel="noopener">iterm 2</a> </li>
<li><a href="https://ohmyz.sh/" target="_blank" rel="noopener">Oh My ZSH</a></li>
<li>tmux</li>
</ul>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ul>
<li><a href="https://zh.mweb.im/" target="_blank" rel="noopener">MWEB</a></li>
<li><a href="https://ia.net/zh-hans/writer" target="_blank" rel="noopener">iA Writer</a></li>
<li><a href="https://typora.io/" target="_blank" rel="noopener">Typora</a></li>
<li><a href="https://www.xmind.cn/zen/" target="_blank" rel="noopener">Xmind Zen</a></li>
<li><a href="https://mubu.com/" target="_blank" rel="noopener">幕布</a></li>
<li><a href="https://www.yinxiang.com/" target="_blank" rel="noopener">印象笔记</a></li>
</ul>
<h2 id="开发类工具"><a href="#开发类工具" class="headerlink" title="开发类工具"></a>开发类工具</h2><ul>
<li><a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">IntelliJ_IDEA</a></li>
<li><a href="https://www.jetbrains.com/zh/datagrip/" target="_blank" rel="noopener">DataGrip</a></li>
<li><a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">PyCharm</a></li>
<li><a href="https://atom.io/" target="_blank" rel="noopener">Atom</a></li>
<li><a href="https://www.sublimetext.com/" target="_blank" rel="noopener">Sublime Text3</a></li>
<li><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a></li>
<li><a href="https://www.getpostman.com/" target="_blank" rel="noopener">Postman</a></li>
<li><a href="https://filezilla-project.org/" target="_blank" rel="noopener">FileZilla</a></li>
</ul>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><ul>
<li><a href="https://www.docker.com/" target="_blank" rel="noopener">Docker</a></li>
<li><a href="https://www.parallels.com/cn/products/desktop/" target="_blank" rel="noopener">Parallels Desktop</a> </li>
</ul>
<h2 id="Chrome-插件"><a href="#Chrome-插件" class="headerlink" title="Chrome 插件"></a><a href="https://www.google.com/intl/zh-HK/chrome/" target="_blank" rel="noopener">Chrome</a> 插件</h2><ul>
<li>Adblock Plus - 免费广告拦截程序</li>
<li>CaretTab - 新式可以显示时间和日期的标签</li>
<li>Dark Reader - 黑色主题，适用于任何网站。关爱眼睛，就使用Dark Reader进行夜间和日间浏览。</li>
<li>GITHUBER - 开发者的新标签页</li>
<li>Google 翻译</li>
<li>Imagus</li>
<li>Octotree</li>
<li>ReadFree 传送门</li>
<li>Stylish -为任意网站自定义主题</li>
<li>Vimium</li>
<li>下载+ 管理你的下载快速通道。是你的方便、快捷、高效的工具！媒体资源探测下载: 视频, 音频, 图片等</li>
<li>书签侧边栏 - 在浏览器视图区左侧添加固定式的, 管理所有书签的侧边栏.</li>
<li>谷歌上网助手 </li>
<li>马克飞象 - 强大的Markdown离线编辑器，专为印象笔记打造</li>
<li>Tampermonkey</li>
</ul>
<h2 id="办公"><a href="#办公" class="headerlink" title="办公"></a>办公</h2><ul>
<li><a href="https://www.office.com/" target="_blank" rel="noopener">office</a></li>
<li><a href="https://mac.wps.cn/" target="_blank" rel="noopener">WPS</a></li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><a href="https://www.smartisan.com/apps/#/handshaker" target="_blank" rel="noopener">HandShaker</a></li>
<li><a href="https://itunes.apple.com/cn/app/kindle/id405399194?mt=12" target="_blank" rel="noopener">kindle</a> </li>
<li><a href="https://toolinbox.net/Klib/" target="_blank" rel="noopener">klib</a></li>
<li><a href="https://iina.io/" target="_blank" rel="noopener">IINA</a> </li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown 中文排版规范</title>
    <url>/year/05/24/mdzwgf/</url>
    <content><![CDATA[<p>文档书写一定要遵守规范，统一中文文案、排版的相关用法，降低团队成员之间的沟通成本，增强网站气质。</p>
<p>原地址 – <a href="https://github.com/mzlogin/chinese-copywriting-guidelines" target="_blank" rel="noopener">中文文案排版致指北</a></p>
<a id="more"></a>

<h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><p>「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。  </p>
<h3 id="中英文之间需要增加空格"><a href="#中英文之间需要增加空格" class="headerlink" title="中英文之间需要增加空格"></a>中英文之间需要增加空格</h3><p>正确：</p>
<blockquote>
<p>在 LeanCloud 上，数据存储是围绕 AVObject 进行的。</p>
</blockquote>
<p>错误：</p>
<blockquote>
<p>在LeanCloud上，数据存储是围绕AVObject进行的。</p>
</blockquote>
<blockquote>
<p>在 LeanCloud上，数据存储是围绕AVObject 进行的。</p>
</blockquote>
<p>完整的正确用法：</p>
<blockquote>
<p>在 LeanCloud 上，数据存储是围绕 AVObject 进行的。每个 AVObject 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 AVObject 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。</p>
</blockquote>
<p>例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。</p>
<h3 id="中文与数字之间需要增加空格"><a href="#中文与数字之间需要增加空格" class="headerlink" title="中文与数字之间需要增加空格"></a>中文与数字之间需要增加空格</h3><p>正确：</p>
<blockquote>
<p>今天出去买菜花了 5000 元。</p>
</blockquote>
<p>错误：</p>
<blockquote>
<p>今天出去买菜花了 5000元。</p>
</blockquote>
<blockquote>
<p>今天出去买菜花了5000元。</p>
</blockquote>
<blockquote>
<p>数字与单位之间无需增加空格<br>正确：</p>
</blockquote>
<blockquote>
<p>我家的光纤入户宽带有 10Gbps，SSD 一共有 10TB。</p>
</blockquote>
<p>错误：</p>
<blockquote>
<p>我家的光纤入户宽带有 10 Gbps，SSD 一共有 20 TB。</p>
</blockquote>
<p>另外，度／百分比与数字之间不需要增加空格：</p>
<p>正确：</p>
<blockquote>
<p>今天是 233° 的高温。</p>
</blockquote>
<blockquote>
<p>新 MacBook Pro 有 15% 的 CPU 性能提升。</p>
</blockquote>
<p>错误：</p>
<blockquote>
<p>今天是 233 ° 的高温。</p>
</blockquote>
<blockquote>
<p>新 MacBook Pro 有 15 % 的 CPU 性能提升。</p>
</blockquote>
<h3 id="全角标点与其他字符之间不加空格"><a href="#全角标点与其他字符之间不加空格" class="headerlink" title="全角标点与其他字符之间不加空格"></a>全角标点与其他字符之间不加空格</h3><p>正确：</p>
<blockquote>
<p>刚刚买了一部 iPhone，好开心！</p>
</blockquote>
<p>错误：</p>
<blockquote>
<p>刚刚买了一部 iPhone ，好开心！</p>
</blockquote>
<p><strong>-ms-text-autospace to the rescue?</strong><br>Microsoft 有个 <a href="https://msdn.microsoft.com/library/ms531164(v=vs.85).aspx" target="_blank" rel="noopener">-ms-text-autospace</a> 的 CSS 属性可以实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如 OS X、iOS 的用户界面目前并不存在这个特性，所以请继续保持随手加空格的习惯。</p>
<h2 id="全角和半角"><a href="#全角和半角" class="headerlink" title="全角和半角"></a>全角和半角</h2><p>不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『全角和半角』。</p>
<h3 id="使用全角中文标点"><a href="#使用全角中文标点" class="headerlink" title="使用全角中文标点"></a>使用全角中文标点</h3><p>正确：</p>
<blockquote>
<p>嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！</p>
</blockquote>
<blockquote>
<p>核磁共振成像（NMRI）是什么原理都不知道？JFGI！</p>
</blockquote>
<p>错误：</p>
<blockquote>
<p>嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎!</p>
</blockquote>
<blockquote>
<p>嗨!你知道嘛?今天前台的小妹跟我说”喵”了哎!</p>
</blockquote>
<blockquote>
<p>核磁共振成像 (NMRI) 是什么原理都不知道? JFGI!</p>
</blockquote>
<blockquote>
<p>核磁共振成像(NMRI)是什么原理都不知道?JFGI!</p>
</blockquote>
<h3 id="数字使用半角字符"><a href="#数字使用半角字符" class="headerlink" title="数字使用半角字符"></a>数字使用半角字符</h3><p>正确：</p>
<blockquote>
<p>这件蛋糕只卖 1000 元。</p>
</blockquote>
<p>错误：</p>
<blockquote>
<p>这件蛋糕只卖 １０００ 元。</p>
</blockquote>
<p>例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全角数字的。</p>
<h3 id="遇到完整的英文整句、特殊名词，其內容使用半角标点"><a href="#遇到完整的英文整句、特殊名词，其內容使用半角标点" class="headerlink" title="遇到完整的英文整句、特殊名词，其內容使用半角标点"></a>遇到完整的英文整句、特殊名词，其內容使用半角标点</h3><p>正确：</p>
<blockquote>
<p>乔布斯那句话是怎么说的？「Stay hungry, stay foolish.」</p>
</blockquote>
<blockquote>
<p>推荐你阅读《Hackers &amp; Painters: Big Ideas from the Computer Age》，非常的有趣。</p>
</blockquote>
<p>错误：</p>
<blockquote>
<p>乔布斯那句话是怎么说的？「Stay hungry，stay foolish。」</p>
</blockquote>
<blockquote>
<p>推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。    </p>
</blockquote>
<h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><h3 id="专有名词使用正确的大小写"><a href="#专有名词使用正确的大小写" class="headerlink" title="专有名词使用正确的大小写"></a>专有名词使用正确的大小写</h3><p>大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论內容，在这里只对部分易错用法进行简述。</p>
<p>正确：</p>
<blockquote>
<p>使用 GitHub 登录</p>
</blockquote>
<blockquote>
<p>我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。</p>
</blockquote>
<p>错误：</p>
<blockquote>
<p>使用 github 登录</p>
</blockquote>
<blockquote>
<p>使用 GITHUB 登录</p>
</blockquote>
<blockquote>
<p>使用 Github 登录</p>
</blockquote>
<blockquote>
<p>使用 gitHub 登录</p>
</blockquote>
<blockquote>
<p>使用 gｲんĤЦ8 登录</p>
</blockquote>
<blockquote>
<p>我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。</p>
</blockquote>
<blockquote>
<p>我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。</p>
</blockquote>
<blockquote>
<p>我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。</p>
</blockquote>
<blockquote>
<p>我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。</p>
</blockquote>
<p>注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML 中请使用标准的大小写规范进行书写；并通过 text-transform: uppercase;／text-transform: lowercase; 对表现形式进行定义。</p>
<h3 id="不要使用不地道的缩写"><a href="#不要使用不地道的缩写" class="headerlink" title="不要使用不地道的缩写"></a>不要使用不地道的缩写</h3><p>正确：</p>
<blockquote>
<p>我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。</p>
</blockquote>
<p>错误：</p>
<blockquote>
<p>我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。</p>
</blockquote>
<h2 id="争议"><a href="#争议" class="headerlink" title="争议"></a>争议</h2><p>以下用法略带有个人色彩，既：无论是否遵循下述规则，从语法的角度来讲都是正确的。</p>
<h3 id="链接之间增加空格"><a href="#链接之间增加空格" class="headerlink" title="链接之间增加空格"></a>链接之间增加空格</h3><p>用法：</p>
<blockquote>
<p>请 <a href="">提交一个 issue</a> 并分配给相关同事。</p>
</blockquote>
<blockquote>
<p>访问我们网站的最新动态，请 <a href="">点击这里</a> 进行订阅！</p>
</blockquote>
<p>对比用法：</p>
<blockquote>
<p><a href="">请提交一个 issue</a> 并分配给相关同事。</p>
</blockquote>
<blockquote>
<p>访问我们网站的最新动态，请<a href="">点击这里</a>进行订阅！</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>mac设置指南</title>
    <url>/year/10/10/mac%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>原文地址: _<a href="https://github.com/macdao/ocds-guide-to-setting-up-mac#%E5%85%A8%E9%94%AE%E7%9B%98%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">传送门</a></p>
<h2 id="如何配置一个高效的-Mac-工作环境"><a href="#如何配置一个高效的-Mac-工作环境" class="headerlink" title="如何配置一个高效的 Mac 工作环境"></a>如何配置一个高效的 Mac 工作环境</h2><a id="more"></a>

<p><a href="https://github.com/macdao/ocds-guide-to-setting-up-mac/blob/master/README.en.md" target="_blank" rel="noopener">English Version</a></p>
<h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ol>
<li><p><a href="#1-os-x">OS X</a></p>
<ul>
<li><a href="#功能键">功能键</a></li>
<li><a href="#全键盘控制">全键盘控制</a></li>
<li><a href="#spotlight-快捷键">Spotlight 快捷键</a></li>
<li><a href="#输入法快捷键">输入法快捷键</a></li>
<li><a href="#其他快捷键">其他快捷键</a></li>
<li><a href="#设置-trackpad-轻点来点按">设置 Trackpad 轻点来点按</a></li>
<li><a href="#语音">语音</a></li>
<li><a href="#词典">词典</a></li>
<li><a href="#dock-position">Dock Position</a></li>
<li><a href="#更改-caps-lock-键为-control-键">更改 Caps Lock 键为 Control 键</a></li>
<li><a href="#remove-all-dock-iconsocd">Remove all Dock icons[OCD]</a></li>
<li><a href="#重置-launchpad-上图标位置ocd">重置 Launchpad 上图标位置[OCD]</a></li>
<li><a href="#创建大小写敏感的工作区">创建大小写敏感的工作区</a></li>
<li><a href="#keychain-access">Keychain Access</a></li>
</ul>
</li>
<li><p><a href="#2-常用工具">常用工具</a></p>
<ul>
<li><a href="#homebrew">Homebrew</a></li>
<li><a href="#homebrew-cask">Homebrew Cask</a></li>
<li><a href="#iterm2">iTerm2</a></li>
<li><a href="#oh-my-zsh">Oh My Zsh</a></li>
<li><a href="#stow">stow</a></li>
<li><a href="#git-常用别名">Git 常用别名</a></li>
<li><a href="#scroll-reverser">Scroll Reverser</a></li>
<li><a href="#shiftit">ShiftIt</a></li>
<li><a href="#sublime-text-2">Sublime Text 2</a></li>
<li><a href="#macdown">MacDown</a></li>
<li><a href="#z">z</a></li>
<li><a href="#vimium">Vimium</a></li>
<li><a href="#lastpass">LastPass</a></li>
<li><a href="#sourcetree">SourceTree</a></li>
<li><a href="#cheatsheet">CheatSheet</a></li>
<li><a href="#alfred">Alfred</a></li>
</ul>
</li>
<li><p><a href="#3-开发工具">开发工具</a></p>
<ul>
<li><a href="#java">Java</a></li>
<li><a href="#jenv">jEnv</a></li>
<li><a href="#民间使用的-java-版本切换方法">民间使用的 Java 版本切换方法</a></li>
<li><a href="#javaocd">Java[OCD]</a></li>
<li><a href="#intellij-idea">IntelliJ IDEA</a></li>
<li><a href="#rbenv">rbenv</a></li>
<li><a href="#ruby-常用别名">Ruby 常用别名</a></li>
<li><a href="#node-版本管理">Node 版本管理</a></li>
</ul>
</li>
</ol>
<p>一直想写这么一篇文章，把我从同事那里学到的经验分享出来。市面上有很多类似的文章，写得都非常好，让我受益匪浅。不过我还是有一些自己总结出来的经验想要分享。</p>
<p>在工作中，我一般会在 1 到 10 人的团队中，经常会结对编程，即两个人共用一台 Mac 工作，因此也经常会把 Mac 外接一个大显示器、鼠标和键盘。我的常用开发平台有 Java、Ruby、Node.js、Web 等，使用 <a href="https://www.jetbrains.com/" target="_blank" rel="noopener">JetBrains</a> 的开发工具，比如 IntelliJ IDEA、RubyMine、WebStorm 等。</p>
<p>我深知自己的知识有限，所以写下本文以便和大家切磋交流。同时更有效率的方法和更好的工具也在不断涌现，我也贪心的希望把更好的方法和工具都收集更到到这里，我会不断更新本文，让它尽量不过时。最新内容请访问：<a href="https://github.com/macdao/ocds-guide-to-setting-up-mac" target="_blank" rel="noopener">https://github.com/macdao/ocds-guide-to-setting-up-mac</a>。欢迎通过 GitHub 的<code>Issues</code>或者直接<code>Pull Requests</code>方式来分享你的经验。期待你的反馈。</p>
<p>我认为“一个高效的 Mac 工作环境”有以下几个特点：</p>
<ul>
<li><p>自动化</p>
<p>举个例子。手动安装一个应用，需要1)打开浏览器，2)搜索应用的名字，3)打开应用网站，4)寻找下载链接和安装方法，5)下载并等待下载完成，6)安装下载文件，7)可能还有后续的安装步骤。而自动化安装一个应用，只需要1)打开终端工具，2)敲入安装命令，3)等待完成这几个步骤。</p>
<p>自动化可以大大简化操作，提高效率。</p>
</li>
<li><p>统一</p>
<p>我经常结对编程，偶尔会遇到快捷键不一样，命令不同等问题。我强烈建议，至少在一个团队中，大家尽量使用相同的快捷键、命令等环境。（我记得有个实践就是这个，可是我一直没找到该实践的名字和出处，求告诉）</p>
</li>
<li><p>够用</p>
<p>够用就好，如果系统本身已经满足了我的需求，我不会再使用第三方工具。</p>
</li>
<li><p>效率</p>
<p>效率，一切都是为了效率。</p>
</li>
</ul>
<p>本文对于第三方应用如何安装和使用只有最简单的介绍，具体还请参考官方网站和相关文档。</p>
<p>有些章节标题标注了[OCD]，意思是这些章节带有我强烈的个人色彩，如果你跟我臭味相投，欢迎借鉴，如果你并不认同，请忽略掉好了。</p>
<p>PS：虽然本文名为“强迫症”，但其实并不是<a href="https://zh.wikipedia.org/wiki/强迫症" target="_blank" rel="noopener">真正意义上的强迫症</a>，真正意义上的强迫症是一种会对患者的日常生活产生负面影响的疾病。</p>
<h2 id="1-OS-X"><a href="#1-OS-X" class="headerlink" title="1. OS X"></a>1. OS X</h2><p>本节介绍操作系统本身的一些设置。</p>
<h3 id="功能键"><a href="#功能键" class="headerlink" title="功能键"></a>功能键</h3><p>默认情况下，F1-F12 都是特殊功能，比如调节屏幕亮度。而当你需要键入 F1-F12 时（比如在使用 IntelliJ IDEA 的快捷键时），需要同时按住 Fn。这对于开发人员来说是非常不方便的。</p>
<p>把 F1-F12 改成标准功能键：选择<code>System Preferences</code> &gt; <code>Keyboard</code>，在<code>Keyboard</code>标签页中选中<code>Use all F1, F2, etc. keys as standard function keys</code>。</p>
<h3 id="全键盘控制"><a href="#全键盘控制" class="headerlink" title="全键盘控制"></a>全键盘控制</h3><p>当你在 Sublime Text 里关闭文件时，可能会遇到这样的对话框：</p>
<p><img src="http://ovlnt0xy1.bkt.clouddn.com/2017-10-10-dialog-box-without-all-controls.png" alt="dialog-box-without-all-controls"></p>
<p>注意这个<code>Save</code>按钮跟其他两个按钮不太一样，它的底色是蓝的。这种按钮被称为默认按钮，除了用鼠标点击触发外，还可以通过回车键触发。</p>
<p>那么问题来了，如果你不想保存，想点击<code>Don&#39;t Save</code>，是不是只能用鼠标点击了呢？</p>
<p>并不是这样：选择<code>System Preferences</code> &gt; <code>Keyboard</code>，在<code>Shortcuts</code>标签页中选择<code>All controls</code>；或者使用快捷键<code>⌃F7</code>。之后这个对话框会变成这样：</p>
<p><img src="http://ovlnt0xy1.bkt.clouddn.com/2017-10-10-dialog-box-with-all-controls.png" alt="dialog-box-with-all-controls"></p>
<p>这个<code>Don&#39;t Save</code>按钮有了一圈蓝边，这个意味着你可以通过空格键触发。不仅如此，你还可以用<code>Tab</code>键把蓝边转移到其他按钮，来实现全键盘控制。</p>
<p>除了<code>All controls</code>这个方法，你还可以用<code>⌘⌫</code>来选择<code>Don&#39;t Save</code>。<code>⌘⌫</code>的作用是在包含“删除”或“不存储”按钮的对话框中选择“删除”或“不存储”。</p>
<p>除了上述两个办法之外，居然还有个方法！就是按<code>⌘D</code>！据说是因为按<code>⌘+按钮的大写首字母</code>可以触发该按钮。可是！我按了<code>⌘C</code>和<code>⌘S</code>想取消和保存都没用！但是<code>⌘D</code>真的有用！如果仅仅是这也就算了，可是我又手贱试了下 TextEdit，在关闭未保存的文件时弹出的对话框上有三个按钮<code>Delete</code>、<code>Cancel</code>和<code>Save</code>。然而<code>⌘D</code>和<code>⌘C</code>都没用，但是！<code>⌘S</code>可以保存！我完全不能理解！我整个人几乎都是崩溃的，只好以咆哮体写下这段文字。如果谁能解释请务必告诉我，必有重谢！</p>
<p><code>⌘C</code>不能用应该是因为它绑定到了复制功能；而<code>⌘D</code>不能用因为它的作用是从“打开”对话框或“存储”对话框中选择“桌面”文件夹。</p>
<p>在这个对话框上，你可以用<code>Esc</code>来执行<code>Cancel</code>操作。</p>
<h3 id="Spotlight-快捷键"><a href="#Spotlight-快捷键" class="headerlink" title="Spotlight 快捷键"></a>Spotlight 快捷键</h3><p>中文版 OS X 的 Spotlight 的快捷键是<code>⌃Space</code>。这个快捷键有一些问题：</p>
<ul>
<li>JetBrains 的 IDE，比如 IntelliJ IDEA、WebStorm 等都使用<code>⌃Space</code>作为自动完成这个最常用功能的快捷键。我不建议更改 IDE 的快捷键，而建议更改 Spotlight 的快捷键。</li>
<li>对于没有添加中文输入法的 Mac 来说，Spotlight 的快捷键是<code>⌘Space</code>。英语国家的人都是这样的。所以我建议把 Spotlight 的快捷键设置为<code>⌘Space</code>，跟他们一致。</li>
</ul>
<h3 id="输入法快捷键"><a href="#输入法快捷键" class="headerlink" title="输入法快捷键"></a>输入法快捷键</h3><p>一般来说切换输入法的快捷键是<code>⌘Space</code>。由于我建议把 Spotlight 的快捷键设置为<code>⌘Space</code>，所以我建议把切换输入法的快捷键设置为<code>⌥Space</code>。</p>
<h3 id="其他快捷键"><a href="#其他快捷键" class="headerlink" title="其他快捷键"></a>其他快捷键</h3><p>让双手尽量多的键盘和快捷键，少使用鼠标和触摸板，可以大大提高效率。</p>
<ul>
<li><p><a href="https://support.apple.com/kb/HT201236" target="_blank" rel="noopener">Mac keyboard shortcts</a></p>
<p>苹果官方文档。当你在写代码，怎么通过快捷键让光标转移到行首、行尾、向上翻页或者将光标移左移一个词？都在这篇文档里。</p>
</li>
<li><p><a href="https://support.apple.com/kb/HT204434" target="_blank" rel="noopener">Mac keyboard shortcuts for accessibility features</a></p>
<p>苹果官方文档。回车触发蓝底按钮，空格触发蓝边按钮，都出自这里。</p>
</li>
</ul>
<h3 id="设置-Trackpad-轻点来点按"><a href="#设置-Trackpad-轻点来点按" class="headerlink" title="设置 Trackpad 轻点来点按"></a>设置 Trackpad 轻点来点按</h3><p>默认情况下按下触摸板才是点按（click）。我喜欢设置成用轻点作为点按：</p>
<p>选择<code>System Preferences</code> &gt; <code>Trackpad</code>，在<code>Point &amp; Click</code>标签页中选中<code>Tap to click</code>。</p>
<h3 id="语音"><a href="#语音" class="headerlink" title="语音"></a>语音</h3><p>OS X 自带了语音功能，可以用<code>say</code>命令让 Mac 开口说话：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">say hello</span><br></pre></td></tr></table></figure>

<p>可以和<code>&amp;&amp;</code>或者<code>;</code>配合使用来提示你某任务已经完成：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew update &amp;&amp; brew upgrade &amp;&amp; brew cleanup ; say mission complete</span><br></pre></td></tr></table></figure>

<p>通过命令行来听取发音还是有点麻烦。其实我们几乎可以在任何地方选中单词，然后使用快捷键<code>⌥+ESC</code>发音。仅仅需要这样设置一下：选择<code>System Preferences</code> &gt; <code>Dictation &amp; Speech</code>，在<code>Text to Speech</code>标签页中选中<code>Speak selected text when the key is pressed</code>。</p>
<h3 id="词典"><a href="#词典" class="headerlink" title="词典"></a>词典</h3><p>OS X 自带了词典（Dictionary）。你几乎可以在任何应用中通过三指轻拍触摸板来现实对应单词的释义。</p>
<p>也可以打开 Dictionary 应用来查找单词。</p>
<p>可以在 Dictionary 应用中添加英汉汉英词典。</p>
<h3 id="Dock-Position"><a href="#Dock-Position" class="headerlink" title="Dock Position"></a>Dock Position</h3><p>默认 Dock 在屏幕下方。我们的屏幕一般都是 16:10，Dock 在屏幕下方的话会占据本来就不大的垂直空间。建议把 Dock 放到左边或者右边。</p>
<h3 id="更改-Caps-Lock-键为-Control-键"><a href="#更改-Caps-Lock-键为-Control-键" class="headerlink" title="更改 Caps Lock 键为 Control 键"></a>更改 Caps Lock 键为 Control 键</h3><p>我经常用到<code>Control</code>键，但这个键在键盘的左下角，很难按到。同时我发现我很少使用<code>Caps Lock</code>键，我一般会用<code>Shift</code>键加字母来输入大写字母，或者先输入小写再（通过快捷键）转换成大写。</p>
<p>基于以上原因，我把<code>Caps Lock</code>键的功能改成了<code>Control</code>键。很多同事也都这么做的，可能是受到 <a href="https://en.wikipedia.org/wiki/Happy_Hacking_Keyboard" target="_blank" rel="noopener">HHKB</a> 的影响。</p>
<p>设置方法：选择<code>System Preferences</code> &gt; <code>Keyboard</code>，在<code>Keyboard</code>标签页中点击<code>Modifier Keys...</code>按钮，在弹出的窗口中，把<code>Caps Lock (⇪) Key:</code>对应的选项改成<code>⌃ Control</code>。</p>
<h3 id="Remove-all-Dock-icons-OCD"><a href="#Remove-all-Dock-icons-OCD" class="headerlink" title="Remove all Dock icons[OCD]"></a>Remove all Dock icons[OCD]</h3><p>本条目对于强迫症适用。</p>
<p>默认情况下 Dock 被一堆系统自带的应用占据着，而其中大部分我都很少使用，当我打开几个常用应用后，Dock 上会有很多图标，每个图标都会被挤得很小。所以我会把所有 Dock 上固定的图标都删掉，这样一来 Dock 上只有我打开的应用。</p>
<p>PS：Finder 图标是删不掉的。</p>
<p>除了一个一个删除图标，也可以通过这个命令来隐藏所有的固定图标：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">defaults write com.apple.dock static-only -boolean <span class="literal">true</span>; killall Dock</span><br></pre></td></tr></table></figure>

<p>恢复也非常简单：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">defaults delete com.apple.dock static-only; killall Dock</span><br></pre></td></tr></table></figure>

<p>PS：使用这个方法的话，Dock 上的<code>Downloads</code>也会被隐藏掉。</p>
<h3 id="重置-Launchpad-上图标位置-OCD"><a href="#重置-Launchpad-上图标位置-OCD" class="headerlink" title="重置 Launchpad 上图标位置[OCD]"></a>重置 Launchpad 上图标位置[OCD]</h3><p>本条目对于强迫症适用。</p>
<p>新的应用被安装后，经常会跑到 Launchpad 的第一屏，所以它们的位置跟安装的顺序有关系，而我更希望它们可以按照某种更加稳定的顺序排列，比如按照系统默认的顺序：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">defaults write com.apple.dock ResetLaunchPad -bool <span class="literal">true</span>; killall Dock</span><br></pre></td></tr></table></figure>

<p>在默认顺序中，Launchpad 第一屏只有 Apple 自家应用。</p>
<h3 id="创建大小写敏感的工作区"><a href="#创建大小写敏感的工作区" class="headerlink" title="创建大小写敏感的工作区"></a>创建大小写敏感的工作区</h3><p>在多人合作的项目开发时，因为 Mac 文件系统默认是大小写不敏感的，所以经常会出现一些诡异的问题。创建一个大小写敏感的工作区（workspace）来解决避免这些问题：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hdiutil create -<span class="built_in">type</span> SPARSE -fs <span class="string">'Case-sensitive Journaled HFS+'</span> -size 100g -volname workspace ~/Documents/workspace.dmg.sparseimage</span><br></pre></td></tr></table></figure>

<p>可以通过三种方式挂载镜像：</p>
<ol>
<li>直接双击打开 <code>~/Documents/workspace.dmg.sparseimage</code></li>
<li><code>open ~/Documents/workspace.dmg.sparseimage</code></li>
<li><code>hdiutil attach ~/Documents/workspace.dmg.sparseimage</code></li>
</ol>
<h3 id="Keychain-Access"><a href="#Keychain-Access" class="headerlink" title="Keychain Access"></a>Keychain Access</h3><p>钥匙串访问（Keychain Access）是一个 OS X 应用程序，对我来说它最大的功能就是查看已经保存的各种账号和密码，包括 Wi-Fi 密码。</p>
<h2 id="2-常用工具"><a href="#2-常用工具" class="headerlink" title="2. 常用工具"></a>2. 常用工具</h2><p>本节介绍一些常用的，跟开发没有直接关系的第三方应用及其设置。</p>
<h3 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a><a href="http://brew.sh" target="_blank" rel="noopener">Homebrew</a></h3><p>包管理工具，官方称之为<code>The missing package manager for OS X</code>。</p>
<p>安装步骤见官网。</p>
<p>有了 brew 以后，要下载工具，比如 MySQL、Gradle、Maven、Node.js 等工具，就不需要去网上下载了，只要一行命令就能搞定：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install mysql gradle maven node</span><br></pre></td></tr></table></figure>

<p>PS：安装 brew 的时候会自动下载和安装 Apple 的 Command Line Tools。</p>
<p>brew 的替代品有 <a href="https://www.macports.org/" target="_blank" rel="noopener">MacPorts</a>，现在基本没人用它。</p>
<h3 id="Homebrew-Cask"><a href="#Homebrew-Cask" class="headerlink" title="Homebrew Cask"></a><a href="https://caskroom.github.io" target="_blank" rel="noopener">Homebrew Cask</a></h3><p>brew-cask 允许你使用命令行安装 OS X 应用。比如你可以这样安装 Chrome：<code>brew cask install google-chrome</code>。还有 Evernote、Skype、Sublime Text、VirtualBox 等都可以用 brew-cask 安装。</p>
<p>brew-cask 是社区驱动的，如果你发现 brew-cask 上的应用不是最新版本，或者缺少你某个应用，你可以自己提交 pull request。</p>
<p>安装步骤见官网。</p>
<p>应用也可以通过 App Store 安装，而且有些应用只能通过 App Store 安装，比如 Xcode 等一些 Apple 的应用。App Store 没有对应的命令行工具，还需要 Apple ID。倒是更新起来很方便。</p>
<p>几乎所有常用的应用都可以通过 brew-cask 安装，而且是从应用的官网上下载，所以你要安装新的应用时，建议用 brew-cask 安装。如果你不知道应用在 brew-cask 中的 ID，可以先用<code>brew cask search</code>命令搜索。</p>
<h3 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a><a href="https://www.iterm2.com/" target="_blank" rel="noopener">iTerm2</a></h3><p>iTerm2 是最常用的终端应用，是 Terminal 应用的替代品。提供了诸如<code>Split Panes</code>等<a href="https://www.iterm2.com/features.html" target="_blank" rel="noopener">一群实用特性</a>。它默认的黑色背景让我毫不犹豫的抛弃了 Terminal。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew cask install iterm2</span><br></pre></td></tr></table></figure>

<p>感谢 brew-cask，我们可以通过命令行自动安装 iTerm2 了。</p>
<p>在终端里，除了可以用<code>⌃E</code>等快捷键（详见<a href="#其他快捷键">其他快捷键</a>）之外，还可以使用<code>⌥B</code>、<code>⌥F</code>等快捷键（具体可以参考<a href="http://ss64.com/bash/syntax-keyboard.html" target="_blank" rel="noopener">这里</a>）。前提是这样设置一下：</p>
<p>选择<code>Iterm</code>菜单 &gt; <code>Preferences</code> &gt; <code>Profiles</code>，选择你在使用的 Profile（默认是<code>Default</code>），在<code>Keys</code>标签页中把<code>Left option (⌥) key acts as</code>和<code>Right option (⌥) key acts as</code>都设置成<code>+ESC</code>。</p>
<p>在打开新的窗口/标签页的时候，默认情况下新窗口总是 HOME 目录，还需要我每次敲命令才能进入工作目录。如果想要这个新窗口在打开的时候就自动进入工作目录，需要如下设置：</p>
<p>选择<code>Iterm</code>菜单 &gt; <code>Preferences</code> &gt; <code>Profiles</code>，选择你在使用的 Profile（默认是Default），在<code>General</code>标签页中的<code>Working Directory</code>部分中选择<code>Reuse previous seesion&#39;s directory</code>。</p>
<p>至此，Terminal 应用已经出色的完成了其历史使命。后面命令行就交给 iTerm2 啦。</p>
<p>在 iTerm2 中双击会自动选中对应的词，三击会选中对应的整行。选中的内容会自动进入剪贴板，不需要再按<code>⌘C</code>复制。</p>
<h3 id="Oh-My-Zsh"><a href="#Oh-My-Zsh" class="headerlink" title="Oh My Zsh"></a><a href="http://ohmyz.sh" target="_blank" rel="noopener">Oh My Zsh</a></h3><p>默认的 Bash 是黑白的，没有色彩。而 Oh My Zsh 可以带你进入彩色时代。Oh My Zsh 同时提供一套插件和工具，可以简化命令行操作。后面我们会看到很多介绍，你会看到我爱死这家伙了。</p>
<p>安装方法见官网。</p>
<p>目前我使用的插件有：<code>git z sublime history rbenv bundler rake</code></p>
<p>Oh My Zsh 使用了 Z shell（zsh），一个和 Bash 相似的 Shell，而非 Bash。</p>
<p>在 Z shell 中，<code>~/.zshrc</code>是最重要的配置文件。Oh My Zsh 在安装的时候会把当前环境的<code>$PATH</code>写入<code>~/.zshrc</code>中。这并不是我期望的行为，因为使用了 brew，我们基本不再需要去定制<code>$PATH</code>，而 Oh My Zsh 提供的默认<code>$PATH</code>值<code>$HOME/bin:/usr/local/bin:$PATH</code>是非常合适的一个值，它把<code>$HOME/bin</code>加入了<code>$PATH</code>，可以让我们把自己用的脚本放到<code>$HOME/bin</code>下。</p>
<p>所以建议把<code>~/.zshrc</code>重置：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://github.com/robbyrussell/oh-my-zsh/commit/551abfcbb48a0c001eadef80abc3276af4e9ad26" target="_blank" rel="noopener">2016年6月17号的一次提交</a>后，<code>zshrc.zsh-template</code>就不再修改<code>$PATH</code>了。请找到<code># export PATH=$HOME/bin:/usr/local/bin:$PATH</code>这一行，把前面的<code>#</code>去掉。</p>
</blockquote>
<p>Oh My Zsh 还有很多<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins-Overview" target="_blank" rel="noopener">有价值的插件</a>。</p>
<p>替代品有 <a href="https://github.com/oh-my-fish/oh-my-fish" target="_blank" rel="noopener">Oh My Fish</a>。基于 <a href="http://fishshell.com/" target="_blank" rel="noopener">Fishshell</a> 。</p>
<h3 id="Stow"><a href="#Stow" class="headerlink" title="Stow"></a><a href="http://www.gnu.org/software/stow/" target="_blank" rel="noopener">Stow</a></h3><p>GNU stow 是管理符号链接（symlink）的一个小公举。主要用于 symlink 你的 <a href="http://dotfiles.github.io/" target="_blank" rel="noopener">dotfiles</a> 如 emacs，git，fish/zsh 的配置文件。安装只需要</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">brew install stow</span><br></pre></td></tr></table></figure>

<p>安装了 stow 之后，我们可以开始 symlink 一些 dotfiles 了。完整使用 stow 和 dotfiles 的流程可以参考 <a href="https://github.com/jcouyang/dotfiles" target="_blank" rel="noopener">https://github.com/jcouyang/dotfiles</a></p>
<p>当你的 dotfiles 都妥妥的 symlink 到 <code>~/dotfiles</code> 后，push 到 github 上就再也不怕换电脑了。</p>
<h3 id="Git-常用别名"><a href="#Git-常用别名" class="headerlink" title="Git 常用别名"></a>Git 常用别名</h3><p>几乎每个人都会使用一些方法比如 Git 别名来提高效率，几乎所有人都会把使用<code>git st</code>来代替<code>git status</code>。然而这需要手动设置，每个人也都不完全一样。</p>
<p>Oh My Zsh 提供了一套系统别名（alias），来达到相同的功能。比如<code>gst</code>作为<code>git status</code>的别名。而且 Git 插件是 Oh My Zsh 默认启用的，相当于你使用了 Oh My Zsh，你就拥有了一套高效率的别名，而且还是全球通用的。是不是棒棒哒？下面是一些我常用的别名：</p>
<table>
<thead>
<tr>
<th>Alias</th>
<th>Command</th>
</tr>
</thead>
<tbody><tr>
<td>gapa</td>
<td><code>git add --patch</code></td>
</tr>
<tr>
<td>gc!</td>
<td><code>git commit -v --amend</code></td>
</tr>
<tr>
<td>gcl</td>
<td><code>git clone --recursive</code></td>
</tr>
<tr>
<td>gclean</td>
<td><code>git reset --hard &amp;&amp; git clean -dfx</code></td>
</tr>
<tr>
<td>gcm</td>
<td><code>git checkout master</code></td>
</tr>
<tr>
<td>gcmsg</td>
<td><code>git commit -m</code></td>
</tr>
<tr>
<td>gco</td>
<td><code>git checkout</code></td>
</tr>
<tr>
<td>gd</td>
<td><code>git diff</code></td>
</tr>
<tr>
<td>gdca</td>
<td><code>git diff --cached</code></td>
</tr>
<tr>
<td>glola</td>
<td><code>git log --graph --pretty = format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit --all</code></td>
</tr>
<tr>
<td>gp</td>
<td><code>git push</code></td>
</tr>
<tr>
<td>grbc</td>
<td><code>git rebase --continue</code></td>
</tr>
<tr>
<td>gst</td>
<td><code>git status</code></td>
</tr>
<tr>
<td>gup</td>
<td><code>git pull --rebase</code></td>
</tr>
<tr>
<td>gwip</td>
<td><code>git add -A; git rm $(git ls-files --deleted) 2&gt; /dev/null; git commit -m &quot;--wip--&quot;</code></td>
</tr>
</tbody></table>
<p>完整列表请参考：<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git</a></p>
<h3 id="Scroll-Reverser"><a href="#Scroll-Reverser" class="headerlink" title="Scroll Reverser"></a>Scroll Reverser</h3><p>当你在浏览一个很长的网页时，你看完了当前显示的内容，想要看后续的内容，你可以在 Trackpad 上双指上滑，或者鼠标滚轮向上滚动。这是被称作“自然”的滚动方向。</p>
<p>然而在 Windows 里鼠标滚动的行为是相反的：鼠标滚轮向下滚动才会让浏览器显示后续的内容，向上滚动会达到页面的顶部。你可以在 OS X 的系统偏好设置里修改（选择<code>System Preferences</code> &gt; <code>Trackpad</code>，在<code>Scroll &amp; Zoom</code>标签页中不选中<code>Scroll direction: natural</code>），但是这样会同时改变鼠标滚轮的方向和 Trackpad 的方向。</p>
<p>要想只改变鼠标滚轮的方向，而保持 Trackpad 依旧是“自然”的，我们需要 Scroll Reverser：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew cask install scroll-reverser</span><br></pre></td></tr></table></figure>

<p>PS：这货会让三指点击失效</p>
<h3 id="ShiftIt"><a href="#ShiftIt" class="headerlink" title="ShiftIt"></a>ShiftIt</h3><p>原生 OS X 下只能手动调整窗口大小，所以我们需要窗口管理工具。我用过很多窗口管理工具，可惜大部分工具都存在快捷键冲突的问题（对我来说主要是 IntelliJ IDEA）。ShiftIt 是少见的没有冲突的窗口管理工具：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew cask install shiftit</span><br></pre></td></tr></table></figure>

<p>PS：ShiftIt的旧版本需要安装 X11，最新版本已经修正了这个问题。</p>
<p>替代者有 SizeUp，主要快捷键和 ShiftIt 相同。</p>
<p>当然如果喜欢 hacking，<a href="https://github.com/jigish/slate" target="_blank" rel="noopener">Slate</a>  是个不错的 hackable 的窗口管理工具。配置可以参照 <a href="http://thume.ca/howto/2012/11/19/using-slate/" target="_blank" rel="noopener">http://thume.ca/howto/2012/11/19/using-slate/</a></p>
<h3 id="Sublime-Text-2"><a href="#Sublime-Text-2" class="headerlink" title="Sublime Text 2"></a>Sublime Text 2</h3><p>安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew cask install sublime-text</span><br></pre></td></tr></table></figure>

<p>在命令行中指定使用 Sublime Text 打开某文件，是一个非常常用的功能，一般我们会按照 <a href="https://www.sublimetext.com/docs/2/osx_command_line.html" target="_blank" rel="noopener">OS X Command Line</a> 中所说执行 <code>ln -s &quot;/Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl&quot; ~/bin/subl</code> 来增加<code>subl</code>链接。但是如果你用 brew-cask 安装的话，恭喜你，你不需要运行这个命令，因为 brew-cask 自动帮你做了这件事情。而且你卸载 Sublime Text 的时候 brew-cask 会自动删掉这个链接。</p>
<p>同时 Oh My Zsh 也提供了 Sublime Text 插件，叫做<code>sublime</code>。参考：<a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/sublime" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/sublime</a>，这个插件和通过 brew-cask 安装的 Sublime Text 完美兼容。</p>
<p>替代品有 Atom、TextMate、Sublime Text 3 等，跟 Sublime Text 2 一样，用 brew-cask 安装的话命令行工具会被自动加入<code>$PATH</code>。</p>
<h3 id="MacDown"><a href="#MacDown" class="headerlink" title="MacDown"></a>MacDown</h3><p>MacDown 是 Markdown 编辑器。由于 Mou 一直不支持代码高亮，我就转向了 MacDown。完美支持 <a href="https://help.github.com/articles/github-flavored-markdown/" target="_blank" rel="noopener">GFM</a>。</p>
<p>我特别喜欢 <a href="https://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>，我用 Makdown 来写文章（包括本文），写幻灯片（<a href="https://github.com/hakimel/reveal.js/" target="_blank" rel="noopener">reveal.js</a>）。Markdown 可以让我专注于内容本身，而无需花精力在排版和样式上。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew cask install macdown</span><br></pre></td></tr></table></figure>

<h3 id="z"><a href="#z" class="headerlink" title="z"></a>z</h3><p>在打开终端后，你是怎么进入项目的工作目录？是<code>cd xxx</code>，<code>⌃R</code>还是用别名？</p>
<p><a href="https://github.com/rupa/z" target="_blank" rel="noopener">z</a> 工具可以帮你快速进入目录。比如在我的 Mac 上运行<code>z cask</code>就会进入<code>/usr/local/Library/Taps/caskroom/homebrew-cask/Casks</code>目录。</p>
<p>这货的安装非常方便，甚至都不需要下载任何东西，因为它已经整合在了 Oh My Zsh 中。编辑<code>~/.zshrc</code>文件，在<code>plugins=(git)</code>这行中加上<code>z</code>变成<code>plugins=(git z)</code>，然后运行<code>source ~/.zshrc</code>重新加载配置文件，就可以使用 z 了。</p>
<p>替代品有 autojump。autojump 需要使用 brew 安装。</p>
<h3 id="Vimium"><a href="#Vimium" class="headerlink" title="Vimium"></a><a href="https://vimium.github.io/" target="_blank" rel="noopener">Vimium</a></h3><p>Vimium 是一个 Google Chrome 扩展，让你可以纯键盘操作 Chrome，把你的 Chrome 变成“黑客的浏览器”。</p>
<p>安装方法请参考官方网站。</p>
<p>其他浏览器也有类似的工具，比如 FireFox 的 <a href="https://github.com/mooz/keysnail" target="_blank" rel="noopener">KeySnail</a>。</p>
<h3 id="LastPass"><a href="#LastPass" class="headerlink" title="LastPass"></a><a href="https://lastpass.com" target="_blank" rel="noopener">LastPass</a></h3><p>LastPass 是管理密码的工具，支持二次验证，提供所有浏览器插件以及 Mac 桌面版本。</p>
<p>最重要的是，它提供 <strong>命令行</strong> 的版本，可以直接通过 brew 安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install lastpass-cli --with-pinentry</span><br></pre></td></tr></table></figure>

<p>之后，只需要登陆：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lpass login you@email.com</span><br></pre></td></tr></table></figure>

<p>就可以拷贝密码或者集成到其他命令中了：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lpass show --password gmail.com -c</span><br></pre></td></tr></table></figure>

<h3 id="SourceTree"><a href="#SourceTree" class="headerlink" title="SourceTree"></a><a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">SourceTree</a></h3><p>SourceTree 是 Atlassian 公司出品的一款优秀的 Git 图形化客户端。如果你发现命令行无法满足你的要求，可以试试 SourceTree。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew cask install sourcetree</span><br></pre></td></tr></table></figure>

<p>用 brew-cask 安装会自动增加命令行工具<code>stree</code>到<code>$PATH</code>里。在命令行中输入<code>stree</code>可以快速用 SourceTree 打开当前 Git 仓库。详细用法请参见<code>stree --help</code>。</p>
<h3 id="CheatSheet"><a href="#CheatSheet" class="headerlink" title="CheatSheet"></a><a href="http://www.mediaatelier.com/CheatSheet/" target="_blank" rel="noopener">CheatSheet</a></h3><p>CheatSheet 能够显示当前程序的快捷键列表，默认的快捷键是长按<code>⌘</code>。</p>
<p><img src="http://www.mediaatelier.com/CheatSheet/imgs/main.png" alt="CheatSheet"></p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew cask install cheatsheet</span><br></pre></td></tr></table></figure>

<h3 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a><a href="https://www.alfredapp.com" target="_blank" rel="noopener">Alfred</a></h3><p>Mac 用户不用鼠标键盘的必备神器，配合大量 Workflows，习惯之后可以大大减少操作时间。</p>
<p>上手简单，调教成本在后期自定义 Workflows，不过有大量雷锋使用者提供的现成扩展，访问<a href="http://www.alfredworkflow.com/" target="_blank" rel="noopener">这里</a>挑选喜欢的，并可以极其简单地根据自己的需要修改。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew cask install alfred</span><br></pre></td></tr></table></figure>

<h2 id="3-开发工具"><a href="#3-开发工具" class="headerlink" title="3. 开发工具"></a>3. 开发工具</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>现在 OS X 都不会自带 JDK 了，所以进行 Java 开发的话，需要下载 JDK。在 brew-cask 之前，我们需要从 <a href="https://developer.apple.com/downloads/" target="_blank" rel="noopener">https://developer.apple.com/downloads/</a> 或者 Oracle 网站上下载。还有更麻烦的－－卸载 JDK 和升级 JDK。</p>
<p>JDK 安装文件是 pkg 格式，卸载和<code>.app</code>不一样，且没有自动卸载方式。</p>
<p>而 brew-cask 提供了自动安装和卸载功能，能够自动从官网上下载并安装 JDK 8。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew cask install java</span><br></pre></td></tr></table></figure>

<p>如果你需要安装 JDK 7 或者 JDK 6，可以使用<code>homebrew-cask-versions</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew tap caskroom/versions</span><br><span class="line">brew cask install java6</span><br></pre></td></tr></table></figure>

<p>在 OS X 上，你可以同时安装多个版本的 JDK。你可以通过命令<code>/usr/libexec/java_home -V</code>来查看安装了哪几个 JDK。</p>
<p>那问题来了，当你运行<code>java</code>或者 Java 程序时使用的是哪个 JDK 呢？在 OS X 下，<code>java</code>也就是<code>/usr/bin/java</code>在默认情况下指向的是已经安装的最新版本。但是你可以设置环境变量<code>JAVA_HOME</code>来更改其指向：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ java -version</span><br><span class="line">java version <span class="string">"1.8.0_60"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_60-b27)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.60-b23, mixed mode)</span><br><span class="line">$ JAVA_HOME=/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home java -version</span><br><span class="line">java version <span class="string">"1.6.0_65"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.6.0_65-b14-466.1-11M4716)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 20.65-b04-466.1, mixed mode)</span><br></pre></td></tr></table></figure>

<p>其中<code>JAVA_HOME=/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home</code>可以用<code>JAVA_HOME=`/usr/libexec/java_home -v 1.6`</code>这种更加通用的方式代替。</p>
<h3 id="jEnv"><a href="#jEnv" class="headerlink" title="jEnv"></a><a href="https://github.com/gcuisinier/jenv" target="_blank" rel="noopener">jEnv</a></h3><p>也可以使用 jEnv 来管理不同版本的 JDK，这个工具跟 <a href="#rbenv">rbenv</a> 类似，通过当前目录下的<code>.java-version</code>来决定使用哪个 JDK。jEnv 也可以用 brew 安装。不过要使用 jEnv 要有几个问题：</p>
<ul>
<li><p>需要手动把<code>eval &quot;$(jenv init -)&quot;</code>加入 profile，没有 Oh My Zsh 插件。这点是我非常反感的。</p>
<p>可以把<code>eval &quot;$(jenv init -)&quot;</code>加入<code>~/.zlogin</code>，这样可以避免修改<code>~/.zshrc</code>。</p>
</li>
<li><p>需要手动添加 JDK，不会自动采集系统 JDK。跟 Ruby 不同，OS X 已经提供<code>/usr/libexec/java_home</code>工具来管理安装的 JDK。</p>
</li>
<li><p>需要 <code>jenv rehash</code>。这个是跟 rbenv 学的。</p>
</li>
</ul>
<p>所以我建议不要使用 jEnv。</p>
<h3 id="民间使用的-Java-版本切换方法"><a href="#民间使用的-Java-版本切换方法" class="headerlink" title="民间使用的 Java 版本切换方法"></a>民间使用的 Java 版本切换方法</h3><p>添加以下脚本到当前 shell 配置文件中：<code>~/.zprofile</code>或者<code>~/.bash_profile</code>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">setjdk</span></span>() &#123;</span><br><span class="line">    <span class="built_in">export</span> JAVA_HOME=`/usr/libexec/java_home -v <span class="variable">$@</span>`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以通过输入一条命令进行版本切换了：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">setjdk 1.8</span><br></pre></td></tr></table></figure>

<h3 id="Java-OCD"><a href="#Java-OCD" class="headerlink" title="Java[OCD]"></a>Java[OCD]</h3><p>作为一个强迫症患者，每当我看到 Java 的错误写法就想纠正过来。</p>
<p>当指编程语言时，Java 的正确写法是首字母大写，其余小写。其他写法比如<code>JAVA</code>、<code>java</code>都是不对的。</p>
<p>在其他一些地方会使用小写的<code>java</code>：</p>
<ul>
<li><code>java</code>命令</li>
<li>原文件<code>Main.java</code></li>
<li>包名<code>java.lang</code></li>
</ul>
<p>只有在全大写的标题里使用<code>JAVA</code>或者环境变量<code>JAVA_HOME</code>。</p>
<h3 id="IntelliJ-IDEA"><a href="#IntelliJ-IDEA" class="headerlink" title="IntelliJ IDEA"></a>IntelliJ IDEA</h3><p>Java 开发必备工具 IntelliJ IDEA。可以安装 Ultimate Edition：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew cask install intellij-idea</span><br></pre></td></tr></table></figure>

<p>也可以安装开源免费的 Community Edition：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew cask install intellij-idea-ce</span><br></pre></td></tr></table></figure>

<p>IntelliJ IDEA 有几套内建的快捷键方案（Keymap）。其中适用于 OS X 的有<code>Mac OS X</code>和<code>Mac OS X 10.5+</code>两种。区别是:</p>
<ul>
<li><code>Mac OS X</code>方案和其他平台上的快捷键类似，</li>
<li>而<code>Mac OS X 10.5+</code>更加符合 OS X 常用的快捷键。</li>
</ul>
<p>一个团队使用不同的快捷键会严重影响效率。可以用<code>View | Quick Switch Scheme</code>（<code>⌃ Back Quote</code>）快速切换 Keymap。</p>
<p>如果可以选择的话，我建议使用<code>Mac OS X</code>方案。因为我经常遇到使用 Windows 的客户，而 Windows 平台上的快捷键和<code>Mac OS X</code>方案类似。</p>
<p>可以从 IDEA 的<code>Help &gt; Default Keymap Reference</code>打开快捷键的参考手册。不过从这里打开的是<code>Mac OS X 10.5+</code>方案的，而<code>Mac OS X</code>方案的可以从这里找到：<a href="http://www.basrikahveci.com/static/ij_keymap_mac.pdf" target="_blank" rel="noopener">http://www.basrikahveci.com/static/ij_keymap_mac.pdf</a>。</p>
<h3 id="rbenv"><a href="#rbenv" class="headerlink" title="rbenv"></a><a href="https://github.com/sstephenson/rbenv" target="_blank" rel="noopener">rbenv</a></h3><p>人人都需要一个 Ruby 版本管理工具。rbenv 就是这样一个轻量级工具，它可以通过 brew 安装。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install rbenv ruby-build</span><br></pre></td></tr></table></figure>

<p>然后在<code>~/.zshrc</code>中加上<code>rbenv</code>插件。否则你需要手动添加<code>eval &quot;$(rbenv init -)&quot;</code>到<code>~/zshrc</code>或者<code>~/.zprofile</code>文件里。</p>
<p>有时候项目会依赖一些奇怪的版本号，比如<code>ruby-2.1.0</code>，这个时候你需要 <a href="https://github.com/tpope/rbenv-aliases" target="_blank" rel="noopener">rbenv-aliases</a> 帮忙：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install rbenv-aliases</span><br></pre></td></tr></table></figure>

<p>替代品有 RVM、chruby。因为 RVM 不能通过 brew 安装，并且安装的时候会没有节操的修改一堆文件，所以被我早早的弃用了。chruby 也是一个轻量级工具，而且可以完美的和 Oh My Zsh 集成在一起，我看到有些生产环境在用它。</p>
<h3 id="Ruby-常用别名"><a href="#Ruby-常用别名" class="headerlink" title="Ruby 常用别名"></a>Ruby 常用别名</h3><p>几乎所有 Ruby 开发人员都会把<code>bi</code>作为<code>bundle install</code>的别名。Oh My Zsh 提供<code>builder</code>插件，这个插件提供了一套别名，比如<code>bi</code>、<code>be</code>。同时还能让你在运行一些常用 gem 的时候直接输入<code>rspec</code>，不需要<code>be rspec</code>这样了。具体包括哪些命令请参考<a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/bundler" target="_blank" rel="noopener">这里</a>。</p>
<p>Z shell 对于<code>[</code>和<code>]</code>符号有特殊的处理，所以在运行<code>rake task[parameter]</code>的时候会报错，你需要改成<code>rake task\[parameter\]</code>或者<code>noglob rake task[parameter]</code>。然而 Oh My Zsh 已经看穿这一切，自带的 rake 插件已经解决了这个问题：<code>brake task[parameter]</code>。</p>
<p>添加插件的时候注意把<code>rake</code>放到<code>bundler</code>后面，例如这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins=(git z sublime history rbenv bundler rake)</span><br></pre></td></tr></table></figure>

<h3 id="Node-版本管理"><a href="#Node-版本管理" class="headerlink" title="Node 版本管理"></a>Node 版本管理</h3><p>Node 的版本管理工具有很多，常用的会有以下几个：</p>
<ul>
<li><p><a href="https://github.com/nodenv/nodenv" target="_blank" rel="noopener">nodenv</a></p>
<p>该工具是一个类似 rbenv 的工具，命令和其完全一样，安装和配置也一样。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">brew install nodenv</span><br></pre></td></tr></table></figure>

<p>  你需要手动添加以下配置到<code>~/.zshrc</code>或者<code>~/.zprofile</code>文件里。</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">"<span class="variable">$HOME</span>/.nodenv/bin:<span class="variable">$PATH</span>"</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(nodenv init -)</span>"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a></p>
<p>该工具是一个类似 RVM 的工具，命令安装方式也基本一样，可以参考官方文档。</p>
</li>
<li><p><a href="https://github.com/tj/n" target="_blank" rel="noopener">n</a></p>
<p>一个简单的工具，安装方式类似 nvm，无需额外配置。具体参考官方文档。</p>
</li>
</ul>
<p>目前根据 GitHub Stars，这三个管理工具的排名依次是 nvm、n、nodenv。但是个人建议采用 nodenv，原因同 rbenv，尤其已经在使用 rbenv 的伙伴们会觉得 nodenv 更顺手 :smile: 。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://lapwinglabs.com/blog/hacker-guide-to-setting-up-your-mac" target="_blank" rel="noopener">Hacker’s Guide to Setting up Your Mac</a></li>
<li><a href="https://mattstauffer.co/blog/setting-up-a-new-os-x-development-machine-part-1-core-files-and-custom-shell" target="_blank" rel="noopener">Setting up a new (OS X) development machine</a></li>
<li><a href="http://www.xialeizhou.com/?p=71" target="_blank" rel="noopener">高效 MacBook 工作环境配置</a></li>
<li><a href="http://www.zhihu.com/question/20873070" target="_blank" rel="noopener">程序员如何优雅地使用 Mac？</a></li>
<li><a href="http://sspai.com/33493" target="_blank" rel="noopener">装点你的 Dock：外观篇</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 图形界面管理工具 -- Portainer</title>
    <url>/year/05/19/portainer/</url>
    <content><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g36jl1fll4j31fg0fkgnv.jpg" alt=""></p>
<a id="more"></a>

<p><a href="https://github.com/portainer/portainer" target="_blank" rel="noopener">Portainer</a>（基于 Go）是一个轻量级的管理界面，可让您轻松管理Docker主机或Swarm集群。</p>
<p>Portainer的使用意图是简单部署。它包含可以在任何 Docker 引擎上运行的单个容器（Docker for Linux 和 Docker for Windows）。</p>
<p>Portainer允许您管理 Docker 容器、image、volume、network 等。 它与独立的 Docker 引擎和 Docker Swarm 兼容。</p>
<h4 id="Docker-命令安装："><a href="#Docker-命令安装：" class="headerlink" title="Docker 命令安装："></a>Docker 命令安装：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">docker volume create portainer_data</span><br><span class="line"></span><br><span class="line">docker run -d -p <span class="number">9000</span>:<span class="number">9000</span> --name Portainer -v /<span class="keyword">var</span>/run/docker.sock:<span class="regexp">/var/</span>run/docker.sock -v portainer_data:<span class="regexp">/data portainer/</span>portainer</span><br></pre></td></tr></table></figure>

<h4 id="Swarm集群部署："><a href="#Swarm集群部署：" class="headerlink" title="Swarm集群部署："></a>Swarm集群部署：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ docker volume create portainer_data</span><br><span class="line">$ docker service create \</span><br><span class="line">--name portainer \</span><br><span class="line">--publish <span class="number">9000</span>:<span class="number">9000</span> \</span><br><span class="line">--replicas=<span class="number">1</span> \</span><br><span class="line">--constraint <span class="string">'node.role == manager'</span> \</span><br><span class="line">--mount type=bind,src=<span class="comment">//var/run/docker.sock,dst=/var/run/docker.sock \</span></span><br><span class="line">--mount type=volume,src=portainer_data,dst=<span class="regexp">/data \</span></span><br><span class="line"><span class="regexp">portainer/</span>portainer \</span><br><span class="line">-H unix:<span class="comment">///var/run/docker.sock</span></span><br></pre></td></tr></table></figure>


<h4 id="Docker-Compose-部署："><a href="#Docker-Compose-部署：" class="headerlink" title="Docker Compose 部署："></a>Docker Compose 部署：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">version: <span class="string">'2'</span></span><br><span class="line">services:</span><br><span class="line">  portainer:</span><br><span class="line">    image: portainer/portainer</span><br><span class="line">    command: -H unix:<span class="comment">///var/run/docker.sock</span></span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="regexp">/var/</span>run/docker.sock:<span class="regexp">/var/</span>run/docker.sock</span><br><span class="line">      - portainer_data:<span class="regexp">/data</span></span><br><span class="line"><span class="regexp">volumes:</span></span><br><span class="line"><span class="regexp">  portainer_data:</span></span><br></pre></td></tr></table></figure>


<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>访问 <a href="http://localhost:9000/" target="_blank" rel="noopener">http://localhost:9000/</a></p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g36cm04aidj31i20u0466.jpg" alt=""></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Next主题自动更换背景</title>
    <url>/year/10/06/next%E6%9B%B4%E6%8D%A2%E8%83%8C%E6%99%AF/</url>
    <content><![CDATA[<blockquote>
<p>如果觉得next的空白主题看腻了或者太多人用觉得不够个性化，那么不妨试试自动更新背景图片。</p>
</blockquote>
<a id="more"></a>

<h2 id="图片来源"><a href="#图片来源" class="headerlink" title="图片来源"></a>图片来源</h2><p>自动更换背景的实现是修改添加背景的css样式实现。图片来源是</p>
<p><a href="https://source.unsplash.com/" target="_blank" rel="noopener">https://source.unsplash.com/</a></p>
<p>这个网站，里面不仅免费提供了很多高清美图，而且还提供api接口调用，实在是良心。这里实现的原理也是调用了这个网站的接口。</p>
<h2 id="修改背景样式"><a href="#修改背景样式" class="headerlink" title="修改背景样式"></a>修改背景样式</h2><p>修改<code>themes\next\source\css\_custom\custom.styl</code>文件，这个是Next故意留给用户自己个性化定制一些样式的文件，添加以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line"></span><br><span class="line">    background:url(https:<span class="comment">//source.unsplash.com/random/1600x900);</span></span><br><span class="line"></span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line"></span><br><span class="line">    background-attachment:fixed;</span><br><span class="line"></span><br><span class="line">    background-position:<span class="number">50</span>% <span class="number">50</span>%;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果自己不喜欢这个网址提供的图片做背景，那么修改url()里面的路径即可。repeat、attachment、position就是调整图片的位置，不重复出现、不滚动等等。</p>
<h2 id="修改不透明度"><a href="#修改不透明度" class="headerlink" title="修改不透明度"></a>修改不透明度</h2><p>完成这一步其实背景就会自动更换了，但是会出现一个问题，因为next主题的背景是纯透明的，这样子就造成背景图片的影响看不见文字，这对于博客来说肯定不行。</p>
<p>那么就需要调整背景的不透明度了。同样是修改t<code>hemes\next\source\css _custom\custom.styl</code>文件。在后面添加如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.main-inner &#123; </span><br><span class="line"></span><br><span class="line">    margin-top: <span class="number">60</span>px;</span><br><span class="line"></span><br><span class="line">    padding: <span class="number">60</span>px <span class="number">60</span>px <span class="number">60</span>px <span class="number">60</span>px;</span><br><span class="line"></span><br><span class="line">    background: #fff;</span><br><span class="line"></span><br><span class="line">	opacity: <span class="number">0.8</span>;</span><br><span class="line"></span><br><span class="line">    min-height: <span class="number">500</span>px;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>* background: #fff; 白色
* opacity: 0.8;不透明度</code></pre><h2 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h2><p><img src="https://blog-1256335675.cos.ap-chengdu.myqcloud.com/2019-06-18-006tNbRwgy1fvxvc6azb4j31kw0vknpd.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>观影记——《潜行者》</title>
    <url>/year/07/11/qianxingzhe/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggmcyqyo9oj31ak0jckjl.jpg" alt="image-20200711004853480"></p>
<blockquote>
<p>潜行者：”对于我来说，哪儿都是监狱。“</p>
</blockquote>
<a id="more"></a>

<p>妻（痛苦的在地上翻滚）</p>
<h2 id="上帝-amp-三角形"><a href="#上帝-amp-三角形" class="headerlink" title="上帝&amp;三角形"></a>上帝&amp;三角形</h2><p>生活在中世纪会很有趣，每个家有家神，每个教堂有上帝，人们年轻强壮，而现在，四个人里面就有一个是老人，真是苦闷难耐啊。</p>
<p>什么法律、什么三角形… 也不会有家神，更没有上帝。毕竟上帝跟三角形也毫无差别，不过，我也不清楚。</p>
<p>寻求真理一定是枯燥无味的，它明明躲起来，你们就死要把它揪出来，你们在一个地方挖来挖去，然后兴奋地发现，原子是由质子组成的，你们这样又有了伟大的发现，三角形ABC等于同角A角B和角C对于我来说，那是另一码事。在我发掘真理的时候，真理的被发掘也在同时发生。</p>
<h2 id="内心最隐秘的愿望"><a href="#内心最隐秘的愿望" class="headerlink" title="内心最隐秘的愿望"></a>内心最隐秘的愿望</h2><p>“The Room”可以实现人们内心最隐秘的愿望。曾经有一位绰号“野猪”的潜行者进入了那个”The Room”,希望能让因他的过错而死的兄弟还魂。“野猪”回家后，发现自己变得极其富有。”The Room”实现了他内心最隐秘的愿望，而非他拼命自我暗示的那个。“野猪”最后上吊自杀了。</p>
<h2 id="我想要什么"><a href="#我想要什么" class="headerlink" title="我想要什么"></a>我想要什么</h2><p>我该从哪儿知道，我想要的东西是什么？我该从哪儿知道，其实我并不想q要自己想要的东西，还是说，我实际上不想要自己不想要的东西。他们都是捉摸不定的东西，当我说出他们的名字他们的内涵就像烈日下的水母开始模糊、融化乃至消失。</p>
<p>我的良知渴望素食主义赢得整个世界，而我的下意识却渴求一块抹上汁的肥肉。那我想要什么？</p>
<h2 id="欲望"><a href="#欲望" class="headerlink" title="欲望"></a>欲望</h2><p>但愿他们相信，让他们为自己的欲望投以一丝嘲笑。因为他们所谓的欲望，实际上不过是内在的动力，不过是灵魂和外界之间的摩擦。最重要的是让他们相信自己，让他们变得像小孩那样无助，因为软弱是伟大的，而意志力是毫无意义的。当一个人降生于世之时，他是何等的脆弱与柔和，当他行将就木之时，他又何等的僵硬与麻木。当一颗树茁壮成长，它是何等的葱郁与婀娜，但当它变得干枯与僵硬之时，便垂死挣扎。僵硬与挣扎是死亡的伴侣，婀娜与柔弱是鲜活生命的体现。要知道，生命的僵硬是不可抗力的。</p>
<p> 一个人也因为备受折磨、心存怀疑而投笔著书，他就得无时无刻想自己、向别人证明自己的价值，如果我坚信自己是个天才，那何必著书？究竟为了什么？总之，我的说… 我们生存是为了…</p>
<p>不管怎样，你们的工业科技、你们的高炉转轮，还有别的乱七八糟的东西，设计出来都是为了减轻负担，享受更多。这些全都是拐杖和义肢。人类之所以存在，是为了艺术创作。与其他人类活动不同，艺术创作是无私的，那是宏伟的幻想，真是的绝对写照。</p>
<h2 id="艺术的无私（我们生命的意义）"><a href="#艺术的无私（我们生命的意义）" class="headerlink" title="艺术的无私（我们生命的意义）"></a>艺术的无私（我们生命的意义）</h2><p>艺术的无私。就拿音乐来说，音乐和现实关联很少，即便有关联也不是思维上的而是力学上的关联。而空洞的声音，就与一切关联脱节。然而，音乐奇迹般的穿透我们的灵魂。是什么原因让我们与”噪音“达到和谐共鸣的呢？是什么原因让我们把它当做极乐的源泉，以至使自己震撼，使众人归一？这一切又何必，还是要说，谁需要这一切？你们会说”没人需要这一切，这毫无理由，也毫无私心。“</p>
<p>不，我不这么认为，毕竟，一切事物都有自己的意义，意义和存在的理由。</p>
<h2 id="蚕食"><a href="#蚕食" class="headerlink" title="蚕食"></a>蚕食</h2><p>根本就没有事实这回事，尤其是在这里，所有的这一切都是某人愚蠢的发明，难道你没有发觉？当然，你会想找出谁是始作俑者，为什么？你的知识又有什么用？有谁的良心会因此遭到谴责？我的良心？我并没有良心，我只有神经病，有些混蛋骂了我，我收到了伤害，另外一些混蛋又来赞颂我，我又受到了伤害。我把内心与灵魂贡献出来，他们却将其蚕食一空。我本想消除灵魂中的龌龊，然而他们又将其蚕食一空。他们都是有文化的人，他们都是饿鬼，他们的周围总是围着一大群记者、编辑、评论家，还有一些洛泽不绝的女人，他们都渴求，来啊、来啊！</p>
<p>如果我讨厌写作，如果写作对我来说是无尽的折磨，痛苦而耻辱的职业，呼之欲出的毒疮，那我算是个什么作家啊！我曾经以为自己的书可以使人们变得更好，不，没人需要我，当我死去，两天后，他们又会蚕食其他的人。我本想去改变他们，结果他们改造了我。按照他们自己的模式来改造。过去会认为，未来只是现在的一个延续，带着变幻在地平线上隐约闪烁，而现在呢？未来和现在已经融为一体。难道他们早有预谋？他们什么都不知道，他们就知道蚕食。</p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title>《小王子的领悟》 -- 商品逻辑 摘抄</title>
    <url>/year/06/04/splj-xwzdlw/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g3p9l8arvzj31ci0gonpd.jpg" alt=""></p>
<a id="more"></a>

<p>活在今天的社会，我们每个人都不难具体而微地感受到，社会越来越多领域正在慢慢被商品逻辑入侵，并令这些领域本来的意义变质，进而改变我们的情感、价值和伦理关系。 </p>
<p>如果我们无法阻止生活世界被商品逻辑垄断，无法确保不同领域享有相对独立自主的意义，那么活在其中的个体，即使内心清楚某些活动的价值，他的选择也将非常有限，因为赋予这些活动意义的社会基础已被掏空。 </p>
<p>举例说，即使你愿意用心去爱，但当社会根本不承认爱的意义，或干脆视爱为一种商品时，你的爱也将无处着落。在那一刻，你或会意识到，商品社会看似多元，背后却往往有着异常单一的“金钱霸权”。</p>
<p>这里所谓的霸权，不是说别人有钱而你没钱，而是即使你有钱，你也很难再找到那些曾经存在的、未被商品化的生活方式，及其所承载的价值和情感。 </p>
<p>如果你不愿屈服，你就必须在人群中承受异乡人一样的孤独。 孤独，是因为你所追求的价值以及你想过的生活，不能在市场中转化成“有价”之物，于是不得不在生活世界渐渐式微以至消失。你遂心无所寄。 </p>
<p>由此可见，钱能够买什么、不能够买什么，不仅仅是个人选择的问题，更是结构性的制度问题。 </p>
<p>商品化并非某个领域的个别现象，而是资本主义高度发展的必然结果。资本不断累积并寻求利润极大化的逻辑，是商品化的最大动力。这股力量会一步一步改变我们的社会关系，影响我们看世界看自我的方式，并因此改变我们的生活。</p>
<p>最明显的例子，是我们如何看待自己的身体。 在商品化社会，我们不仅早已习惯人的劳动力乃完全可出卖之物，也接受男女性爱可以是一种交易，甚至器官转让和代孕产子，也渐渐成为有庞大市场需求的生意。在这种身体商品化急剧转变的过程中，我们失去什么以及需要为此付上多大代价，值得我们认真对待。 </p>
<p>出路在哪里？就算有，我们是否愿意放弃商品化过程带来的自由、效率和各种各样的利益？ </p>
<p>作为个体，面对无坚不摧的金钱逻辑对不同生活领域的“殖民”，我们又是否有勇气在日常中挺直腰板，向金钱至上的体制说不，并捍卫生而为人的尊严？</p>
<p>周保松. 小王子的领悟 (Kindle 位置 975-981). 上海三联书店. Kindle 版本. </p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac OS 下 Sublime Text 3 运行Java</title>
    <url>/year/01/12/sublime-text-%E8%BF%90%E8%A1%8C-java/</url>
    <content><![CDATA[<p>.</p>
<a id="more"></a>

<h4 id="在Sublime中安装Package-Resource-Viewer，具体操作步骤如下："><a href="#在Sublime中安装Package-Resource-Viewer，具体操作步骤如下：" class="headerlink" title="在Sublime中安装Package Resource Viewer，具体操作步骤如下："></a>在Sublime中安装Package Resource Viewer，具体操作步骤如下：</h4><pre><code>* ctrl+shift+p打开package control； 
* 输入Install Package； 
* 搜索Package Resource Viewer并安装。</code></pre><h4 id="修改Javac-sublime-build："><a href="#修改Javac-sublime-build：" class="headerlink" title="修改Javac.sublime-build："></a>修改Javac.sublime-build：</h4><pre><code>安装Package Resource Viewer就是为这一步服务。同上面的步骤，打开package control，输入PackageResourceViewer:Open Resource，回车后输入java，回车后输入Javac.sublime-build,就能够打开我们所需要修改的文件：Google 了下，找到了两种配置文件。</code></pre><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">"shell_cmd": "javac -encoding utf-8 $file_name &amp;&amp; java $file_base_name",</span><br><span class="line"></span><br><span class="line">"file_regex": "^ *\\[javac\\] (.+):([0-9]+):() (.*)$",</span><br><span class="line"></span><br><span class="line">"selector": "source.java",</span><br><span class="line"></span><br><span class="line">"encoding": "utf-8"</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">"cmd": ["javac \"$file_name\" &amp;&amp; java \"$file_base_name\""],</span><br><span class="line"></span><br><span class="line">"working_dir": "$&#123;project_path:$&#123;folder&#125;&#125;",</span><br><span class="line"></span><br><span class="line">"file_regex": "^(...*?):([0-9]*):?([0-9]*)",</span><br><span class="line"></span><br><span class="line">"selector": "source.java",</span><br><span class="line"></span><br><span class="line">"shell": true,</span><br><span class="line"></span><br><span class="line">"encoding": "utf-8"</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="选择Build-System，选择上一步保存的配置文件"><a href="#选择Build-System，选择上一步保存的配置文件" class="headerlink" title="选择Build System，选择上一步保存的配置文件"></a>选择Build System，选择上一步保存的配置文件</h4><p><img src="https://blog-1256335675.cos.ap-chengdu.myqcloud.com/2019-06-18-su.jpg" alt=""></p>
<h4 id="Command-B编译运行"><a href="#Command-B编译运行" class="headerlink" title="Command+B编译运行"></a>Command+B编译运行</h4><pre><code>运行的时候会在桌面上生成一个　.class文件，可以通过配置文件将生成的.class文件删除。</code></pre><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">"shell_cmd": "javac -encoding utf-8 $file_name &amp;&amp; java $file_base_name &amp;&amp; rm -rf $file_base_name.class"</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS 如何像 Windows 一样使用鼠标</title>
    <url>/year/06/02/shubiao/</url>
    <content><![CDATA[<p>虽然 mac 本身的触摸板很好用，但有时候还是忍不住用鼠标，或者你外接显示器的时候。推荐两款软件，让鼠标在 mac 下和 win 一样顺滑。</p>
<a id="more"></a>

<h2 id="SteerMouse"><a href="#SteerMouse" class="headerlink" title="SteerMouse"></a>SteerMouse</h2><p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g3ji2oedahj311c0u07ka.jpg" alt=""></p>
<blockquote>
<p>SteerMouse可以分配不同的功能按钮，包括双点击点击，改性剂，应用切换，快捷键的分配，“对齐”，光标移动，光标移动的目标（如OK按钮），和更多。<br>SteerMouse可以让你控制光标的灵敏度上的跟踪速度。（苹果的软件只允许跟踪速度。调整）调整配置，您可以自定义光标到适合你的手的运动的理想环境。</p>
</blockquote>
<p>官网地址： <a href="http://plentycom.jp/en/steermouse/" target="_blank" rel="noopener">http://plentycom.jp/en/steermouse/</a><br>破解版地址：<a href="https://xclient.info/s/steermouse.html" target="_blank" rel="noopener">https://xclient.info/s/steermouse.html</a></p>
<h2 id="SmoothScroll"><a href="#SmoothScroll" class="headerlink" title="SmoothScroll"></a>SmoothScroll</h2><p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g3ji5q6mlrj30ww0i0afv.jpg" alt=""></p>
<p>鼠标滚轮一格一格的滚动效果总是没有触摸板来的顺滑，Smooth Scroll 可以让平滑滚动应用到系统的每个角落，让鼠标滚轮用起来也有触摸板的感觉。</p>
<p>官网地址：<a href="https://www.smoothscroll.net/mac/" target="_blank" rel="noopener">https://www.smoothscroll.net/mac/</a></p>
<p>破解版地址： <a href="https://xclient.info/s/smoothscroll.html" target="_blank" rel="noopener">https://xclient.info/s/smoothscroll.html</a></p>
<p>参考： <a href="https://sspai.com/post/32832" target="_blank" rel="noopener">8 款 App 全面提升你的 Mac 鼠标体验</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS 轻松愉快的解压 rar 压缩包</title>
    <url>/year/06/28/unrar/</url>
    <content><![CDATA[<p>macOS 自带的压缩软件不支持 rar 格式的文件解压缩，于是需要找一个第三方压缩软件。Keka 一个不错的软件，但是它默认的压缩文件图标也太丑了吧。而且我对解压缩并那么多的需求，在用了一段时间之后发现了 unrar 就果断放弃了。</p>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用 homebrew 安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install unrar</span><br></pre></td></tr></table></figure>

<h2 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unrar 参数 压缩文件名 路径</span><br></pre></td></tr></table></figure>

<p>解压参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e             解压压缩文件到当前目录</span><br><span class="line">x             用绝对路径解压文件</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>《when》</title>
    <url>/year/12/18/when/</url>
    <content><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=17657650&auto=1&height=66"></iframe>


<p>当我在梦里游荡<br>我爱你</p>
<a id="more"></a>
<p>当我醒来 世界面目全非<br>我爱你<br>当最后一个夜晚快要崩塌<br>我爱你<br>当所有真相浮出水面<br>当所有繁花凋落<br>我爱你<br>当你的吻将被我卒逼到没有退路<br>我爱你<br>当你睡着 像个孩子一样<br>我爱你<br>当此恶世要把我们消磨殆尽<br>当再见时你不再吻我<br>我爱你<br>当我欲哭又无泪<br>当春风又绿了柳丝<br>当那个遥远 冰冷 隔绝的星球着起了火<br>雨不停地落 窗户把它们围拥<br>像一双双眼睛<br>永远都在寻觅 却寻不到落在远方的孤苦灵魂<br>当我们的名字被并排写在一起<br>我爱你<br>当我想起我们的初吻<br>当你变得冷漠 不可捉摸<br>我爱你<br>当我张开嘴 却无语<br>当雨滴从天空滴落<br>我爱你<br>当干涸的河床干裂<br>我爱你<br>虽然你没有拥我入怀<br>在那个无休止的狂野海浪不停拍打的海边<br>雨不停地落 窗户把它们围拥<br>像一双双眼睛<br>永远都在寻觅 却寻不到落在远方流浪着的孤苦灵魂<br>当你我相隔两端<br>我爱你<br>当我们彻底和疯狂的世界隔绝<br>我爱你<br>虽然最终这场持久的战斗还是会输<br>我爱你<br>当幕布落下 观众离开<br>当我的灵魂离开这个躯壳<br>你会挺大 我在雨里对你呼唤</p>
<p><img src="http://ovlnt0xy1.bkt.clouddn.com/2017-12-18-15135777800931.jpg" alt=""></p>
]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>music</tag>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>Tmux 配置：打造最适合自己的终端复用工具</title>
    <url>/year/06/20/tmux-conf/</url>
    <content><![CDATA[<p><img src="https://blog-1256335675.cos.ap-chengdu.myqcloud.com/2019-06-20-161234.png" alt="image-20190621001230589"></p>
<p>如果说有什么工具可以用<strong>相见恨晚</strong> 来形容的话，Tmux 算一个。</p>
<p>Tmuxs 是一款优秀的终端复用工具，使用它最直观的好处就是，通过一个终端登录远程主机并运行tmux后，在其中可以开启多个控制台而无需再“浪费”多余的终端来连接这台远程主机；</p>
<a id="more"></a>

<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>提供了强劲的、易于使用的命令行界面。</li>
<li>可横向和纵向分割窗口。</li>
<li>窗格可以自由移动和调整大小，或直接利用四个预设布局之一。</li>
<li>支持 UTF-8 编码及 256 色终端。</li>
<li>可在多个缓冲区进行复制和粘贴。</li>
<li>可通过交互式菜单来选择窗口、会话及客户端。</li>
<li>支持跨窗口搜索。</li>
<li>支持自动及手动锁定窗口。</li>
<li>可以自由配置绑定快捷键。</li>
</ul>
<h2 id="Tmux-重要概念"><a href="#Tmux-重要概念" class="headerlink" title="Tmux 重要概念"></a>Tmux 重要概念</h2><p>使用 Tmux 的时候千万不要去背指令，所有的指令都可以在 <code>.tmux.conf</code> 配置文件中绑定自己顺手的快捷键，也可以配置开启鼠标。</p>
<p>这个是我的配置文件：<a href="https://github.com/zuorn/tmux.conf" target="_blank" rel="noopener">https://github.com/zuorn/tmux.conf</a> </p>
<p>在Tmux逻辑中，需要分清楚Server &gt; Session &gt; Window &gt; Pane这个大小和层级顺序是极其重要的，直接关系到工作效率：</p>
<ul>
<li>Server：是整个tmux的后台服务。有时候更改配置不生效，就要使用tmux kill-server来重启tmux。</li>
<li>Session：是tmux的所有会话。我之前就错把这个session当成窗口用，造成了很多不便里。一般只要保存一个session就足够了。</li>
<li>Window：相当于一个工作区，包含很多分屏，可以针对每种任务分一个Window。如下载一个Window，编程一个window。</li>
<li>Pane：是在Window里面的小分屏。最常用也最好用</li>
</ul>
<p>了解了这个逻辑后，整个Tmux的使用和配置也就清晰了。<br>（ps：下面这种方便好看的Status bar状态栏，显示的是windows，而不是sessions）<br><img src="media/15604367235575/15610200944082.jpg" alt="-w318"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在 Mac OS 中，通过 brew 安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install tmux</span><br></pre></td></tr></table></figure>
<p>ubuntu版本下直接apt-get安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get install tmux</span><br></pre></td></tr></table></figure>
<p>centos7版本下直接yum安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y tmux</span><br><span class="line"></span><br><span class="line">​```sh</span><br><span class="line">centos6版本需要编译安装</span><br><span class="line"></span><br><span class="line">​```sh</span><br><span class="line">yum install libevent libevent-devel ncurses-devel</span><br><span class="line">tar -zvxf tmux-2.3.tar.gz <span class="comment"># (提前下载：wget https://github.com/tmux/tmux/releases/download/2.3/tmux-2.3.tar.gz)</span></span><br><span class="line"><span class="built_in">cd</span> tmux-2.3</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h2 id="Tmux-常用命令"><a href="#Tmux-常用命令" class="headerlink" title="Tmux 常用命令"></a>Tmux 常用命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#启动新session：</span><br><span class="line">$ tmux [new -s 会话名 -n 窗口名]</span><br><span class="line"></span><br><span class="line">#恢复session：</span><br><span class="line">$ tmux at [-t 会话名]</span><br><span class="line"></span><br><span class="line">#列出所有sessions：</span><br><span class="line">$ tmux ls</span><br><span class="line"></span><br><span class="line">#关闭session：</span><br><span class="line">$ tmux kill-session -t 会话名</span><br><span class="line"></span><br><span class="line">#关闭整个tmux服务器：</span><br><span class="line">$ tmux kill-server</span><br></pre></td></tr></table></figure>

<h2 id="Tmux-常用内部命令"><a href="#Tmux-常用内部命令" class="headerlink" title="Tmux 常用内部命令"></a>Tmux 常用内部命令</h2><blockquote>
<p>所谓内部命令，就是进入Tmux后，并按下前缀键后的命令，一般前缀键为Ctrl+b. 虽然ctrl和b离得很远但是不建议改前缀键，因为别的键也不见得方便好记不冲突。还是记忆默认的比较可靠。</p>
</blockquote>
<h3 id="系统指令："><a href="#系统指令：" class="headerlink" title="系统指令："></a>系统指令：</h3><table>
<thead>
<tr>
<th>前缀</th>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+b</td>
<td>?</td>
<td>显示快捷键帮助文档</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>d</td>
<td>断开当前会话</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>D</td>
<td>选择要断开的会话</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>Ctrl+z</td>
<td>挂起当前会话</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>r</td>
<td>强制重载当前会话</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>s</td>
<td>显示会话列表用于选择并切换</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>:</td>
<td>进入命令行模式，此时可直接输入ls等命令</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>[</td>
<td>进入复制模式，按q退出</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>]</td>
<td>粘贴复制模式中复制的文本</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>~</td>
<td>列出提示信息缓存</td>
</tr>
</tbody></table>
<h3 id="窗口（window）指令："><a href="#窗口（window）指令：" class="headerlink" title="窗口（window）指令："></a>窗口（window）指令：</h3><table>
<thead>
<tr>
<th>前缀</th>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+b</td>
<td>c</td>
<td>新建窗口</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>&amp;</td>
<td>关闭当前窗口</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>0~9</td>
<td>切换到指定窗口</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>p</td>
<td>切换到上一窗口</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>n</td>
<td>切换到下一窗口</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>w</td>
<td>打开窗口列表，用于且切换窗口</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>,</td>
<td>重命名当前窗口</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>.</td>
<td>修改当前窗口编号（适用于窗口重新排序）</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>f</td>
<td>快速定位到窗口（输入关键字匹配窗口名称）</td>
</tr>
</tbody></table>
<h3 id="面板（pane）指令："><a href="#面板（pane）指令：" class="headerlink" title="面板（pane）指令："></a>面板（pane）指令：</h3><table>
<thead>
<tr>
<th>前缀</th>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+b</td>
<td>“</td>
<td>当前面板上下一分为二，下侧新建面板</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>%</td>
<td>当前面板左右一分为二，右侧新建面板</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>x</td>
<td>关闭当前面板（关闭前需输入y or n确认）</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>z</td>
<td>最大化当前面板，再重复一次按键后恢复正常（v1.8版本新增）</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>!</td>
<td>将当前面板移动到新的窗口打开（原窗口中存在两个及以上面板有效）</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>;</td>
<td>切换到最后一次使用的面板</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>q</td>
<td>显示面板编号，在编号消失前输入对应的数字可切换到相应的面板</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>{</td>
<td>向前置换当前面板</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>}</td>
<td>向后置换当前面板</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>Ctrl+o</td>
<td>顺时针旋转当前窗口中的所有面板</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>方向键</td>
<td>移动光标切换面板</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>o</td>
<td>选择下一面板</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>空格键</td>
<td>在自带的面板布局中循环切换</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>Alt+方向键</td>
<td>以5个单元格为单位调整当前面板边缘</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>Ctrl+方向键</td>
<td>以1个单元格为单位调整当前面板边缘（Mac下</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>t</td>
<td>显示时钟</td>
</tr>
</tbody></table>
<h1 id="我的配置文件"><a href="#我的配置文件" class="headerlink" title="我的配置文件"></a>我的配置文件</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone git@github.com:zuorn&#x2F;tmux-config.git</span><br><span class="line">$ cp tmux-config&#x2F;.tmux.conf ~&#x2F;.tmux.conf</span><br></pre></td></tr></table></figure>
<p>重启 tmux <code>restart tmux</code> 或者 在 tmux 窗口中，先按下 <code>Ctrl+b</code> 指令前缀，然后按下系统指令:，进入到命令模式后输入 <code>source-file ~/.tmux.conf</code>，回车后生效。</p>
<h2 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h2><h3 id="修改指令前缀"><a href="#修改指令前缀" class="headerlink" title="修改指令前缀"></a>修改指令前缀</h3><p>可根据自己的喜好来设置，如若要启用，取消注释即可。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#set -g prefix C-f #</span></span><br><span class="line"><span class="comment">#unbind C-f # C-b 即 Ctrl+b 键，unbind 意味着解除绑定</span></span><br><span class="line"><span class="comment">#bind C-f send-prefix # 绑定 Ctrl+f 为新的指令前缀</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从tmux v1.6版起，支持设置第二个指令前缀</span></span><br><span class="line"><span class="comment">#set-option -g prefix2 ` # 设置一个不常用的`键作为指令前缀，按键更快些</span></span><br></pre></td></tr></table></figure>
<h3 id="添加加载配置文件快捷指令-r"><a href="#添加加载配置文件快捷指令-r" class="headerlink" title="添加加载配置文件快捷指令 r"></a>添加加载配置文件快捷指令 r</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bind</span> r <span class="built_in">source</span>-file ~/.tmux.conf \; display-message <span class="string">"Config reloaded.."</span></span><br></pre></td></tr></table></figure>

<h3 id="支持鼠标"><a href="#支持鼠标" class="headerlink" title="支持鼠标"></a>支持鼠标</h3><ul>
<li>选取文本</li>
<li>调整面板大小</li>
<li>选中并切换面板</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 老版本：</span></span><br><span class="line"><span class="comment">#setw -g mode-mouse on # 支持鼠标选取文本等</span></span><br><span class="line"><span class="comment">#setw -g mouse-resize-pane on # 支持鼠标拖动调整面板的大小(通过拖动面板间的分割线)</span></span><br><span class="line"><span class="comment">#setw -g mouse-select-pane on # 支持鼠标选中并切换面板</span></span><br><span class="line"><span class="comment">#setw -g mouse-select-window on # 支持鼠标选中并切换窗口(通过点击状态栏窗口名称)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># v2.1及以上的版本</span></span><br><span class="line"><span class="built_in">set</span>-option -g mouse on</span><br></pre></td></tr></table></figure>
<h3 id="面板"><a href="#面板" class="headerlink" title="面板"></a>面板</h3><h4 id="更改新增面板键"><a href="#更改新增面板键" class="headerlink" title="更改新增面板键"></a>更改新增面板键</h4><ul>
<li><ul>
<li>垂直新增面板</li>
</ul>
</li>
<li><ul>
<li>水平新增面板</li>
</ul>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">unbind <span class="string">'"'</span></span><br><span class="line"><span class="built_in">bind</span> - splitw -v -c <span class="string">'#&#123;pane_current_path&#125;'</span> <span class="comment"># 垂直方向新增面板，默认进入当前目录</span></span><br><span class="line">unbind %</span><br><span class="line"><span class="built_in">bind</span> =  splitw -h -c <span class="string">'#&#123;pane_current_path&#125;'</span> <span class="comment"># 水平方向新增面板，默认进入当前目录</span></span><br></pre></td></tr></table></figure>

<h4 id="面板调整大小"><a href="#面板调整大小" class="headerlink" title="面板调整大小"></a>面板调整大小</h4><p>绑定Ctrl+hjkl键为面板上下左右调整边缘的快捷指令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bind</span> -r ^k resizep -U 10 <span class="comment"># 绑定Ctrl+k为往↑调整面板边缘10个单元格</span></span><br><span class="line"><span class="built_in">bind</span> -r ^j resizep -D 10 <span class="comment"># 绑定Ctrl+j为往↓调整面板边缘10个单元格</span></span><br><span class="line"><span class="built_in">bind</span> -r ^h resizep -L 10 <span class="comment"># 绑定Ctrl+h为往←调整面板边缘10个单元格</span></span><br><span class="line"><span class="built_in">bind</span> -r ^l resizep -R 10 <span class="comment"># 绑定Ctrl+l为往→调整面板边缘10个单元格</span></span><br></pre></td></tr></table></figure>

<h3 id="复制模式"><a href="#复制模式" class="headerlink" title="复制模式"></a>复制模式</h3><h4 id="复制模式更改为-vi-风格"><a href="#复制模式更改为-vi-风格" class="headerlink" title="复制模式更改为 vi 风格"></a>复制模式更改为 vi 风格</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">setw -g mode-keys vi <span class="comment"># 开启vi风格后，支持vi的C-d、C-u、hjkl等快捷键</span></span><br></pre></td></tr></table></figure>

<h4 id="复制模式向-vi-靠拢"><a href="#复制模式向-vi-靠拢" class="headerlink" title="复制模式向 vi 靠拢"></a>复制模式向 vi 靠拢</h4><ul>
<li>v 开始选择文本</li>
<li>y 复制选中文本</li>
<li>p 粘贴文本</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bind</span> -t vi-copy v begin-selection <span class="comment"># 绑定v键为开始选择文本</span></span><br><span class="line"><span class="built_in">bind</span> -t vi-copy y copy-selection <span class="comment"># 绑定y键为复制选中文本</span></span><br><span class="line"><span class="built_in">bind</span> p pasteb <span class="comment"># 绑定p键为粘贴文本（p键默认用于进入上一个窗口，不建议覆盖）</span></span><br></pre></td></tr></table></figure>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="设置窗口面板起始序号"><a href="#设置窗口面板起始序号" class="headerlink" title="设置窗口面板起始序号"></a>设置窗口面板起始序号</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -g base-index 1 <span class="comment"># 设置窗口的起始下标为1</span></span><br><span class="line"><span class="built_in">set</span> -g pane-base-index 1 <span class="comment"># 设置面板的起始下标为1</span></span><br></pre></td></tr></table></figure>
<h4 id="自定义状态栏"><a href="#自定义状态栏" class="headerlink" title="自定义状态栏"></a>自定义状态栏</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -g status-utf8 on <span class="comment"># 状态栏支持utf8</span></span><br><span class="line"><span class="built_in">set</span> -g status-interval 1 <span class="comment"># 状态栏刷新时间</span></span><br><span class="line"><span class="built_in">set</span> -g status-justify left <span class="comment"># 状态栏列表左对齐</span></span><br><span class="line">setw -g monitor-activity on <span class="comment"># 非当前窗口有内容更新时在状态栏通知</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -wg window-status-format <span class="string">" #I #W "</span> <span class="comment"># 状态栏窗口名称格式</span></span><br><span class="line"><span class="built_in">set</span> -wg window-status-current-format <span class="string">" #I:#W#F "</span> <span class="comment"># 状态栏当前窗口名称格式(#I：序号，#w：窗口名称，#F：间隔符)</span></span><br><span class="line"><span class="built_in">set</span> -wg window-status-separator <span class="string">""</span> <span class="comment"># 状态栏窗口名称之间的间隔</span></span><br></pre></td></tr></table></figure>

<h2 id="Tmux-常见问题"><a href="#Tmux-常见问题" class="headerlink" title="Tmux 常见问题"></a>Tmux 常见问题</h2><h3 id="Tmux不管怎么改配置文件，都不产生变化"><a href="#Tmux不管怎么改配置文件，都不产生变化" class="headerlink" title="Tmux不管怎么改配置文件，都不产生变化"></a>Tmux不管怎么改配置文件，都不产生变化</h3><p>这个主要是由于Tmux的后台缓存机制造成的。我就犯了个大错误：甚至删了Tmux、重装Tmux、重启电脑，都没达成。<br>Tmux会有一个叫Tmux-server的东西。只要把它kill，重启tmux就OK了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tmux kill-server -a</span><br></pre></td></tr></table></figure>


<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="http://man.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man1/tmux.1?query=tmux%26sec=1" target="_blank" rel="noopener">官方文档</a></li>
<li><a href="https://www.cnblogs.com/congbo/archive/2012/08/30/2649420.html" target="_blank" rel="noopener">https://www.cnblogs.com/congbo/archive/2012/08/30/2649420.html</a></li>
<li><a href="http://louiszhai.github.io/2017/09/30/tmux/" target="_blank" rel="noopener">Tmux 使用手册</a></li>
<li><a href="https://segmentfault.com/a/1190000018032072" target="_blank" rel="noopener">Tmux的超绝便利 （基础篇）</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次误删系统文件</title>
    <url>/year/05/20/wushan/</url>
    <content><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g37stwytfcj313803y3zc.jpg" alt=""></p>
<p>不小心删除了<code>/System/Library/Frameworks/Python.framework/Versions/2.7/</code>的内容，之后每次使用<code>cd</code>命令都会提示.</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd</span><br><span class="line">python: posix_spawn: &#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;2.7&#x2F;Resources&#x2F;Python.app&#x2F;Contents&#x2F;MacOS&#x2F;Python: No such file or directoryr</span><br></pre></td></tr></table></figure>

<p>google了一下，找到一个文件包，下载下来拷贝进去就OK了！</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g37sqovyk8j31ac0ken2i.jpg" alt=""></p>
<p>地址：<a href="https://stackoverflow.com/questions/10212270/python-asks-for-older-paths-on-mac-after-deleting-duplicate-python-installation" target="_blank" rel="noopener">https://stackoverflow.com/questions/10212270/python-asks-for-older-paths-on-mac-after-deleting-duplicate-python-installation</a></p>
<p>stackoverflow可能下载会比较慢，我在百度网盘也备份了一份，留给像我这样的手残党😂</p>
<p>链接:<a href="https://pan.baidu.com/s/1rgXQ5k4mxwVWZIfzUZC5uQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1rgXQ5k4mxwVWZIfzUZC5uQ</a>  密码:rf5n</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>《斯通纳》摘抄集</title>
    <url>/year/09/15/%E3%80%8A%E6%96%AF%E9%80%9A%E7%BA%B3%E3%80%8B%E6%91%98%E6%8A%84%E9%9B%86/</url>
    <content><![CDATA[<p><strong>唯有孤独恒常如新</strong></p>
<blockquote>
<p>你也在弱者之列——你是个梦想家，一个更疯狂世界的疯子，我们中西部本土的堂吉诃德，但没有自己的桑乔，在蓝天下欢跳。你足够聪明——只是比我们共同的朋友聪明一点。但是你有这个瑕疵，那个顽疾。你觉得这里有某种东西，有某种东西值得去寻找。其实，在这个世界上，你很快就会明白。你同样因为失败而与世隔绝；你不会跟这个世界拼搏。你会任由这个世界吃掉你，再把你吐出来，你还躺在这里纳闷，到底做错了什么。因为你总是对这个世界有所期待，而它没有那个东西，它也不希望如此。棉花里的象虫，豆荚里的蠕虫，玉米里的穿孔虫。你无法面对它们，你又不会与它们搏斗；因为你太弱了，你又太固执了。你在这个世界没有安身之地。</p>
</blockquote>
<a id="more"></a>

<br>
> 有时，他对学生讲话时，仿佛是站在自我之外，观察着一个陌生人在给一群并不情愿地聚集在一块儿的人发表讲话；他听着自己平板的声音在背诵着准备过的材料，从背诵中体会不到丝毫属于自己的兴奋。

<br>
>我太聪明了，我总是无法闭上嘴不去评论这个世界，这是一种疾病，无药可治。所以我只好被封存起来，在那里我能够不负责任又很安全，我可以不伤害任何东西。”

<br>
> 以最后的沉默的姿态来表达对这个深深地背叛了他的世界的爱与蔑视，他简直难以忍受在这个世界中生活。

<br>
> 女儿感染了他的情绪，他说的几句话逗得孩子哈哈大笑。接着两个人一起毫无意义地笑起来，好像都成了小孩子。忽然，书房的门打开了，从起居室里照过来的强光像溪水般流进书房每个暗淡的角落。伊迪丝的身影出现在那片光中。 “格蕾斯，”她吐词清晰又缓慢地说，“父亲要工作了。你别打搅。” 斯通纳和女儿刹那间对这种突如其来的撞入吃惊不已，两个人既不动弹也不说话。接着斯通纳又应付着说：“没事儿，伊迪丝，她不影响我。” 他好像无话可讲了，伊迪丝说：“格蕾斯，听见我说的了吗？赶快出来。” 格蕾斯满脸困惑，从椅子上下来，穿过书房。走到正中间时，她站住不动了，先是看看父亲，又看看母亲。伊迪丝又发话了，但斯通纳设法打断她。 “没关系，格蕾斯，”他尽量温柔地说，“没关系。到你妈妈那儿去吧。” 格蕾斯穿过书房门，走进起居室时，伊迪丝对丈夫说，“这孩子太放任自流了。这样沉默寡言、怕羞内向对她来说太不自然了。她一个人待的时间太久了。她应该更活泼些，多跟同龄的孩子玩。你难道没有看出她多不开心吗？” 不等斯通纳回答，她就关上了门。 斯通纳好长时间都没有动一下。他盯着书桌，上面摆满了笔记和打开的书。他慢慢穿过书房，漫无目标地重新规整了下那些纸张和书籍。他站在那里，皱着眉头，站了好几分钟，好像在努力回想什么。接着他又转过身，走到格蕾斯的小桌前，他在桌前站了片刻，就像站在自己桌前那样。他关了桌上的灯，于是桌面变成一片灰色，没有了生命，接着他走过去来到沙发前，躺在沙发上，睁着眼睛盯着天花板。 他的心头渐渐升起某种憎恶感，所以，又过了好几个星期他才肯在心里承认伊迪丝干的事；当他最终确认了那种承认时，自己几乎毫不惊讶。伊迪丝是施展这种聪明和技巧进行竞争的高手，他还找不出合理的证据抱怨。那天晚上，她突然而且几乎是残忍地撞进书房后，回想起来这种撞入貌似一场意外的袭击，此后，伊迪丝的策略变得更加曲折，更加悄无声息和克制。这种策略把自己伪装成爱和关心，所以，他根本无可反击。

<br>
> 她的目光越来越戒备，几乎是警惕了，曾经那么文静的表情，现在有时隐隐约约透露出郁郁寡欢，另一方面又开心和活跃得快要滑向歇斯底里的边缘。她已经很少微笑了，虽然经常放声大笑。她微笑的时候，好像一个幽灵从脸上飘然掠过。

<br>
>“我心里始终不肯承认这点，”他有些镇定地说，“但你其实挺讨厌我，是吗，伊迪丝？” “什么？”她话音中透出的惊奇是真的。“噢，威利！”她清晰地放声大笑，而且抑制不住。“别犯傻了。当然不讨厌。你是我丈夫。” “不要利用孩子，”他抑制不住声音的颤抖，“你再也没有什么可利用的了，你知道这点。其他任何东西。可是，如果你继续利用格蕾斯，我就要——”他没有把话说完就打住了。过了会儿，伊迪丝说，“你想要什么？”她平静地说，没有任何挑战意味。“你能做的无非是离开我，而你永远不会这样做。我们都知道这点。” 他点点头。“我想你是对的。”他什么也不看地站起来走进书房。他从壁柜里取出外套，从旁边的桌子上拿起公文包。当他穿过起居室时，伊迪丝又跟他说话了。 “威利，我并不想伤害格蕾斯。你应该知道这个的。我爱她。她是我亲生的女儿。” 他知道这话是真心的，她是爱着孩子。这种真切的顿悟几乎让他要哭出来。他摇摇头，走了出去，踏进外面的恶劣天气中。

<br>
> 最后，他意识到，那已经成为一个避难所，一个港湾，一个晚上去办公室的借口。他阅读、研究，终于从中找到了点儿安慰，找到了点儿乐趣，甚至那个古老的愉悦的幽灵，也在他做的其中，这是一种没有具体目标的学问探求。

<br>
>带着某种欢快的恶意.

<br>
>当一个人发觉近在手边的主题其实就在一个更宏观的主题的中心里，而且当一个人强烈地感觉到对这个主题的探寻很可能引向——什么地方，人们还并不知道时，都会有种恍然若悟的感觉。

<br>
>“当我们面对文学中的谜题，面对它难以描述的魅力时，我们有责任去揭示这种力量和谜题的根源。但是，说到底，有什么用呢？文学作品在我们面前抛出一张深沉的面纱，我们无法测度。在它面前，我们只有崇拜，在它的摇晃中无可奈何。谁会有那种愚勇揭起那块面纱，去揭开那原本无法揭开的东西，去抵达不可抵达的境界？在那个永恒的神秘面前，我们中最强有力的人都不过是最微不足道的低能儿，都不过是叮作响的钹子和声音浑厚的铜管。”

<br>
>他感觉自己向外被拉着走向那片白色，那片白色延伸到他目力所及的远方，而且它也是黑暗的一部分，在黑暗中闪耀着，同时也是清澈无云、没有高度或者深度的天空的一部分。他一时感觉自己的灵魂逃出在窗前坐着不动的身体。当他感觉自我溜出去后，一切——平坦的白色，树木，高高的圆柱，夜晚，遥远的星辰——似乎都渺小和遥远得不可思议，好像这一切都逐渐缩小到变成某种虚无。这时，他身后的一个散热器哐啷响了一下。他动了动，这幅景象恢复了原貌。他怀着不情愿得有些奇怪的轻松感，再次拧亮台灯。他收拾好一本书和几页纸，走出办公室，穿过更显黑暗的走廊，有意走出杰西楼后面宽敞的双排门。他慢慢步行回家，发觉每走一步都带着沉闷的声响，在干硬的雪地上咔嚓咔嚓地踩过去。

<br>
>那年，特别是冬天的几个月，斯通纳发觉自己越来越频繁地重温这种虚幻不真实的状态。他好像可以随心所欲地把自己的意识从盛放它的躯体里移出来，他观察自己时，就像一个熟悉得有些古怪的陌生人在做着熟悉得有些古怪的事情，自己不得不做。这是一种他以前从未体验过的分裂。他知道，自己应该遭受其困扰，但他已经麻木，无法说服自己相信这事很重要。他已经四十二岁，往前，看不到任何自己渴望享受的东西，往后，看不到任何值得费心记住的事物。

<br>
>你最初爱的那个人并不是你最终爱的那个人，爱不是最终目标而是一个过程，借助这个过程，一个人想去了解另一个人。

<br>
>一天又一天，那层保护他们的克制的皮层逐渐脱落，所以，最后，他们像许多极其羞怯的人一样，彼此向对方敞开，完美又无拘无束、惬意地撤去了保护，而且有绝对无拘无束的惬意感。 几乎每天下午，斯通纳上完课后就去她的公寓。他们做爱，说话，然后又做爱，像孩子玩游戏般不知疲倦。春天的日子延长了，他们渴望夏天的到来。

<br>
>斯通纳还非常年轻的时候，认为爱情就是一种绝对的存在状态，在这种状态下，如果一个人挺幸运的话，可能会找到入口的路径。成熟后，他又认为爱情是一种虚幻宗教的天堂，人们应该怀着有趣的怀疑态度凝视它，带着一种温柔、熟悉的轻蔑，一种难为情的怀旧感。如今，到了中年，他开始知道，爱情既不是一种优美状态，也非虚幻。他把爱情视为转化的人类行为，一种一个瞬间接一个瞬间，一天接一天，被意志、才智和心灵发现、修改的状态。

<br>
>有时，早晨，他到公寓时，发现她刚刚睡醒，还带着睡眠的温暖和性感，那件深蓝色的睡袍里面一丝不挂，她穿上就过来开门。在这样的早晨，他们经常几乎来不及说话就开始做爱，走到那张自然乱糟糟、还带着凯瑟琳睡觉时留下的余温的窄床前。 她的身材修长、纤细、满怀温柔的激情，他抚摸时，笨拙的手在肉体上好像活了起来。有时，他会凝视着她的身体，像是一座结实的金银宝藏，交给他保管，他粗硬的手指抚弄着大腿以及腹部潮湿、隐约散发着粉红色光泽的皮肤，惊叹着她那小小的硬实的乳房，精巧而细腻。他忽然想到，自己还从不了解另一个人的身体。他甚至想到，这就是他经常把另一个人的自我与随身携带这个自我的躯体分离开来的原因。最后他又想到，几乎是决定性地领悟到，自己从未怀着任何亲密或者信任，乃至人类托付的温暖去了解过另一个人。

<br>
>可我们从来没有真正——在一起。甚至做爱的时候。

<br>
>这个模糊的身影，没有脸，没有名。他的吃惊化作悲哀，对这个不知名的男孩有种宽宏的同情心，这个男孩由于某种不明原因的迷茫痛苦，抛弃了的人又被斯通纳拥有了。

<br>
>他走出办公室，踏进漫长走廊的黑暗中，步履沉重地走进阳光里，走进外面开阔的世界，无论他从哪里转过身，这个世界都像一座监狱。

<br>
>他心怀无法量度的悲伤看着他们最后欢乐的努力，就像生命利用死亡的躯体跳的一场舞蹈。

<br>
>她经常偷偷喝酒，由于某种不明原因和久远的悲伤，她得了一种罕见而且一般都会致命的疾病，在慢慢走向死亡。

<br>
>长久的沉默逐渐退缩成一种内向，

<br>
>格蕾斯几乎动都不动，好像感觉稍微一动就会摔进一道深渊，在这道深渊里，她根本爬不上来。

<br>
>伊迪丝放弃了战役，开始了漫长、缓慢、通往自己都不清楚目的的旅程。

<br>
>由于跟这个世界格格不入，它只好生存在一个不可能是自己家园的地方。渴望温柔和安静，它只好以冷漠、麻木和喧闹为食粮。这种天性，即使在陌生和充满敌意、不得已要生存的地方，也没有蛮力击退反对它的残暴势力，只有退缩到一个静谧之地，那里荒凉、狭小而柔静。

<br>
>这是一种不张扬的美，几乎可以说是病态的美。

<br>
>他渴望介入，他想品尝死亡的滋味，毁灭的苦涩快感，流血的感觉。他既感觉可耻，又感觉自豪。在这之上则是苦涩的失望，对自己，对这个时代和让他变得如此的环境。

<br>
>她虽然很绝望，但却算得上幸福开心了。她可以安安静静地过日子。少喝点酒，年复一年，自我麻痹，来对抗自己那已经变得虚无的生活。

<br>
>她继续喝酒，那种不变的冷漠就像一个彻底失去希望的人。

<br>
>他的失落感，内心藏了很久的失落感，喷涌而出，彻底将他吞没，他任由这股洪流裹挟着，意志已失去控制。他不想搭救自己。接着他又亲切地笑了，好像是冲着某个记忆而笑。

<br>
>时间在流逝，而他却看不见这种流逝。

<br>
>他想当一名教师，他成了教师。但他知道，他永远知道，人生的大部分时候他都是一个冷漠的人。他曾梦想过某种正直，某种绝对的纯洁。他寻找过妥协和无关紧要的攻击性消遣。他曾想象过智慧，在漫长岁月的尽头，他找到了无知。还有什么呢？他想，还有什么呢？





]]></content>
      <categories>
        <category>阅读</category>
      </categories>
  </entry>
  <entry>
    <title>不能承受生命之轻摘抄</title>
    <url>/year/12/06/%E4%B8%8D%E8%83%BD%E6%89%BF%E5%8F%97%E7%94%9F%E5%91%BD%E4%B9%8B%E8%BD%BB%E6%91%98%E6%8A%84/</url>
    <content><![CDATA[<ul>
<li>尼采常常与哲学家们纠缠—个神秘的“众劫回归”观：想想我们经历过的事情吧，想想它们重演如昨，甚至重演本身无休无止地重演下去！这癫狂的幻念意味着什么？</li>
</ul>
<a id="more"></a>

<ul>
<li><p>最沉重的负担压得我们崩塌了，沉没了，将我们钉在地上。可是在每一个时代的爱情诗篇里，女人总渴望压在男人的身躯之下。也许最沉重的负担同时也是一种生活最为充实的象征，负担越沉，我们的生活也就越贴近大地，越趋近真切和实在。 　　相反，完全没有负担，人变得比大气还轻，会高高地飞起，离别大地亦即离别真实的生活。他将变得似真非真，运动自由而毫无意义。</p>
</li>
<li><p>没有比较的基点，因此没有任何办法可以检验何种选择更好。我们经历着生活中突然临头的一切，毫无防备，就象演员进入初排。如果生活的第一排练便是生活本身，那生活有什么价值呢？这就是为什么生活总象一张草图的原因。不，“草图”还不是最确切的词，因为草图是某件事物的轮廓，是一幅图画的基础，而我们所说的生活是一张没有什么目的的草图，最终也不会成为一幅图画。</p>
</li>
<li><p>只发生过一次的事就象压根儿没有发生过。如果生命属于我们只有一次，我们当然也可以说根本没有过生命。</p>
</li>
<li><p>唯一能使双方快乐的关系与多愁善感无缘，双方都不要对对方的生活和自由有什么要求。</p>
</li>
<li><p>同女人做爱和同女人睡觉是两种互不相关的感情，岂止不同，简直对立。爱情不会使人产生性交的欲望（即对无数女人的激望），却会引起同眠共寝的欲求（只限于对一个女人的欲求）</p>
</li>
<li><p>一个作者企图让读者相信他的主人公们都曾经实有其人；是毫无意义的。他们不是生于母亲的子宫，而是生于一种基本情境或一两个带激发性的词语。托马斯就是“Einmalistkeinmal”这一说法的产物，特丽莎则产于胃里咕咕的低语声。</p>
</li>
<li><p>什么也不是，只是一块标记着所有生理过程的仪表板，标记着吃，看，听，呼吸以及思维的情况。</p>
</li>
<li><p>她的灵魂浮现于她的身体表面，如那些塞在底舱的水手终于冲了出来，散布在甲板上，向着长天挥臂欢呼。</p>
</li>
<li><p>宣称青春与美丽被人们过分高估，其实毫无价值。</p>
</li>
<li><p>在那里，青春与美丽一文不值，世界不过是肉体巨大的集中营，人人都差不多，灵魂是看不见的。</p>
</li>
<li><p>那个唤她的人是陌生者同时又是个与她有友谊默契的人。他唤她的声音是和善的，于是，特丽莎感到她的灵魂从血管里和毛孔里冲出体外，向他展示开来。</p>
</li>
<li><p>人的生活就象作曲。各人为美感所导引，把一件件偶发事件（贝多芬的音乐，火车下的死亡）转换为音乐动机，然后，这个动机在各人生活的乐曲中取得一个永恒的位置。安娜可以选择另一种方式自杀，但死和火车站的动机，与爱的诞生有着不可忘怀的联系，并且在她绝望的时刻，以黑色的美诱惑着她。人们没有认识到这一点，即使在最痛苦的时候，各人总是根据美的法则来编织生活。</p>
</li>
<li><p>见那些不曾发生的事。是人类的最深层需要。这里存在着危险。如果这些梦境不美，它们就会很快被忘记。</p>
</li>
<li><p>不论谁，如果目标是“上进”，那么某一天他一定会晕眩。怎么晕法？是害怕掉下去吗？当了望台有了防晕的扶栏之后，我们为什么害怕掉下去呢？不，这种晕眩是另一种东西，它是来自我们身下空洞世界的声音，引诱着我们，逗弄着我们；它是一种要倒下去的欲望。抗拒这种可怕的欲望，我们保护着自己。 　　那些裸体女人围着游泳池行进，那些棺材里的尸体为她也是死人面欣喜——这就是她害怕的“底下世界”。她曾经逃离，但这个世界神秘地召唤她回来。这些就是她的晕眩：她听了一种甜美的（几乎是欢快的）呼唤，重新宣读了她的命运和灵魂，听到了没有灵魂者的大聚集在召唤她。虚弱的时候，她打算响应这一召唤，回到母亲那里去；打算驱散她身体甲板上灵魂的水手们；打算趋就到母亲的朋友们中间去，当有人放响屁时跟着笑；还打算和她们一起围着游泳池裸身行走，一起唱歌。</p>
</li>
<li><p>那些裸体女人围着游泳池行进，那些棺材里的尸体为她也是死人面欣喜——这就是她害怕的“底下世界”。她曾经逃离，但这个世界神秘地召唤她回来。这些就是她的晕眩：她听了一种甜美的（几乎是欢快的）呼唤，重新宣读了她的命运和灵魂，听到了没有灵魂者的大聚集在召唤她。虚弱的时候，她打算响应这一召唤，回到母亲那里去；打算驱散她身体甲板上灵魂的水手们；打算趋就到母亲的朋友们中间去，当有人放响屁时跟着笑；还打算和她们一起围着游泳池裸身行走，一起唱歌。</p>
</li>
<li><p>“我想与你在我的画室里做爱。那儿象一个围满了人群的舞台，观众不许靠近我们，但他们不得不注视着我们……”</p>
</li>
<li><p>表面的东西是明白无误的谎言，下面却是神秘莫测的真理。”</p>
</li>
<li><p>入侵并不仅仅是一场悲剧，还是一种仇恨的狂欢，充满着奇怪的欢欣痛快。</p>
</li>
<li><p>这是正常的。一切正常的东西都是美的。</p>
</li>
<li><p>“裸体可没有错，”这位女人带着母性的柔情说。“这是正常的。一切正常的东西都是美的。”</p>
</li>
</ul>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>人类简史摘抄</title>
    <url>/year/12/06/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E6%91%98%E6%8A%84/</url>
    <content><![CDATA[<ul>
<li>不幸的是，演化观点并不是唯一判断物种成功与否的标准。它一切只考虑到生存和繁殖，而不顾个体的痛苦或幸福。</li>
</ul>
<ul>
<li>我们从农业革命能学到的最重要一课，很可能就是物种演化上的成功并不代表个体的幸福。</li>
</ul>
<a id="more"></a>

<ul>
<li><p>而根据生物学，人并不是“创造”出来的，自然也就没有“造物者”去“赋予”人类什么。个体诞生的背后就只是盲目的演化过程，而没有任何目的。所以“造物者赋予”其实就只是“出生”。 同样，生物学上也没有“权利”这种事，只有各种器官、能力和特性。鸟类会飞就是因为它们有翅膀，可不是因为有什么“飞的权利”。此外，这些器官、能力和特性也没有什么“不可剥夺”的问题，它们常常会不断突变，还可能在一段时间后完全消失。例如鸵鸟，就是失去了飞行能力的鸟类。所以，“不可剥夺的权利”其实是“可变的特性”。</p>
</li>
<li><p>因此，我们来看看美国《独立宣言》改用生物学、科学的角度来写该是如何： 我们认为下面这些真理是不言而喻的：人人演化各有不同，出生就有某些可变的特性，其中包括生命和追求快感。</p>
</li>
<li><p>我们知道人在生物学上不相等！但是如果大家都相信人人在本质上平等，就能创造出一个稳定繁荣的社会。</p>
</li>
<li><p>身为人类，我们不可能脱离想象所建构出的秩序。每一次我们以为自己打破了监狱的高墙、迈向自由的前方，其实只是到了另一间更大的监狱，把活动范围稍稍加以扩大。</p>
</li>
<li><p>奶牛被迫与后代分开时是否会造成忧郁。</p>
</li>
<li><p>假设你可以将自己的大脑整个儿备份到硬盘上，再用笔记本电脑来读取运作。这样一来，笔记本电脑是不是就能够像智人一样地思考和感受了呢？如果是的话，那算是你吗？还是算别人呢？如果计算机程序设计师可以建构起一个全新的数字个体心灵，完全由计算机程序码组成，但拥有自我的知觉、意识和记忆，这又算是什么？如果你让这个程序在计算机上运作，这算是一个人吗？如果你删了这个程序，算是谋杀吗</p>
</li>
</ul>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>似水柔情</title>
    <url>/year/12/12/%E4%BC%BC%E6%B0%B4%E6%9F%94%E6%83%85-%E5%8D%81%E4%BA%8C/</url>
    <content><![CDATA[<p><img src="http://ovlnt0xy1.bkt.clouddn.com/2017-12-12-15130617923439.jpg" alt=""></p>
<a id="more"></a>

<p>在古代的什么时候，有一位军官，或者衙役，他是什么人无关紧要，重要的是，他长得身长九尺，紫髯重瞳，具体他有多高，长得什么样子，其实也不重要，重要的是他在高高的宫墙下巡逻时，逮住了一个女贼，把锁链扣在了她脖子上。这个女人修肩丰臀，像龙女一样漂亮。他可以把她送到监狱里去，让她饱受牢狱之苦，然后被处死；也可以把锁链打开，放她走。在前一种情况下，他把她交了出去；在后一种情况下，他把她还给了她自己。实际上还有第三种选择，他用铁链把她拉走了，这就是说，他把她据为己有。其实，这也是女贼自己的期望。</p>
<p>阿兰在书里写道：正是阳春三月，嫩柳如烟的时节，那位衙役把她带到柳树林里，推倒在乌黑的残雪堆上，把她强奸了。然后，她把自己裹在被污损了的白衣下，和他回家去。阿兰说：铁链的寒冷、残雪的污损，构成了惨遭奸污的感觉。她觉得这样的感觉真是好极了。小史想到这件事的始未，觉得阿兰简直是有病了。阿兰的书，阿兰在那一夜里对他讲到的一切、还有阿兰对他的爱情，这三件事混在一起，好像一个万花筒。而这三件事在阿兰那里就变得很清楚。这就是，在阿兰写到这段文字之前，他想到了自己在那一夜坐在派出所里，看着小史狰狞的面孔，感受了他对他的轻蔑。这些感觉就幻化成了那个女贼在树林里惨遭蹂躏，她白衣如雪，躺在一堆残雪之上。这个女贼就是阿兰。虽然如此，假如不把阿兰对小史的爱考虑在内，这个场面还是脉络不清。</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>脑洞</tag>
      </tags>
  </entry>
  <entry>
    <title>像另一个人那样活着</title>
    <url>/year/09/13/%E5%83%8F%E5%8F%A6%E4%B8%80%E4%B8%AA%E4%BA%BA%E9%82%A3%E6%A0%B7%E6%B4%BB%E7%9D%80/</url>
    <content><![CDATA[<p>大致从卡夫卡和普鲁斯特开始，现代小说中的主角就不再是英雄人物了，而往往是庸常现实生活中的失败者。这种失败是现实俗世生活意义上的失败：他们或是无法勉强自己去获得这样的成功，或是无力像他人那样娴熟而不假思索地应接自如，又或是无法从所谓“成功”中得到愉悦感，因而<strong>与现实之间总存在着某种不能缓解的疏离感。</strong>与那种更强调对外物的征服欲的现代精神相比，他们似乎更乐意像鼹鼠一样躲在自己幽暗的角落世界里向内挖掘。</p>
<a id="more"></a>

<p>约翰·威廉斯的《斯通纳》也是如此。小说没有任何戏剧性的后现代叙事手法，不紧不慢地从威廉·斯通纳在美国西部农场上的少年时代开始，一直写到他离开人世。虽然在他人生所经历的六十五年间（1891-1956），外面爆发了两次世界大战（如果加上冷战则是三次）和一次经济大萧条，但那对他的生活几乎没有产生什么直接影响：他自1910年上大学起，就一直呆在同一个校园里，外面世界的那些事只是造成了他岳父自杀、未来的女婿战死等间接影响，仿佛时代的大浪波及到这个平静的池塘时已只剩下涟漪。</p>
<p>的确，在一个大时代中能保有这样的平静是无上幸事，在同时代的许多国家，普通人只怕想躲都无法躲开那些席卷而来的大浪——就像索尔仁尼琴在《红轮》中所暗喻的那样，<strong>一个人在昏昏欲睡中靠着机车巨大的红色车轮，但它却忽然转起来，卷起你背上的衣服，以不可抗拒的力量裹挟、推动着你卷入到危险的未知境地中去。</strong>相比而言，斯通纳至少在不想参战时还能拒绝参战，一辈子都可以藏身在象牙塔里，尽管他的同侪马斯特思嘲讽说大学“是给那些体弱、年迈、不满以及失去竞争力的人提供的休养所”，但那儿至少还有庇护所。</p>
<p>当然，这并不是说他就可以在这象牙塔里优游自在，相反，或许听起来有些奇怪的是，正是因此，一个人要反抗反倒变得更困难了。 <strong>你也许觉得生活沉闷、内心压抑，但甚至都不知道应该反抗谁、如何反抗，因为看起来似乎并没有一个明确的外部力量在左右着你的生活，只是一团无以名状的灰色空气。如果任由自己发泄这种怒气，又只会让旁人觉得他古怪、神经质或莫名其妙的老顽固。</strong>这在某种程度上正是斯通纳生活的写照：他始终未能真正求得自己“辛苦追求的宁静”，敏感地意识到自己的生活里充满了挫败，怀疑这样究竟有何意义，然而他从未能反抗或真正改变什么，只是成功地使周围人觉得自己越来越难以理解。他的所有反抗要么在爆发之前就熄火了，要么在爆发之后归于失败，别人看到的只是他的某个“姿势”，却不能理解这是想表明什么、他又为何如此。</p>
<p>更麻烦的是，一个人有时会（并不总能）赫然发现所需要反抗的那个主宰正是自己。斯通纳本身就是一个对自我要求和道德感颇强的人物：出身于1891年的他，在成人之前经历了美国镀金时代的尾声以及禁欲主义的纯真年代，社会上既物欲横行，涌现出许多拜金的新潮女郎（flapper），又有清教徒道德主义的禁酒运动，这样的社会背景下，他和妻子伊迪丝在相处时那种彼此既保守、又拘谨不自如的相处，可说是那个时代的缩影之一。在小说中，伊迪丝这样传统而保守的女性已不再被描绘为美德和优雅的化身，然而斯通纳自己对待内心感情的第一反应也是自我克制。 他之所以变成后来那个古怪的样子，或许正是因为他之前在管束自己这一点上做得太成功了。</p>
<p>小说中不止一次刻画斯通纳的自我审视：“有时，他回想自己几年前的样子，被那个陌生人物的记忆搞得惊诧不已，那个人像土地中冒出来的”（页18）、“当他开始向自己的听众和学生自我介绍时，他发现自己内心仍然深藏着某种惊奇感。有时，他对学生讲话时，<strong>仿佛是站在自我之外，观察着一个陌生人在给一群并不情愿地聚集在一块儿的人发表讲话”</strong>（页30）、“即便他拿出全部坚强的忍耐力和坚忍不拔的行动，度过几天、几星期，自己仍然是一个严重分裂的人”（页296）。他不仅是时代的旁观者，甚至是自己生活的旁观者，像另一个人那样在生活，借用欧文·戈夫曼在《日常生活中的自我呈现》中的话说，<strong>他只是在扮演生活安排给自己的角色，但那个在“前台”的角色并不是真正的自己。</strong></p>
<p>在笔法上与《斯通纳》不无相似之处的美国小说《纯真年代》中有一句话：“他已经渐渐明白，已婚男人为什么不总能够立即顺从自己最初的冲动。”如果是这样，那么斯通纳在小说中表现出来的是一种相反的时代精神：一个在崇尚道德律己和禁欲的年代成长起来的人，在经历了最压抑的中年之后，才开始觉得有必要<strong>“立即顺从自己最初的冲动”</strong>。四十三岁那年与凯瑟琳·德里斯科尔小姐的婚外恋是他人生得以无拘无束地表露自己的唯一一段感情经历，尽管两人各自压抑了许多，但随后到来的幸福使人感觉这压抑至少也有一个好处：使得那些被压抑的东西更有力量、激情和余味。在她这里，他的自我苏醒过来，因而当这份爱受阻于现实时，他变得更加无所顾忌，既然“无论他从哪里转过身，这个世界都像一座监狱”（页256），那么他宁可在来日无多的人生中做回自己。</p>
<p>作为一个知识分子，他对待学术的态度与对待爱情不无共通之处：也是在人到中年之际，他虽然一方面怀疑自己所掌握的小小学问究竟有何价值，但另一面也因这种自嘲而更加豁达，从而使他在自我怀疑之下反倒比以前更为自信了，也恢复了对文字、语言的热爱，而这种热爱就像他的恋情一样，“他曾经深藏不露，好像那是非法和危险的，现在开始表现这种爱了，<strong>起先还是试探性的，接着大胆勇敢，最后就完全是自豪地表现了</strong>”（页133-134）。在凯瑟琳悄然离开后，他已丧失了对人生的幻想，因而比以往更不妥协地坚持自我，乃至逐渐在同事中落得个粗硬无礼和坏脾气的名声。他这样，乃是因为这是他仅存的自我，是他的尊严所系。可以设想，一个真正窒息的社会，是这样微小的反抗也无法存在的社会。</p>
<p>这部1965年问世的小说之所以在半个世纪之后读来仍感觉并不过时（没有多少小说能做到这一点），原因之一大概也是它写的其实是一个“无时间性”的故事。虽然故事中也清楚地交代了时代背景，但那却是疏离的，斯通纳的生活仿佛是独立于庞大历史事件而平行发展的轨道，至少要理解他的人生，并不需要对世界大战有多深的了解，这也使其人生获得了超越时间束缚的价值，因为它看起来也完全可能发生在当下的某个大学校园里。在一个线性进化的时空中，大概也唯有校园里的时间是循环式的，而知识分子们，也始终面临着大同小异的问题。考虑到这一点，小说那种不动声色的平淡克制写法想来也是有意如此，大概作者才一开始就意识到，平淡才最能持久。</p>
<h2 id="转自《南都周刊》"><a href="#转自《南都周刊》" class="headerlink" title="转自《南都周刊》"></a>转自《南都周刊》</h2><p>勘误：<br>p.49：一个身份不明的学生，很快就成为当地的某种民间英雄，他爬到杰西楼前的一根大柱子上，在柱顶上吊了一只用稻草填充的凯泽像。译注：乔治·凯泽（Georg Kaiser, 1878-1945），德国表现主义剧作家，主要作品有《从清晨到午夜》。<br>按：此注有误。这是在一战末期的事，这里的Kaiser指德国皇帝，被视为一战爆发的罪魁祸首，此所以这个学生会被视为英雄，否则这句话就很奇怪了。</p>
<hr>
<h3 id="“旁观自己”的视角"><a href="#“旁观自己”的视角" class="headerlink" title="“旁观自己”的视角"></a><strong>“旁观自己”的视角</strong></h3><blockquote>
<p>他只是在扮演生活安排给自己的角色，但那个在“前台”的角色并不是真正的自己。</p>
</blockquote>
<p>引用：</p>
<blockquote>
<p>随着集中营的现实变得越发残酷，囚犯们的幻想终究破灭。这时候，囚犯们又会产生一种奇异冷酷的幽默感，并形成一种“旁观自己”的视角，对自己未来的遭遇甚至还有点好奇。</p>
</blockquote>
<blockquote>
<p>有一次，一位更早被抓进集中营的朋友来到弗兰克住的大屋子，打算给他们这些新来的人说点注意事项。这位朋友对众人说：“最重要的事情是要天天刮胡子，用玻璃碴也好，用最后一片面包换个刀片也好，一定要每天刮脸。这样才能看起来更年轻，脸色更好。只有看上去能干活的人，才不会被送进毒气室。那些脸色不好，看起来体弱有病、不能干活的人，很快就会被送进毒气室。”<br>说到这里，这位朋友指了指弗兰克，对其他人说：看，他就是这样的人。<br>正常环境中，任何人听到这种话，一定会吓得魂飞魄散，或者勃然大怒。但弗兰克当时的反应，却只是笑了笑——你看，这种反应就是<strong>“旁观自己”</strong>的视角，是不正常的反应。</p>
</blockquote>
<blockquote>
<p>接下来囚犯的心理将进入第二阶段，那就是冷漠、迟钝、对任何事情都漠不关心。囚犯们日夜所想的，就是吃、穿、睡等等最基本的生活需求，除此以外的任何事情——发生在眼前的折磨和暴行、冻饿而死的囚犯尸体、难友的痛苦，都引不起他们的兴趣。</p>
</blockquote>
<blockquote>
<p>囚犯们的情感已经麻木，看到什么都只会呆呆地站着不动，不再有厌恶、恐惧、怜悯等情感，对一切都司空见惯。<br><strong>当外界的压力太大，完全无望摆脱，而且还会长期持续的时候，人就会用冷漠的外壳把自己保护起来，让情感变“钝”，以尽量减少外界对自己的刺激。这很可能是人类的一种本能，在艰难环境中求生的重要技能。</strong></p>
</blockquote>
<p>摘自————《活出生命的意义》作者：弗兰克尔</p>
<h3 id="观点：命运论"><a href="#观点：命运论" class="headerlink" title="观点：命运论"></a>观点：命运论</h3><blockquote>
<p>“你也许觉得生活沉闷、内心压抑，但甚至都不知道应该反抗谁、如何反抗，因为看起来似乎并没有一个明确的外部力量在左右着你的生活，只是一团无以名状的灰色空气。如果任由自己发泄这种怒气，又只会让旁人觉得他古怪、神经质或莫名其妙的老顽固”</p>
<p>“一个人在昏昏欲睡中靠着机车巨大的红色车轮，但它却忽然转起来，卷起你背上的衣服，以不可抗拒的力量裹挟、推动着你卷入到危险的未知境地中去。”</p>
</blockquote>
<h3 id="反驳：逃避责任的借口"><a href="#反驳：逃避责任的借口" class="headerlink" title="反驳：逃避责任的借口"></a>反驳：逃避责任的借口</h3><blockquote>
<p>有时候我们会回避承担自己的责任，会把自己的自由上交给一种更宏大的力量。并且希望这个宏大的力量来主宰我们的命运，所以我们就不再需要为自己的成功和失败负责。</p>
</blockquote>
<p>摘自——《逃避自由》</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>人生最大的挑战，其实是战胜平庸</title>
    <url>/year/04/10/%E5%86%8D%E8%AF%BB%E6%96%AF%E9%80%9A%E7%BA%B3/</url>
    <content><![CDATA[<p><img src="http://ovlnt0xy1.bkt.clouddn.com/2018-04-10-15041098079682.jpg" alt=""></p>
<blockquote>
<p>人生最大的挑战，其实是战胜平庸。</p>
</blockquote>
<p>《斯通纳》的故事从美国西部农场上的少年开始，一直到他离开人世。他的人生大致可以用几个词语来总结，农家子弟、求学、结婚、生子、教书、退休、衰老、死亡。他的人生充满着无力感，可以说是一个庸俗的失败者。</p>
<a id="more"></a>

<h4 id="斯通纳劳苦的童年："><a href="#斯通纳劳苦的童年：" class="headerlink" title="斯通纳劳苦的童年："></a>斯通纳劳苦的童年：</h4><blockquote>
<p>从自己最早能记得的时候开始，威廉·斯通纳就有很多活儿必须做。六岁的时候，他就得从那几头瘦骨嶙峋的母牛上挤奶，把几只猪赶进离屋子不远的圈里，还要到一窝母鸡那里去收鸡蛋。甚至去距离农场八公里的学校读书，从黎明前到天黑后，他的这段时间要被一两种活儿占据。十七岁的时候，在农活的重压下，他已经开始驼背。</p>
</blockquote>
<h4 id="终于，他的生活迎来了希望。"><a href="#终于，他的生活迎来了希望。" class="headerlink" title="终于，他的生活迎来了希望。"></a>终于，他的生活迎来了希望。</h4><blockquote>
<p>父亲在椅子里挪了挪身子。他看着自己粗壮、长满老茧的手指，泥土钻进那些干裂的缝隙，深邃得都不可能洗掉了。他把手指锁在一起，从桌上举起来，那态度几乎像个祷告者。 “说来我从来没有上过什么学，”他说，望着自己的手，“读完六年级后就开始在一家农场干活了。年轻的时候不用上学也能支持。可是现在我就不知道了。就像这土地，一年比一年干枯，干活一年比一年辛苦；不像我还是小孩子时那样肥沃了。县里的人说，他们想到了很多新点子，有很多干活儿的办法，会在大学教给你。他说的可能没错。有时我在地里干活的时候也会琢磨。”他打住不说了，手指紧紧攥在一起，紧握着的手放在桌上。“我开始琢磨——”他愁眉苦脸地看着自己的手，又摇了摇头，“秋天了你就去上大学吧。你妈妈和我能应付得了。”</p>
</blockquote>
<h4 id="可是在学校"><a href="#可是在学校" class="headerlink" title="可是在学校"></a>可是在学校</h4><blockquote>
<p>母亲的脸正对着他，可是并没有看他。母亲的眼睛挤着闭着；她重重地喘着气，脸庞好像因为痛苦而扭曲着，她紧攥的拳头压在脸颊上。斯通纳惊奇地发觉母亲在哭泣，深情又默默地哭着，带着不怎么哭泣的人嫌丢脸和不好意思的表情。他又看了眼母亲，然后缓慢地站起身，走出客厅。他顺着老路踏上通向自己阁楼房间的那条狭窄的楼梯；他在床上躺了很长时间，睁大眼睛望着头顶的黑暗。</p>
</blockquote>
<h4 id="与父母形同陌生人"><a href="#与父母形同陌生人" class="headerlink" title="与父母形同陌生人"></a>与父母形同陌生人</h4><blockquote>
<p>但他发现自己跟父母无话可说；而且，他意识到，他和父母已经逐渐形同陌生人。他感觉自己的爱因为损失反而更强烈了。他比原来计划的提前一个多星期返回哥伦比亚。</p>
</blockquote>
<p>与现实之间有着某种不能被缓解的疏离感。<br>他不仅是时代的旁观者，甚至是自己生活的旁观者，像另一个人那样生活。</p>
<p>他只是扮演生活给自己的角色，在那个”前台“表演的人并不是自己。</p>
<blockquote>
<p>有时，他对学生讲话时，仿佛是站在自我之外，观察着一个陌生人在给一群并不情愿地聚集在一块儿的人发表讲话；他听着自己平板的声音在背诵着准备过的材料，从背诵中体会不到丝毫属于自己的兴奋。</p>
</blockquote>
<p>未完…</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>斯通纳</tag>
      </tags>
  </entry>
  <entry>
    <title>毛姆 -《刀锋》 摘抄</title>
    <url>/year/01/21/%E5%88%80%E9%94%8B/</url>
    <content><![CDATA[<p>“我真希望你能明白我向你提供的生活比你想象的生活要充实得多，真希望让你明白精神生活是多么令人兴奋，那种经历是多么丰富。那样的生活没有止境，多么幸福。只有一件事情能与之媲美，好比你一个人坐在飞机上，飞机越飞越高，越飞越高，你周围只有无垠的空间，你会陶醉其中。你感觉那么的愉悦，就算用世界上所有的权力和荣誉来同你交换，你也会舍不得。我前几天在阅读笛卡尔的作品，他的文字是那样安逸，优雅，清澈。天哪！” </p>
<a id="more"></a>

<p>“可是拉里，”她绝望地打断他，“你难道不明白你是在要求我做一件我无法适应、不感兴趣也不想感兴趣的事吗？还要我跟你说多少遍，我就是一个普普通通的女孩。我现在二十岁，十年后我就老了，我想趁现在有机会的时候过点好日子。噢，拉里。我真的非常爱你。你说的这一切都是无关紧要的东西，不会让你有任何出息的。就算为了你自己，我求求你了，放弃吧。拉里，成为一个堂堂正正的男人，做男人该做的事情。别人都在奋发图强时，你却在浪费宝贵的时间。拉里，如果你爱我，肯定不会为了一个梦而弃我于不顾的。你已经游荡过了，跟我们一起回美国吧。” “我做不到，亲爱的。这样回去对我来说简直就是死亡，等于出卖了我的灵魂。” </p>
<p>“噢，拉里，你为什么要这样说话？那些歇斯底里、自我卖弄的女人才会这样说话。这样说有什么意义呢？没有，没有，没有丝毫意义啊。” </p>
<p>“我只是把内心的感觉说出来而已。”他答道，眼里闪着光芒。 “你怎么能笑呢？你难道没觉得这是件极为严肃的事情？我们现在走到了十字路口，现在的决定将会影响我们一辈子。” “我知道，请你相信我，我是非常严肃的。” 她叹了口气。 “如果我跟你讲道理，你仍旧充耳不闻，那我真没什么好说的了。” “可我不觉得你这是在讲道理，我觉得你说的都是无聊至极的话。” </p>
<p>“你是说我？”要不是她那么伤心，早会笑出声来，“我可怜的拉里，你真是个十足的疯子。” </p>
<p>她慢慢把手指上的戒指取下来，放在掌心，望着它。一颗切割得四四方方的红宝石镶嵌在细细的白金指环上，她素来很喜欢。 “如果你爱我，就不会让我这般痛苦。” </p>
<p>“我真的爱你。可惜一个人做自己认为正确的事情时，难免会让别人不快乐。” 她把手伸了出去，那颗红宝石戒指就在掌心，颤抖的嘴唇勉强挤出一丝笑意。 </p>
<p>“还给你，拉里。” “它对我来说没有丝毫用处。你何不留着，当成我们友谊的象征可好？你可以戴在小指上，我们的友谊不需要这样决裂，对吗？” </p>
<p>“我会永远关心你，拉里。” “那就留着吧，我也希望你戴着。” 有那么一瞬间，她迟疑了一下，然后戴在右手的小指上。 “太大了。” </p>
<p>“你可以改一改，我们去里兹饭店喝一杯吧。”</p>
<p>“好啊。”</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>哪里都是楚门的世界</title>
    <url>/year/11/22/%E5%93%AA%E9%87%8C%E9%83%BD%E6%98%AF%E6%A5%9A%E9%97%A8%E7%9A%84%E4%B8%96%E7%95%8C/</url>
    <content><![CDATA[<p><img src="http://ovlnt0xy1.bkt.clouddn.com/2017-12-11-15129566132297.jpg" alt="-w325"></p>
 <a id="more"></a>

<p>楚门的世界 鼎鼎大名的电影… 直到完整看完，才明白TA的伟大之处：<strong>在遥远的以前，预估了日常生活的无趣，对他人生活强烈的窥视欲，以及真人秀的火爆。</strong></p>
<p>更可怕的是，在上班途中、下班后、工作闲暇，爱刷的、爱聊的都是真人秀，或者是明星类爆款大IP作品（捂脸～最近一直追老九门～）生活的有意思的地方去哪里了…只能通过长篇小说、绵延注水的剧集，兴奋又半强迫自己往下看..满怀期待地看完后 在找类似的继续追～!如此以往～继续循环？？！</p>
<p>我们究竟怎么了？！工作、加班，当然奔波辛苦：坐着拥挤公交，丧尸般机械go to work–working–下班继续working–挤公交回去，都是每天的真实写照，即使睡觉，梦里脑中交杂着工作中几个方面的信息。所以 我 and 同路人，希望下班就可以更无脑的接受happy信息，刷剧，看小说，让“有可追”的概念伴随我，避免自己还要费脑选择干什么～</p>
<p>copy and copy，生活即使出现偶然的变化，也在微小波动内，我们逐步to be the same as楚门：重复做事，不再想边界在哪里，为什么要机械重复？为什么我要两点一线的过日子？有吃有喝后，我们可以额外想些什么，有的没的，脑洞大开的，甚至anything 都OK 。</p>
<p>最可怕的是，当想去想think时，不知道自己想什么，要想什么，可以想什么。但每天能留给wo自由去想的时间很有限，内心os：赶紧想 一会就得睡觉了，抓狂想去想有趣的东西，可找脑海里一片空白……紧张的想ing，直至没有能用来想的时间over，重复进入另一个copy day，again and again～</p>
<p>如何有改变 ？投入到一个未知领域，花掉闲散的精力？今天所感，希望对自己有惊醒…工作完不知道做什么 也是浑浑噩噩对自己极不负责的，既然时间有限，才更应该跳出“楚门的世界”，别让青春虚度！</p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title>因为你的缘故我没有不曾去爱过就死了</title>
    <url>/year/11/15/%E5%9B%A0%E4%B8%BA%E4%BD%A0%E7%9A%84%E7%BC%98%E6%95%85%E6%88%91%E6%B2%A1%E6%9C%89%E4%B8%8D%E6%9B%BE%E5%8E%BB%E7%88%B1%E8%BF%87%E5%B0%B1%E6%AD%BB%E4%BA%86/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkq7y421g0j31kz0u0hdu.jpg" alt=""></p>
<p>因为你的缘故我没有不曾去爱过就死了。</p>
<a id="more"></a>

<p>他写到：</p>
<p>我会乞求你来原谅我，因为你的温柔没有激发我去成就伟大的业绩，而是使得我成了一个因你而失去了我原有的一小点理智，并且常常是在宁静的忧伤之中以哼哼着我所不明白的东西来打发时间的傻蛋，就像一个鬼魂。我日日夜夜地环绕着我所不能进入的地方溜达来溜达去。我所爱恋的啊！就是你，我的一切都是因为你，因为你我失去了理智，我的灵魂受到震颤，我在我的内在本质被惊骇；就是你，因为你我没有走完一生却没有什么东西能够足够震颤我，因为你的缘故我没有不曾去爱过就死了。</p>
<p>随后他又写到：</p>
<p>哪怕我的爱情是不幸的，这又算得了什么呢？对你的称赞比我自己生命中最幸福的瞬间更让我热情洋溢，你的不朽比我自己的存在更让我热情洋溢。是的，如果你被拿走了，如果你的名字被磨灭，那么支撑着我的唯一的支柱就被毁灭了。在之前这支柱一直帮我抵挡着，使得一切没有毋塌在一种无限的混乱、一种可怕的虚无之中。</p>
<p>他是一个爱思考的人，可是这种思考对他来说却是一种折磨。而这种折磨，对他来说是必要的，至少在此刻来说是重要的。因为他反感盲从，甚至恶心。因为他认为盲从本质上是一种掩耳盗铃的行径，是一种彻底的愚蠢。而他需要自己寻找到一种确实的目标，一种感觉他是自己的生活，一种真实，不被虚假谎言欺骗的生活。尽管这种目标和这种生活在别人看来是不可理喻的，甚至是愚蠢的。当然，有时候就连他自己也开始质疑，是否他是为了反抗而反抗，就像他之前所说的，也许对抗不是生活的本质。但他不确定，曾经的他确定过，可那是因为当时无知，现在他明白了他的无知，于是陷入了一种可怕的折磨当中，就像他写下的那段文字，这一切开始于一场失恋。</p>
<p>这个问题真是复杂到了极点，当然也可以一言以蔽之。就是他需要一种支持他的支柱，就像中世纪的人们需要上帝一样，然而现在信仰没了。</p>
<p>他还说，总觉得这个问题关乎所有存在的人，不过很多人像是之前的他一样，从没有意识到，而更多的人选择了一种自欺的生活，选择了谎言。</p>
<p>他接着说，我相信这种近乎自虐式反思有益于我长久的生活，当然，其中最大的风险就是我长久的处于这种折磨当中，而彻底的失去了生活。</p>
<p>按照他的意思，我想这或许也可以一言以蔽之：因为我的缘故我没有不曾去爱过就死了。</p>
]]></content>
  </entry>
  <entry>
    <title>如何得体跳槽</title>
    <url>/year/10/18/%E5%A6%82%E4%BD%95%E5%BE%97%E4%BD%93%E8%B7%B3%E6%A7%BD/</url>
    <content><![CDATA[<blockquote>
<p>跳槽，几乎是现今每个深处职场的人都要经历的事情。可是，有的人潇洒转身，有的人却越跳越惨，为什么？</p>
<p>这条关于如何得体跳槽的清单分享给你，15条建议，带你避开跳槽路上的那些“坑”</p>
</blockquote>
<a id="more"></a>

<p>转自逻辑思维！</p>
<ol>
<li><p>至少有70％的跳槽，是非理性的。</p>
</li>
<li><p>抛开不得已的个人和家庭原因，一切不以职业发展为核心的跳槽都是耍流氓。寻找新工作，真正要关注的应该是：去更兴旺的行业、寻找优秀的团队、新职位能让自己发挥最擅长的力量等因素。35岁之前，不建议单纯为了钱而跳槽。</p>
</li>
<li><p>跳槽前一定要认真思考四个问题：新工作能否带来我想要的东西、失去的是我能承受的吗、新工作中不好的部分我看到了吗、现在的工作是不是真的已经没有价值。如果想明白了这四个问题，还是决定跳槽，那就不要犹豫，坚定地递交辞职申请。</p>
</li>
<li><p>跳槽和其他所有事一样，要用“断舍离”的决策力，一步步做减法，只留下自己的首要目标，然后所有决策据此展开。不要想着自己的工作要有好的接替者、团队被新领导虐待怎么办、公司的体制还没理顺……这不是你该操心的了。</p>
</li>
<li><p>除了“金三银四”，跳槽的最好时机是完成一个阶段性任务、立下点儿功劳之后。这时候提出辞呈，一方面不留埋怨，另一方面老板会觉得欠你人情，难以拒绝；同时，“功成身退”对自己的未来身价，也有一种加持。</p>
</li>
<li><p>具体的辞职时间，最好是在一个月的下半月。新单位的录用函不是合同，仍存在变数。下半月离职，这个月的社保已经交了，即使新工作出现问题，也还有一段时间的挪腾空间，不至于社保中断。不是我们喜欢社保这东西，而是它断了确实会很麻烦。</p>
</li>
<li><p>跳槽可能面临原公司的挽留，要提就要提一个让人无法拒绝的理由。“钱更多”、“离家更近”显得自己没追求；“工作压力”、“人际关系”更不要提，一旦老板指出帮忙解决便不好回绝。真正的好理由有两种：一是无法解决的客观原因，如行业的固有限制、政策问题、企业的并购等；二是难以回绝的个人理由，如生育计划、婚后换城市、职业发展方向、需要进修等。</p>
</li>
<li><p>正确的辞职对象，应该是自己的直接领导。越级递交辞呈和直接向HR诉说，都是不得体的。越级搞得像投诉；向HR诉说，则好像你和直接领导的关系已经僵到没法正常沟通了一样，对谁面上都不好看。</p>
</li>
<li><p>在正式提出辞呈前，最好先做一次情感上的当面沟通，然后再写封正式的邮件。未经沟通，让领导在晚上12点要休息时，突然收到一封辞职信，是非常不得体的。再者，和领导的直接沟通，可能使真正困扰你的问题（也许还是误会）出现转机；如果不经沟通就发辞职邮件，就失去了任何的回旋余地。</p>
</li>
<li><p>如果辞职时，领导让你对现有公司、团队和工作提意见，记住千万不要提。如果现任领导把你批评同事的话讲给他们听（他一定会的，他要懂事你也不会离开他了），你就在老单位臭大街了。而加薪这种话，就更不要提了，那应该是离职的几个月前说的。</p>
</li>
<li><p>如果去意已决，在找工作的时候就要和新单位约好，留够至少30天的缓冲期。一方面，这是《劳动法》规定的自动离职期限，大多数公司也会在合同上说明。另一方面，给原单位一个招新人的缓冲期，也是自己职业性的体现，大家面上都好看。</p>
</li>
<li><p>最后记得静悄悄地走。给公司所有人群发邮件、痛斥现状的行为极为愚蠢。自己要走了，别人还要在团队里继续工作，不要让大家都难堪。一定范围内的辞职饭是可以的，也可以私下请要好的领导吃饭。如果去的是竞争关系的公司，那就悄无声息的叫几个关系好的同事小聚一下就好了。</p>
</li>
<li><p>即使跳槽，也要处理好和前东家的关系，持续地保持情感账户。毕竟你积累了几年的人脉、朋友和行业地位都在其中。而且昨天的敌人，可能就是明天的合作对象，要懂得为自己留后路。</p>
</li>
<li><p>最后切记一点：不要试图挑战竞业避止规则。即使你的级别没有让公司跟你签署竞业协议，也要尊重老东家。利用自己掌握的商业信息，做损害原单位利益的事，不仅是不职业的体现，更会毁掉你在圈子里的名声，严重时还可能坐牢。</p>
</li>
<li><p>最后的最后，提醒一句：换游泳池解决不了不会游泳的问题，有些问题还是原地修炼更好。当然，人活着不只是为了发展，如果有一天你遇到了人生中最看重的东西，上面的大多数原则，都可抛弃。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title>小王子的领悟</title>
    <url>/year/09/14/%E5%B0%8F%E7%8E%8B%E5%AD%90%E7%9A%84%E9%A2%86%E6%82%9F/</url>
    <content><![CDATA[<p>小王子终于明白，人世间真正值得珍惜的，并不在于所爱对象在客观上是否独一无二，而在于自己能否全心全意投入一段彼此驯服的关系。活着的价值，不赖于外在偶然的世界（谁可保证自己所爱就是世间唯一），而在于作为能爱的主体，能否用心浇灌爱护属于自己生命中的那朵玫瑰。</p>
<a id="more"></a>

<p>小王子决定离开他的小行星时，真是义无反顾，即使他的玫瑰放下骄傲和矜持，向他表露爱意和不舍，他依然不为所动，甚至觉得自己会一去不回。小小的玫瑰，留不住他，因为他要去见识更大的世界，认识更多的朋友。他渴望成长。成长的目的，是去领悟什么是生命中的重要之事。小王子带着这份初衷，开始他的人生之旅。</p>
<p>小王子在旅途中遇上不同的大人，有国王和喜欢虚荣的人，也有酒鬼和生意人，但小王子一点也不喜欢他们。他自信满满，觉得自己活得比这些人富足。为什么呢？因为他相信自己拥有整个宇宙至为独一无二的一朵玫瑰。这份独一无二，让他可以在别人面前肯定自己，甚至相信自己是伟大的。但当他来到地球，见到花园中五千朵跟他的花儿长得一模一样的玫瑰时，他一下子被彻底击倒：“我自以为拥有一朵独一无二的花儿，所以很富有，其实我拥有的只是一朵普通的玫瑰。”这是小王子经历的第一次人生大危机，因为支撑他的生命意义的基础，在残酷的现实面前，一下子崩塌。</p>
<p>拯救他的，是狐狸。狐狸教会他，怎样用心而不是用眼睛，去发现世间重要之事。小王子开始领悟，即使他的玫瑰并非世间唯一，但通过驯服，他却可以拥有另一层意义的“独一无二”。于是，他跑回去和那五千朵玫瑰说：“没人驯服你们，你们也没驯服任何人。你们就跟我的狐狸过去那样。那时，它只是一只和其它成千上万只狐狸一样的狐狸。可是我把它当成朋友，现在它就是世界上独一无二的了。”</p>
<p>问题是，为什么通过驯服，小王子就可以对自己说，没关系，即使我的玫瑰只是万千玫瑰的其中一朵，即使从外人看来她们之间没有任何分别，但因为也仅仅因为她是我的玫瑰，得到我的悉心照顾，并建立起彼此需要的关系，所以她就是我世上的唯一？小王子是在自欺吗？这是理解《小王子》的关键。</p>
<p>狐狸的教导是，生命中真正重要之事，并非它从外在的观点看有多少价值或有多么与众不同，而在于你能否和你所在乎的人或物，建立起真正的关联。要有这样的关联，你需要用心。你要用纯洁的心爱对方，聆听对方，了解对方的需要，也要容忍对方及为对方牺牲，并承受因爱而来的种种伤害。所以，狐狸才对小王子说：“你花在你玫瑰身上的时间，才让你的玫瑰变得这么重要。”</p>
<p>所谓时间，就是双方共享的历史。这份共享的历史，建立起小王子和他的玫瑰独特的关系，并构成他们的共同记忆。任何关系的建立，都是在特定的时空情境、特定的人生阶段、特定的生命情怀中发生。就此而言，任何一段用心的关系，皆是独一无二且不可取代。小王子终于明白，人世间真正值得珍惜的，并不在于所爱对象在客观上是否独一无二，而在于自己能否全心全意投入一段彼此驯服的关系。活着的价值，不赖于外在偶然的世界（谁可保证自己所爱就是世间唯一），而在于作为能爱的主体，能否用心浇灌爱护属于自己生命中的那朵玫瑰。正因如此，小王子才会有这样的剖白：“我的那朵玫瑰，普通路人会觉得她跟你们好像。可是光她一朵，就比你们全部加起来都重要，因为她是我浇灌的。”</p>
<p>有人或会马上问，既然每段驯服关系都是唯一且不可替代的，那么人们为什么不可以不断去开始新的关系？事实上，小王子在离开玫瑰以后，不是也驯服了狐狸吗？他为什么不可以留在地球，和狐狸好好生活下去？甚至小王子有一天觉着厌倦了，他也可以去玫瑰园驯服另一朵同样美丽的玫瑰啊。在这里，狐狸教晓小王子另一个重要道理，就是责任：“可是你不该忘记，你现在永远都得对你驯服过的一切负责。你要对你的玫瑰负责。”</p>
<p>一旦意识到这点，小王子的生命遂经历第三重转变。原来爱不仅仅是享受和拥有，还有责任。他有责任回去好好照顾他的玫瑰。狐狸在这里，也很不容易。它深爱小王子，它知道它一旦将道理全部告诉小王子，小王子就会离牠而去，它也知道会因此受伤，但它愿意承受。对它来说，它和小王子共同经历的一切，早已成为生命中至为美好的回忆。只要风吹起麦子，它就会想起小王子金黄色的头发。这于它而言，同样是生命的唯一。</p>
<p>不过，小王子心里其实清楚，经过一年之后，他的玫瑰很可能早已不在。因为地理学家告诉过他，花是不被记录的，因为花稍纵即逝。既如此，小王子为何仍然要离开狐狸，去尽那不可能尽的责任？他真的还能回到从前吗？去到选择被毒蛇咬的一刻，小王子的理由仍然是：“你知道……我的花儿……我对她有责任！”因为责任，一切未知、恐惧和危险都可以克服。小王子再一次义务反顾，走上生命另一段旅程。</p>
<p>这样的领悟，是何等高贵庄严，又是何等哀伤！这些年来，我一次又一次问自己，小王子真的非如此不可吗？他真的别无选择吗？小王子的问题，何尝不是我们每个人的问题。</p>
<p>转自：南方周末</p>
<blockquote>
<p>对于处于热恋期的伴侣而言，任何人生哲理，在彼此看来都不过是陈词滥调。然而，随着感情的投入，正是这种陈词滥调，如悬在头上的达摩克利斯之剑，越忽视，越变得难以忽视。于是乎，有人主动拥抱，有人殊死一搏，有人理所应当，有人过犹不及。</p>
<p>人生百态，不过如是。何为？</p>
</blockquote>
<blockquote>
<p>就像周老师说的那样，任何恋情的初始，包括初恋，大多热衷于海誓山盟的追求永久，而“曾经拥有”的大道理，在那时总显得“正确却不合时宜”；所以，在创作时，“文学和电影为了避免这种挫败而总是安排故事主角早逝，以使得美好定镜于生命的某一刻”。可是这样的处理方式，一方面让人们对爱情充满憧憬向往，另一方面让人们忽视潜在现实问题，活在爱情幻想或幻灭中的人群，因此走在感情种种极端里，变得自我迷失。</p>
<p>难道真的就无药可救？尤其对于伴侣们，无论热恋期，磨合期还是成熟期，爱情的消亡总归是宿命？又或许，大家总给予爱情过高或者过低的期待：谁都愿意在恋情中爱惜对方，保护对方；但彼此总将这种保护，在某种程度上变成了满足自我安全的控制。《小王子》里将这种行为称为“驯养”：彼此从未真正尊重过对方的意志，并在以爱为名义互相伤害中，忘记了相爱的初衷。</p>
</blockquote>
<blockquote>
<p>林夕话斋，“谁能凭爱意，要富士山私有”？谁不懂得欣赏谁，谁不懂得珍惜谁？没有什么付出是想当然的，也没有什么付出是不需要限制的。</p>
<p>所以，对于情侣们，“曾经拥有”的道理并不需要忽视或者避之不及。毕竟，正因为知道爱情的来之不易，彼此才更需要明白倍加珍惜，好好保管；而对于受过情伤的朋友们，也不要因为懂得了这个道理而放弃对爱的追求，毕竟，道理和爱情一样，同样不过转瞬即逝，并不恒常，更不可能真的成为什么咒语。相反，只要愿意相信，愿意坚持，爱情就不会消逝，反之亦然。</p>
<p>想起宋禅师天目文礼的一首诗，“不汝还兮复是谁？桃花落满燕子矶。日斜风动无人扫，燕子衔将云际飞。”某种程度上，谁都可以成为那只燕子的，它并不只是空想。</p>
</blockquote>
<blockquote>
<p>若你不信，看一下周老师的这篇文章吧，我猜，他应该愿意“把这陈年风褛，送赠你解咒”吧。</p>
</blockquote>
<p>还记得年少时，初读《小王子》，最不解的，是小王子为什么要决绝地离开玫瑰，害得深爱他的玫瑰要在小行星孤零零生活下去。如果这是一个关于初恋的故事，最美好的结局，难道不应是小王子和玫瑰一见钟情，彼此相亲相爱，最后长相厮守以终老吗？！那时我相信，真正的爱情，不可只求曾经拥有，而应求天长地久──“不在乎天长地久，只在乎曾经拥有”，是我们那个年代轰动一时的铁达时名表广告。</p>
<p>及后年长，我经历了我的初恋的挫败，目睹身边许多朋友初恋的挫败，然后在文学和电影中看到无数初恋的挫败，又或为了避免这种挫败而总是安排故事主角早逝以使得美好定镜于生命的某一刻，我开始想，为什么人生中最纯洁最投入最刻骨铭心的初恋，总是如此脆弱如此短暂？小王子的离开，是不是有着某些普遍的关于人性关于情感的秘密在背后，因而具有某种必然性？我被这个问题困惑经年，却始终没有答案。过去大半年，我一个人在台北文山区新光路慢慢过活，静静重读《小王子》，始渐渐体会，问题也许不在于在不在乎，而在于这是成长必须走过的一段路。</p>
<p>小王子为什么要离开？是因为玫瑰不够美吗？当然不是。在小王子眼中，玫瑰美得教他“心旌神摇”，并深信她是全宇宙独一无二的花儿。是因为厌倦吗？也不见得。直到临走，小王子也没流露半分对玫瑰的不耐烦。是因为吵架吗？好像是。由于玫瑰的虚荣和骄傲，有时的确惹得小王子生气，并对玫瑰产生各种误会。但如果仅仅是因为这些小事分手，那就难以解释小王子在离开后对玫瑰无尽的悔疚和思念，更何况在道别的一刻，玫瑰放下所有骄矜，向小王子表白：“是的，我是爱你的。你一点都不知道，都怪我。现在这些都不重要了。可是，你以前也跟我一样傻。你要快快乐乐的。”换言之，在玫瑰眼中，小王子根本不了解她对他的爱。小王子后来也向飞机师坦承：“可惜当时我太小了，不懂得好好爱她。”</p>
<p>读者或会糊涂，到底小王子是否和玫瑰相爱过？当然有，但那是一种未经反思的朦胧的直觉的爱。由玫瑰出现那天起，小王子就全心全意照顾玫瑰，和玫瑰建立起亲密无间的关系，但他当时并不知道这叫“驯养”，更不晓得驯养里面承载的意义和责任。他是直到遇见狐狸，经其启蒙，才懂得用“驯养”这一概念来理解他对玫瑰的爱。没有狐狸，他其实没法好好理解自己的情感。</p>
<hr>
<p>也许这就是初恋的宿命。因为其初，所以无猜投入，所以情动于衷，但却也因为其初，所以手足无措，所以茫然无助。小王子极为在乎玫瑰，是故对玫瑰一言一语如此敏感那么介怀，但却无法向玫瑰表达，不是因为没有勇气，而是他没有那样的人生经验去理解自己和体谅对方。两人彼此相爱，却不知道怎样相处，如何维系，遂不得不承受由爱而来的种种伤害和折磨。两人分手时，玫瑰伤心欲绝却没有挽留，只是和小王子说了两次“你要快快乐乐的”。为什么？她知道小王子不快乐，她想小王子快乐，但她又清楚她没有能力令小王子快乐，遂只能放手。</p>
<p>爱，需要热情，但也需要阅历，更需要对阅历的反思，从而更好地理解自己和理解生命。是故只有在曾经沧海之后（造访不同星球并见识不同的人），在众里寻她千百度之后（见过五千朵长得同样美丽的玫瑰），蓦然回首，小王子才能完完整整明白他对他的玫瑰是怎样一种感情。如果他不和玫瑰分手，不走过那段崎岖曲折却又充满启迪的路，他不可能对爱情有那样深刻的领悟。初恋的失败，是成长的分水岭。分手之后，人的整个心境遂截然不同。我们的一生，可以有许多许多次的恋爱，但初恋却只能有一次，其理在此。</p>
<p>当然，这是我从第三者的角度去理解小王子的决定。但小王子和玫瑰分手时，他自然不会这样想。他不可能对玫瑰说，因为我要更好地理解什么是爱，所以我必须离开。如果他真的这样想，他就已从这段关系中异化出去。我宁愿相信，小王子决定离开时，他其实没法好好地给出一个理由，因为他没有那样的人生框架去理解爱情。他不舍，他难过，却又自觉非走不可，因为他不懂如何面对爱恋中的自己，遂只能选择逃避和放逐。这也许正是大部份初恋如此美丽如此铭心却又如此脆弱如此无奈的原因。</p>
<p>话说回来，在我们的真实人生，小王子这一去，其实多是没有回头路，原因倒不是小王子没有办法回到他的星球和玫瑰重遇，而是即使重遇，由于两个人别后走上极为不同的人生路因而具有别样的心境，两个人的心遂很难一如当初那样相印。灯火䦨珊处站着的那人，往往是似近却极远，可望而不可即。是故大部份的初恋，只能怀念，不能回头。这是遗憾吗？也许是，也许不是。一如天上的白云飘过山峦，云影虽不能久留，交会的美好却可以长驻心间，直到远远。</p>
<p>转自《明报周刊》</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>《惶然录》-读书笔记</title>
    <url>/year/07/09/%E6%83%B6%E7%84%B6%E5%BD%95/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggklo0jciij30j206w0xn.jpg" alt="image-20200709121851605"></p>
<blockquote>
<p>我充当的这个人到底是谁？我身上到底有多少个人？我是谁？在我和我自己之间，究竟存在怎样的沟壑？</p>
</blockquote>
<a id="more"></a>

<ul>
<li>我的某一部分将与他们共存，失去他们的我，将与死无异。</li>
<li>如果抛弃这一身道拉多雷斯大街的套装，我将会穿上另一种什么样的套装？这是因为我也必须穿一点什么。</li>
<li>任何人在当前生活中的命运就是被剥削，那么我的问题只能是：被V先生及其纺织品公司剥削，是否就比被虚幻、荣耀、愤懑、嫉妒或者无望一类东西来剥削更糟糕？</li>
<li>我是一本还没有开始写作的长篇小说里的人物，我在自己还未存在之前翱翔长空，然后被取消；在自己还未存在之前一次次梦想，梦想一个人，而那个人从来就没有打算赋予我生命。</li>
<li>我总是思考，总是感受，但我的思想全无缘故，感觉全无根由。我正在一脚踩空，毫无方向地空空跌落，通过无限之域而落入无限。</li>
<li>没有创造这个世界的上帝，没有唯一的、创造万物的、不可能存在的上帝，来旋搅这黑暗中的黑暗。</li>
<li>像所有的悲剧一样，我人生的核心悲剧是一种命运的嘲弄。我反感生活，因为它是一种对囚犯的判决。我反感梦想，是反感逃脱行为的一种粗俗形式。是的，我生活在无比肮脏而且平常的真实生活里，也生活在无比激烈而且持久的梦幻化生活中。我像一个放风时醉酒的奴隶——两种痛苦同居于一具躯体。</li>
<li>真正的聪明人能从自己的躺椅里欣赏整个世界的壮景，无须同任何人说话，无须了解任何阅世之法，他仅仅需要知道如何运用自己的五种感官，还有一颗灵魂里纯粹的悲哀。</li>
<li>一个会计助理可以把自己想象成罗马国王，但英国国王不能，因为英国国王已经失去了把自己梦想成另一个国王的能力。他的现实限制了他的感觉。</li>
<li>一如我来到这里，我也将要离去——在阳光中衰老，在新的感觉中高兴，却在思想中悲伤。</li>
<li>我缓缓前行，如一个死人，一个视而不见的人，一个眼下什么也不是的人：他不过是一个人形动物，继承着希腊文化、罗马法规、基督教道德以及所有其他幻象，那些足以制造出我正在生活其中和感受其中的文明。</li>
<li>而生活将会是什么模样？</li>
<li>我持久的偏执之一，就是力图理解其他人的存在方式，以及他们的灵魂是如何不同于我，他们似乎独一无二的意识如何不同于我。</li>
<li>其他人也有灵魂。</li>
<li>昨天，他们告诉我，烟草店的帮手自杀了。我简直不能相信。可怜的小伙子，这么说他也是存在过的！我们，我们所有的人已经忘记了这一点。我们对他的了解，同那些完全不了解他的人的了解，竟然相差无几。我们明天会更加容易地忘记他。但确定无疑的一点，是他有一颗灵魂，一颗足以结束自己生命的灵魂。</li>
<li>是他有一颗灵魂，一颗足以结束自己生命的灵魂。</li>
<li>我总是相信，思想比生存更好。这是我的不幸，与其他所有的大不幸随行。</li>
<li>我所有的感觉都是疲倦，疲倦，完全的疲倦！</li>
<li>生活的一切不过是一个梦，没有人知道自己的所为，没有人知道自己的所愿，没有人知道自己的所知。作为命运永远的孩子，我们把自己的生活都睡掉了。</li>
<li>我经常有一种代理他人快乐的感觉，我并不存在。我一直是别的什么人，不动脑子地生活。</li>
<li>如果一个人今天想要感觉他昨天感觉过的事，这种感觉甚至是不可能的。因为那不是感觉，只是今天他对昨日感觉的回忆，是昨日生活消逝之后一具尚存的尸体。</li>
<li>只有穿上衣装的人，才能发现裸体的美丽。</li>
<li>我总是生活在当前。我对于未来一无所知，也不再有一个过去。未来以千万种可能性压迫着我，过去以虚无的现实压迫着我。我既没有对未来的希望，也没有对过去的向往。</li>
<li>我是灵魂停滞了。我受害于一种意志的悬置，与此同时，感情和思想却天天在持续。</li>
<li>在这些影子般的时间里，我不能思想、感受或者愿望。我设法写下来的东西，只有数字或者仅仅是笔的停顿。我一无所感，甚至我所爱之人的死亡，似乎也会远远离我而去，成为一件用外语发生的事件。我也一无所为，就像我在睡觉，我的语言、姿势以及举动，仅仅是一种表面的呼吸，是一些器官按部就班的本能。</li>
<li>我们把生活想象成什么样，它就是什么样。对于有一块园子的农民来说，园子就是他的一切，是他的帝国。恺撒有庞大帝国，仍嫌帝国狭窄，帝国就只是他的园子。小人物有一个帝国。大人物只有一个园子。除了我们的感觉以外，我们一无所有，这是他们的真实，却不能被他们领悟，而我们必须立足于自己生活的现实。 但所有这些都是虚无。</li>
<li>小人物有一个帝国。大人物只有一个园子。除了我们的感觉以外，我们一无所有，这是他们的真实，却不能被他们领悟，而我们必须立足于自己生活的现实。</li>
<li>踏着我梦想和疲惫的脚步，从你的虚幻中下坠，下坠，而且成为我在这个世界中的替身。</li>
<li>我们看到的，并不是我们所看到的，而是我们自己。</li>
<li>体面和忙碌的单调，是所有单调中最为糟糕的一种。</li>
<li>单调不是无所事事百无聊赖所带来的一种病，而是感到没有什么事情值得一做时，更为麻烦的一种病。因是之故，有更多的人不得不陷入更糟的单调。</li>
<li>一个人感到自己并不真正的存在，而只有灵魂是真正实体，描述这种感觉实在是太难了。我不知道有什么样的人类词语可以用来界定这种感觉。我不知道，我是真正像自己感觉的那样高烧，抑或最终是在生活那里显现于睡梦中的高烧。是的，我像一个旅行者，突然发现自己置身于一个陌生小镇，对自己如何来到这里茫然无知，我提醒自己是一个记忆缺失症患者，已经失去了对以往生活的记忆，长时间里活得像另外一个人。多年以来——从生下来而且成为一个意识性存在的时候开始——我一直是别的什么人，而现在我突然醒了过来，发现自己站在大桥的中端，眺望河水，比以往任何一刻都更确切地知道我存在着。但是，我不知道这个城镇，这些街道对于我来说十分新奇，而且玄秘如不治之症。</li>
<li>郁闷就是这样的东西：灵魂失去了哄骗自己的能力，失去了虚拟的思想通道——灵魂只有凭借这个通道，才可以坚定地登上真理之巅。</li>
<li>可以类分之物是无限的，因此也就是不可类分的。</li>
<li>我放弃自己在生活中寻找的一切，恰恰是因为我不得不将其寻找。我像一个狂乱的人追寻他在梦中找到过的东西，完全是因为忘却了那件东西准确的模样。以历历在目的手，近在眼前的手势——这只手以五根白皙的长长指头千真万确地存在——寻找，把事情翻来覆去，上下折腾，寻找就变得比我要寻找的东西更加真实起来。</li>
<li>当我写完了什么，自己总是惊异。惊异而且沮丧。我对完美的欲望，一直妨碍我写完任何东西，甚至妨碍我开始写作。但是，我忘记了这一点，我正在开始。</li>
<li>对于我来说，写作是对自己的轻贱，但我无法停止写作。写作像一种我憎恶然而一直戒不掉的毒品，一种我看不起然而一直赖以为生的恶习。有一些毒药是必要的，有一些非常轻微的毒药组成了灵魂的配方，诸多草药在残破之梦的角落里熬炙，黑色的罂粟在靠近坟墓的地方才能找到［……］长叶的卑污之树，在地狱里灵魂之河喧哗的两岸摇动它们的枝干。</li>
<li>是的，写作是失去我自己，但所有的人都会失落，因为生活中所有的事物都在失落。不过，不像河流进入河口是为了未知的诞生，我在失落自己的过程中没有感到喜悦，只是感到自己像被高高的海浪抛入沙滩上的浅池，浅池里的水被沙子吸干，再也不会回到大海。</li>
<li>一个人需要一种特定的知识勇气，去无所畏惧地承认，一个人不过是人类的一个碎片，一个活下来的流产儿，一个还没有疯到需要锁起来的疯子；但是，承认这一点之后，一个人甚至更需要精神的勇气，使自己完全适应他的命运，欣然接受，没有反叛，没有弃权，没有任何抗议动作或者试图表示抗议的动作。自然已经把基本的灾难降临于他。想要完全浑然不觉就是想要太多的痛苦，因为人性不愿意接受恶，只能承认它就是这么回事，并且把它称之为善，如果你把它当作一种恶来接受，除了受伤之外你别无出路。</li>
<li>自由是孤立的可能性。只有你离开了人们，感到无需为了钱，或者为了合群，或者为了爱情、光荣甚至好奇去追寻他们，你才能获得自由——那些事情没有哪一件可以得到宁静和寂寞的滋养。如果你不能一个人活着，你就是命定的奴隶。</li>
<li>我累了，关上我窗子的百叶板，为了自己的片刻自由而拒绝世界。明天，我将要回到一个奴隶的生存，但是现在，我独处一人，无需任何人，唯恐可怕的什么声音和什么人前来打搅，我有自己的小小自由，我得意的片刻。 坐在自己的椅子里，我忘记了如此压抑的生活。我仅有的痛感，是自己一度感觉过痛。</li>
<li>颓废”就是无意识的完全缺席，因为无意识是生命的重要基础，这种缺席就像心脏能够想象自己跳动的停止。</li>
<li>对于像我这样的人来说，对于少数像我这样视生若梦的人来说，除了把放弃当作一种生活方式，除了把沉思当作命运，还能有什么？无视宗教生活的意义，也不能通过理性来发现意义，对抽象概念的人无法建立信念，甚至不知道如何处理这件事，我们所能保留的全部，作为一位灵魂拥有者的正当证明，只有对于生活的美学沉思。这样，对世界的庄严性麻木不仁，对人类的神圣和卑贱无所区别，我们把自己虚妄地交给了茫然的感觉主义，再交织享乐主义的一种精致形式，以适应大脑皮层的神经。</li>
<li>有关我的一切都正在消失。我的整个生活，我的记忆，我的想象及其内涵，我的个性，一切都正在消失。我持续地感觉到自己是另外一个人，就是说，我像另外一个人那样感觉和思考。我在一出戏剧里出演于不同的场景，而正在观看这一出戏的就是我。</li>
<li>一个是我的人，在另一种生活中感受它们，而我现在从这种生活里苏醒，就像从另一个人的梦里醒来。</li>
<li>我怎样才能在今天知道我在昨天所不可知道的自己？</li>
<li>我充当的这个人到底是谁？我身上到底有多少个人？我是谁？在我和我自己之间，究竟存在怎样的沟壑？</li>
<li>我感觉到，如果没有一盏灯在那里闪亮，我在这一刻也不会存在（或者至少可以说，不会以这种确切的方式存在，因为自己临场的存在是一种意识，是一种对在场物的意识，在这一刻，便是观灯者的我）。而如果没有我的存在，那一所灯光闪烁的房子也不能呈现任何意义，徒有其高而已。</li>
</ul>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>我只是讨厌屈服</title>
    <url>/year/12/26/%E6%88%91%E5%8F%AA%E6%98%AF%E8%AE%A8%E5%8E%8C%E5%B1%88%E6%9C%8D/</url>
    <content><![CDATA[<blockquote>
<p>“在强大的力量面前人们往往除了服从别无选择，但是我不愿意。”他说。“我要把他们拖上战场，我不一定能赢，但我会让他们觉得痛，让他们害怕有十几二十几个象我这样的人站出来，让他们因为害怕而迅速地改变。”</p>
</blockquote>
<a id="more"></a>

<p>10：03，北京市第一中级人民法院。</p>
<p>郝劲松坐在原告的位子上开口说话，“审判长，通知我的开庭时间是10：00，被告迟到，我是否能得到合理解释？”<br>审判长看他一眼，说“现在你先听从法庭的程序”，冲书记员挥了下手。</p>
<p>书记员立刻跑出去大声叫“北京地铁公司！北京地铁公司！”</p>
<p>片刻，两位男士夹着公文包，匆匆入门，在被告席上落座。</p>
<p>原被告双方目光交汇的一刹那，法庭非常安静。我明白了郝劲松为什么说“不管你有多强大，包括一个国家部委，当你被告上法庭的时候，你是被告，我是原告，大家坐在对面，中间是法官。你和我是平等的”</p>
<p>这是一场关于五角钱的官司，他在地铁使用了收费厕所，认为这收五角钱不合理。所以把北京地铁公司告上法庭。</p>
<p>两年多，他打了7场这样的官司—他在火车餐车上买一瓶水，要发票。</p>
<p>列车员都笑了“火车自古没有发票”。</p>
<p>他于是起诉铁道部，国家税务总局，。。。一次一次。</p>
<p>“在强大的力量面前人们往往除了服从别无选择，但是我不愿意。”他说。“我要把他们拖上战场，我不一定能赢，但我会让他们觉得痛，让他们害怕有十几二十几个象我这样的人站出来，让他们因为害怕而迅速地改变。”</p>
<p>“钱数这么小，很多人觉得失去它并不可惜”我说。</p>
<p>“今天你可以失去获得它的权利，你不抗争，明天你同样会失去更多的权利，人身权，财产权，包括土地、房屋。中国现在这种状况不是偶然造成的，而是长期的温水煮青蛙的一个结果，大家会觉得农民的土地被侵占了与我何干？火车不开发票，偷漏税与我何干？别人的房屋被强行拆迁与我何干？有一天，这些事情都会落在你的身上。”</p>
<p>“但是一个人的力量能改变什么呢？”</p>
<p>“看看罗莎，帕克斯,整个世界为之改变”他说。</p>
<p>帕克斯是美国的一个黑人女裁缝，1955年12月1日，在蒙哥马利市，42岁的她在一辆公共汽车上就座。按照当时的惯例，美国南部公共汽车上实行种族隔离，座位分为前后两部分，白人坐前排，黑人坐后排。</p>
<p>那天晚上人很挤，白人座位已占满，有白人男子要求坐在黑人部分最前排的她让座，遭到了拒绝。</p>
<p>当司机要求乃至以叫警察恐吓黑人让座时，坐在前排的其它三个黑人站了起来，唯独帕克斯倔强地牢坐不起。</p>
<p>如果是一个孩子或是老人，也许她会站起来，但这次，她厌烦了她和其它美国黑人每天在生活中所受到的不公平对待，</p>
<p>她说：“我只是讨厌屈服”。<br>她成了50年代美国第一个拒绝给白人让座的黑人。然后她因公然藐视白人而遭逮捕。<br>她的被捕引发了蒙哥马利市长达381天的黑人抵制公交车运动，组织者是当时仍名不见经传的一名牧师马丁·路德·金，这个名字后来被冠以反种族隔离斗士和诺贝尔和平奖得主的荣誉。这场运动的结果，是1956年最高法院裁决禁止公车上的“黑白隔离”，帕克斯从此被尊为美国“民权运动之母”。</p>
<p>事实上，她并没有组织或领导50年前那场民权运动，她只是在适当的时刻表现了一个平凡人的勇气，而这种勇气迫使整个国家重新审视并改变了原有的社会道德体系。</p>
<p>五十年后，美国国务卿赖斯说“没有她，我不可能站在这里”</p>
<p>“你以谁的名义在诉讼？”我问郝劲松。</p>
<p>“公民。”</p>
<p>“公民和普通人的区别是什么？”</p>
<p>“能独立地表达自己的观点，却不傲慢，对政治表示服从，却不卑躬屈膝。能积极的参与国家的政策，看到弱者知道同情，看到邪恶知道愤怒，这我认为他才算是一个真正的公民。”</p>
<p>他打赢铁路发票的官司后，很多人以为他会和铁路结下梁子。</p>
<p>但他说起他乘车时，乘务长会亲自端来饭菜，问他“发票你现在要还是吃完再说？”</p>
<p>呵呵。</p>
<p>“你靠什么赢得尊重？”我问。<br>“靠我为了自己权利所做的斗争。权利是用来伸张的，否则权利只是一张纸。”他说。　</p>
<p>我停顿了一下，问他最后一个问题“你想要一个什么样的世界？”<br>这个34岁的年青人说，“我想要宪法赋予我的那个世界。”</p>
<p>原文：戳<a href="http://blog.sina.com.cn/s/blog_48b0d37b010002bl.html" target="_blank" rel="noopener">这里</a></p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>未来简史摘抄</title>
    <url>/year/12/06/%E6%9C%AA%E6%9D%A5%E7%AE%80%E5%8F%B2%E6%91%98%E6%8A%84/</url>
    <content><![CDATA[<ul>
<li><p>我们已经成功遏制了饥荒、瘟疫和战争。</p>
</li>
<li><p>灾难发生的次数及频率确实都在下降。因营养过剩而死亡的人数超过因营养不良而死亡的人数，因年老而死亡的人数超过因传染病死亡者，自杀身亡的人数甚至超过被士兵、恐怖分子和犯罪分子杀害的人数的总和，这</p>
</li>
</ul>
<a id="more"></a>

<ul>
<li><p>过去想到和平，只是“暂时没有战争”；而现在想到和平，是指“难以想象会有战争”。</p>
</li>
<li><p>纵观历史，人类总认为这些问题无法解决，于是根本不去试着解决，只是向神祈求奇迹，自己却从未认真努力消灭饥荒、瘟疫和战争。</p>
</li>
<li><p>认可人类过去的努力，其实传达出了希望和责任的信息，鼓励我们在未来更加努力。鉴于人类在20世纪的成就，如果以后人类仍然遭受饥荒、瘟疫和战争之苦，就不能再怪在自然或上帝的头上了。我们已有能力把事情做得更好，并减少未来受苦的概率。</p>
</li>
<li><p>接下来的目标很可能是长生不死、幸福快乐，以及化身为神。</p>
</li>
<li><p>想象一下，如果没了死亡，世界就会变得没有天堂、没有地狱，也没有轮回，那么基督教、伊斯兰教或印度教该如何自处？</p>
</li>
<li><p>对现代人来说，死亡是一个我们能够也应该解决的技术问题。</p>
</li>
<li><p>人类会死亡只有一个原因：人体运行出了点儿技术问题，比如心脏不跳、大动脉被脂</p>
</li>
<li><p>只要是技术问题，就会有技术上的解决方案。要克服死亡，并不需要等到耶稣再次降临，只要实验室里的几个科技专家就够了。</p>
</li>
<li><p>现在只要一出现死亡，诉讼和调查几乎就会自动随之而来。“他们怎么会死？一定是哪里有人做错了！”</p>
</li>
<li><p>绝大多数科学家、医生和学者并不会说自己正在努力实现让人长生不死的梦想，只会说自己正在努力解决这个或那个特定问题。但因为衰老和死亡不过是许多特定问题的总和，</p>
</li>
</ul>
<ul>
<li>我认为，处理（死亡）的方式大概有三种：接受死亡、拒绝死亡、对抗死亡。我觉得社会上大多数人不是拒绝就是接受，而我宁愿和它对抗</li>
</ul>
<ul>
<li><p>人类不再平等，不死就在眼前。</p>
</li>
<li><p>人人享有生命权 悖论</p>
</li>
<li><p>事实上，他们只是达到长生（a-mortal），而不是真正不死（immortal）。</p>
</li>
<li><p>科学在一次一次的葬礼中进步。他所说的是，必须等到一个世代离去，新的理论才有机会铲除旧的理论</p>
</li>
<li><p>我们的意识形态看重人类的生命，绝不允许我们轻易接受人类死亡。只要人是出于某种原因而死，我们就会努力战胜这种原因。</p>
</li>
<li><p>幸福快乐的权利</p>
</li>
<li><p>生命的唯一目的就是享乐。</p>
</li>
<li><p>所谓至善就是“为最多人带来最大的快乐”，并认为国家、市场和科学界唯一值得追寻的目标就是提升全球的快乐。</p>
</li>
<li><p>幸福快乐的玻璃天花板有两大支柱，分别属于心理与生物层面。在心理层面，快乐与否要看你的期望如何，而非客观条件。仅有和平繁荣的生活，并不能让我们满意；现实必须符合期望，才能让我们满足。但坏消息是，随着客观条件改善，期望也会不断膨胀。于是，虽然人类近几十年来的客观生活条件大幅改善，但带来的并不是更大的满足，而是更大的期望。如果我们不做些什么，未来不论达到什么成就，可能我们还是会像当初一样，永远不会真正满足。</p>
</li>
<li><p>我们之所以感到幸福，是因为我们感受到愉悦的感觉，而且并未接触到不快的感觉。</p>
</li>
<li><p>根据生命科学的说法，快乐和痛苦只不过是身体各种感觉的总和。愉悦或痛苦从来就不是对外在世界事件的反应，而是对自己体内感觉的反应。</p>
</li>
<li><p>愉悦的感觉很快就会消退，迟早会转变成不愉快的感觉。就算踢进了世界杯决赛的制胜一球，也无法保证一生都幸福。</p>
</li>
<li><p>愉悦的感觉很快就会消退，迟早会转变成不愉快的感觉。就算踢进了世界杯决赛的制胜一球，也无法保证一生都幸福。</p>
</li>
<li><p>这些都是进化的错。历经无数代人之后，我们的生化系统不断适应变化，为的是增加生存和繁衍的机会，而不是快乐幸福的机会。只要是有利于生存和繁衍的行为，生化系统就会用愉悦的感觉来回应。但这不过是一时的营销伎俩罢了。我们努力取得食物、追求伴侣，就是想避免饥饿带来的不愉悦感觉，并且享受进食的愉悦、性爱的高潮。但无论进食还是性爱，这种愉悦都无法长时间维持，想要再次感受，就只能去寻找更多的食物和伴侣。</p>
</li>
<li><p>这些都是进化的错。历经无数代人之后，我们的生化系统不断适应变化，为的是增加生存和繁衍的机会，而不是快乐幸福的机会。只要是有利于生存和繁衍的行为，生化系统就会用愉悦的感觉来回应。但这不过是一时的营销伎俩罢了。我们努力取得食物、追求伴侣，就是想避免饥饿带来的不愉悦感觉，并且享受进食的愉悦、性爱的高潮。但无论进食还是性爱，这种愉悦都无法长时间维持，想要再次感受，就只能去寻找更多的食物和伴侣。</p>
</li>
<li><p>人类只要一有重大突破，就不可能只用于治疗而不用于进化升级。</p>
</li>
<li><p>未来的经济、社会和政治，将会由“试图战胜死亡”所塑造，但并不代表人类必然能在2100年做到不死。</p>
</li>
<li><p>知识如果不能改变行为，就没有用处。但知识一旦改变了行为，本身就立刻失去意义。我们拥有越多数据，对历史了解越深入，历史的轨迹就改变得越快，我们的知识也过时得越快。</p>
</li>
<li><p>历史学家研究过去不是为了重复过去，而是为了从中获得解放。</p>
</li>
<li><p>快乐和神性。但只要一接近达成这些目</p>
</li>
<li><p>不死、快乐和神性。</p>
</li>
<li><p>图10 亚述国王亚述巴尼拔（Ashurbanipal）杀狮：掌控动物界 第一部分 智人征服世界 人类与其他动物有何不同？ 人类如何征服世界？ 智人究竟是比较高等的生命形式，还是欺凌其他物种的地痞流氓？</p>
</li>
<li><p>对于被驯化的物种来说，物种整体取得了无与伦比的成功，但物种个体却遭到前所未有的苦难。虽然动物界几百万年来也经历过各种痛苦磨难，但农业革命带来的是全新的苦难，而且随着时间推移只会变得更糟。</p>
</li>
<li><p>要说家畜命运特别悲惨，重点不在于它们死的方式，而是它们活的方式。</p>
</li>
<li><p>家畜仍然保留着野生动物的种种生理、情感和社交需求，</p>
</li>
<li><p>家畜仍然保留着野生动物的种种生理、情感和社交需求，但这对人类的农场来说毫无意义。</p>
</li>
<li><p>这种做法岂不是违反了自然选择最基本的原则？进化论认为，所有本能、冲动、情感的进化都只有一个目的：生存和繁衍。如果是这样，看到家畜这样生生不息，岂不是证明所有需求都得到了满足？猪真的有生存和繁衍之外的“需求”吗？</p>
</li>
<li><p>母猪生存和繁衍的一切需要都由人类提供，包括足够的食物、抵抗疾病的疫苗、遮风避雨的住处，另外还有人工授精。客观来看，母猪再也不需要探索周围的环境、与其他猪社交、与小猪有任何情感联结，甚至连走路都没有必要。但从主观而言，母猪仍然会对这一切拥有极强烈的欲望，无法满足则痛苦万分。被锁在母猪栏里的母猪，通常都会出现严重的挫折或绝望症状。</p>
</li>
<li><p>了解什么是算法，以及算法与情感有什么关系。</p>
</li>
<li><p>算法指的是进行计算、解决问题、做出决定的一套有条理的步骤。</p>
</li>
<li><p>农业革命促成了有神论宗教，而科技革命则催生了人文主义宗教：以人取代了神。有神论者崇拜的是神，人文主义者则是崇拜人。人文主义的奠基概念认为智人拥有某些独特而神圣的本质，这些本质是宇宙间所有意义和权力的来源。宇宙间发生的所有事，都会以“对智人的影响”作为判断好坏的依据。</p>
</li>
<li><p>相对论不会让什么人生气，是因为它并不抵触我们宝贵的信仰。空间和时间究竟是绝对的还是相对的，大多数人压根儿就不在乎。如果你说空间和时间可以弯曲，好啊，请自便。弯就弯吧，关我什么事呢？但相较之下，达尔文却会让我们失去灵魂。</p>
</li>
<li><p>从字面来看，英文的“individual”（个体、个人）指的就是无法（in-）再分割（divide）的东西。于是，说自己是个“in-dividual”，也就是说我是个完整的个体，而不是由几个独立部分形成的集合。据说这种不可分割的本质就算随着时间过去，也能不增不减、保持原样。我的身体和大脑会不断变化，比如神经元会放电、激素会分泌、肌肉会收缩；我的性格、期望和关系从来不会静止不变，几年或几十年后很有可能完全不同。然而，在一切的最深处，我从出生到死亡都是同一个人，而且我希望能超越死亡。</p>
</li>
<li><p>灵魂是个有人相信、有人不相信的故事。但意识流则相反，这是我们每分每秒都能直接观察到的具体现实，再明确也不过，无法怀疑它的存在。也许我们会充满怀疑地自问：“真的有主观体验这种事吗？”即便如此，我们也能百分百确定自己正在经历着怀疑。</p>
</li>
<li><p>主观体验有两个基本特征：感觉和欲望。</p>
</li>
<li><p>那么，动物呢？它们有意识吗？它们有主观体验吗？如果逼一匹马工作，直到它精疲力竭而崩溃，有没有问题？前面已经提过，目前生命科学认为，所有哺乳动物和鸟类以及至少某些爬行动物和鱼类，都具有感觉和情感。但也有最新理论认为，感觉和情感只是生化数据处理算法。既然机器人和计算机处理数据的时候不会有任何主观体验，也许动物也是一样？事实上，我们知道就算是人类，也有许多感觉和情感的大脑回路是在人类完全无意识的情况下处理数据的。所以，或许我们以为动物会有的感觉和情感（像饥饿、恐惧、爱、忠诚）都是无意识的算法，而不是主观体验？2</p>
</li>
<li><p>目前的正统科学认为，意识是由大脑中的电化学反应产生的，而这样的心理体验能够完成某些重要的数据处理功能。3然而，大脑里的各种生化反应和电流是怎么创造出痛苦、愤怒或爱等主观体验的，至今仍无解答。</p>
</li>
<li><p>事实上，科学家已经可以用电流刺激相应的神经元，诱发出愤怒或爱情的感觉</p>
</li>
<li><p>又或许，我们需要有主观体验，才能够反观自我？在大草原上游荡、计算自己生存和繁衍机会的动物，必须想象出自己的行动和决定，而且有时也要将这种想象传达给其他动物。如果大脑要设想出一个自己如何决策的模型，就会被困在无限的循环中，开始胡言乱语！而跳出这个循环，出现的就是意识。</p>
</li>
<li><p>毕竟，没有人曾经用显微镜看到过所谓痛苦和爱情的体验，而</p>
</li>
<li><p>或许，“心灵”的概念也会像灵魂、神和以太一样，被丢进科学的垃圾堆？毕竟，没有人曾经用显微镜看到过所谓痛苦和爱情的体验，而且我们对于痛苦和爱情已经有非常详细的生化解释，不再有主观体验的空间。然而，心灵与灵魂（以及心灵与神）之间仍然有个关键的差异。说有永恒存在的灵魂，完全是个臆测；但对于痛苦的体验，则是非常直接而具体的现实。</p>
</li>
<li><p>历史已经提供充分证据，点出大规模合作的极端重要性。胜利几乎永远属于合作更顺畅的一方；这不只适用于人与动物的争斗，也适用于人与人之间的冲突。因此，罗马之所以征服希腊，不是因为罗马人的脑子更大或制造工具的技术更先进，而是因为他们的合作更有效。</p>
</li>
<li><p>以黑猩猩为例，它们一定要等到互相熟识、建立起社会阶级之后，才有可能一起去猎食。因此，黑猩猩要花很多时间进行社会互动、权力斗争。如果两只不认识的黑猩猩碰到一起，通常不但不能合作，反而会互相咆哮、扭打或是尽快逃离。 但倭黑猩猩则有些不同。倭黑猩猩常常用性行为来舒解压力，建立社会联结。所以并不意外，它们之间同性性行为也是稀松平常。如果两群互不相识的倭黑猩猩碰到一起，一开始会先表现出恐惧和敌意，丛林里吼叫和尖叫声不绝于耳。但很快，其中一群的雌性倭黑猩猩会走出来，邀请陌生的倭黑猩猩别打了，来做爱吧。通常另一方都会接受这项邀请，于是不到几分钟，原本可能的战场就成了欢场，倭黑猩猩用各种姿势性交，甚至还会倒吊在树上。</p>
</li>
<li><p>不管人类靠什么打造出了大规模合作网络，总之绝不是仅靠个人熟识而已。</p>
</li>
<li><p>因为如果在石器时代，温和接受一切要求就只能等死。</p>
</li>
<li><p>最后通牒博弈</p>
</li>
<li><p>事实上，大多数人生活的意义，都只存在于彼此讲述的故事之中。</p>
</li>
<li><p>评价任何人类网络的历史时，建议可以经常暂停一下，改用真实实体的观点来看待事物。怎么知道某个实体是否真实？答案很简单，只要问问自己“它是否会感觉痛苦”就行了</p>
</li>
<li><p>宗教的定义应该在于其社会功能，而不在于神是否存在。任何无所不包的故事，只要能够为人类的法律、规范和价值观赋予高于一般人的合法性，就应该算是宗教。宗教能够为人类社会结构找的理由，就是这些结构反映了高于一般人的法则。</p>
</li>
<li><p>科学能够解开一切的道德困境。哈里斯认为，所有人的终极价值都是相同的——将痛苦最小化、快乐最大化，因此，所有的伦理争论都是关于“如何将快乐最大化”的事实论证。</p>
</li>
<li><p>哈里斯认为，所有人的终极价值都是相同的——将痛苦最小化、快乐最大化，因此，所有的伦理争论都是关于“如何将快乐最大化”的事实论证。</p>
</li>
<li><p>“现代性”就是一项交易，所有人都在出生的那天签了契约，从此规范了我们的生活，直到死亡。很少有人能够撤销或超越这份契约，这份契约决定了我们吃什么、做什么、想什么，也决定了我们住在哪里、爱什么人，甚至如何死亡。</p>
</li>
<li><p>“现代性”就是一项交易，所有人都在出生的那天签了契约，从此规范了我们的生活，直到死亡。很少有人能够撤销或超越这份契约，这份契约决定了我们吃什么、做什么、想什么，也决定了我们住在哪里、爱什么人，甚至如何死亡。 这份契约乍看之下非常复杂，于是很少有人会去了解自己究竟签了什么。这就像下载某个软件后，有一份使用同意书，里面有几十页的法律术语，可是你只瞄了一眼，就立刻向下滚到最后一页，勾选“我同意”，接着完全忘了这件事。但事实上，这份契约简单到不可思议，只要一句话就能总结——人类同意放弃意义、换取力量。</p>
</li>
<li><p>在台上得意或失意了一会儿，就再也悄无声息。</p>
</li>
<li><p>某位任职于高科技新创公司的软件工程师，时薪100美元。某天，她的父亲不幸中风，需要有人协助买东西、做饭甚至洗澡。她可以让父亲搬过来和自己住，她一早去上班，晚上再早点回来，亲自照顾父亲。不管是她的收入还是新创公司的生产力都会因此受到影响，但她的父亲却能享有女儿充满爱和尊重的照顾。这位工程师也能请位墨西哥护工，时薪12美元，和父亲住在一起，照顾其所有需求。这样一来，工程师、她任职的新创公司，甚至是这位护工和墨西哥的经济都将受益。那么，这位工程师该怎么选择？</p>
</li>
<li><p>“爱你的邻居”和“把另一边的脸也转过去让人打”的效果。</p>
</li>
<li><p>穷人怎么了？他们为什么不抗议？如果洪水真的来临，穷人将付出所有代价；然而，如果经济停滞，穷人也首当其冲。在资本主义世界里，穷人的生活唯有在经济增长时才可能改善。因此，如果一定要放慢当下的经济增长速度，以减少未来的生态威胁，并不太可能得到他们的支持。保护环境是个很好的主意，但如果有人连房租都交不出来，对于没钱的恐惧就会远远高过对冰层融化的担心。</p>
</li>
<li><p>现代世界就是“永远的不安定和变动”</p>
</li>
<li><p>各种固定的关系和古老的偏见都遭到扫除，而新的结构等不到固定便已经陈旧，一切固定的东西都烟消云散。在这样混乱的世界中，生活本已不易，管理则更是难上加难。 因此，现代性要求我们更加努力，以确保人类不论是个人还是整体都不想退出这场竞赛（虽然这场竞赛正是所有紧张和混乱的源头）。为此，现代性继续高举增长的旗帜作为其最高价值，要求我们为此要冒一切危险、做出一切牺牲。就整体而言，现代社会鼓励政府、企业和组织以实现增长作为成功的标准，并将稳定视为洪水猛兽；就个人而言，现代性要求我们不断提高收入和生活水平，就算目前的生活已经令自己相当满意，我们还是应该努力争取更多。昨天的奢侈品成了今天的必需品。曾经，一套三居室的公寓、一辆车，加上一部台式电脑就已经能让你相当满意；现在，你会想拥有一套五居室的独栋住宅，车库里有两辆车，再加上许多的iPod（苹果公司开发的系列便携式数字多媒体播放器）、平板电脑和智能手机。</p>
</li>
<li><p>为了换取力量，这份契约要求我们放弃意义。</p>
</li>
<li><p>在一个没有神、没有天堂、没有地狱的世界上，道德、美丽甚至是同理心，是如何保存下来而且发展蓬勃的呢？</p>
</li>
<li><p>现代契约给了人类力量，但条件是我们不再相信整个世界有一个伟大的宇宙计划能让生命有意义。然而，如果细查契约条款，会发现有一条赖皮的例外条款。如果人类不用通过伟大的宇宙计划也能找到意义，就不算违背契约。</p>
</li>
<li><p>根据人文主义的观点，人类必须从自己的内在体验找出意义，而且不仅是自己的意义，更是整个宇宙的意义。这是人文主义的主要训诫：为无意义的世界创造意义。</p>
</li>
<li><p>人的感受才是一切意义和权威的源头</p>
</li>
<li><p>知识=体验×敏感性。</p>
</li>
<li><p>体验和敏感性会形成一个彼此加强的无限循环。没有敏感性，就无法体验任何事物；没有体验各种事物，就无法培养敏感性。敏感性并不是能够靠读书或听演讲来培养的抽象能力，而是一个实践技巧，必须在实践中慢慢成熟。</p>
</li>
<li><p>没有必要的敏感性，就无法体验到某些事物；没有长期的体验，就无法培养敏感性。</p>
</li>
<li><p>人文主义认为生命就是一种内在的渐进变化过程，靠着经验，让人从无知走向启蒙。人文主义生活的最高目标，就是通过各式智力、情绪及身体体验，充分发展人的知识。19世纪初，建构现代教育系统的重要人物威廉·冯·洪堡（Wilhelm von Humboldt）曾说，存在的目的就是“在生命最广泛的体验中，提炼出智慧”。他还写道：“生命只有一座要征服的高峰——设法体验一切身为人的感觉。”4这正可作为人文主义的座右铭。</p>
</li>
<li><p>人类史上，从没有任何文化如此重视人类的感受、欲望和体验。人文主义将生命看作一连串的体验，于是这个神话便为从旅游到艺术等许多现代工业奠定了基础。旅行社和餐厅真正卖的不是机票，也不是什么高档晚餐，而是新奇的体验。</p>
</li>
<li><p>有些人认为，讲到现代关注内心生命而非外在行为，乔伊斯的《尤利西斯》正是巅峰之作。</p>
</li>
<li><p>《尤利西斯》</p>
</li>
<li><p>要变得敏感、聪明、勇敢，从来就不需要什么巫师的魔法，只要继续沿着黄砖路走下去，敞开心胸迎接任何体验。</p>
</li>
<li><p>“知识=体验×敏感性”这个公式不仅改变了我们的流行文化，甚至改变了我们对某些重量级议题的看法，</p>
</li>
<li><p>他们对自己和世界都所知甚少，却背负了希望和假象的沉重负担</p>
</li>
<li><p>人文主义主要有三大分支。第一是正统派，认为每个人都是独特的，拥有独一无二的内在声音、永不重复的一连串体验。每个人都像一道不同的光线，从不同的角度照亮世界，为这个宇宙增添色彩、深度和意义。因此，我们应该让每个人都尽量自由自在地体验世界、听从自己内心的声音、表达自己心中真实的想法。不管在政治、经济或艺术中，个人的自由意志都应该比国家利益或宗教原则更为重要。个人能享有的自由越多，整个世界就会变得越美丽、丰富、有意义。由于这种正统派强调自由，也就称为“自由人文主义”（liberal humanism），或简称“自由主义”（liberalism）。[3]</p>
</li>
<li><p>人类的体验是意义和权威的本源</p>
</li>
<li><p>我当下的政治观点、喜好与厌恶、兴趣和抱负，都没有反映真实的自我，只是反映了我的成长和社会环境，这都是由我的阶级、邻里和教育决定的。无论富有还是贫穷，人都是从一出生就被洗脑。富人被教导要无视穷人，而穷人则被教导要无视自己真正的兴趣。再多的自我反思或心理治疗，也不可能有所帮助，因为心理治疗师也是为了资本主义制度而工作。</p>
</li>
<li><p>无论富有还是贫穷，人都是从一出生就被洗脑。富人被教导要无视穷人，而穷人则被教导要无视自己真正的兴趣。再多的自我反思或心理治疗，也不可能有所帮助，因为心理治疗师也是为了资本主义制度而工作。</p>
</li>
<li><p>如果我说自己之所以抑郁，可能是因为遭到资本家剥削，并在主流社会制度下无法实现自己的目标，这位治疗师很可能就会认为，我只是把自己内心的困难投射到整个“社会制度”，以及把自己和母亲之间未解</p>
</li>
<li><p>抑郁，可能是因为遭到资本家剥削，并在主流社会制度下无法实现自己的目标</p>
</li>
<li><p>在主流社会制度下无法实现自己的目标</p>
</li>
<li><p>你有没有想过，虽然战争这么恐怖，至少还算是件大事？我是说，在战争里，人得面对现实。和平的时候，全世界大概有九成的人，过的大概都是邪恶而商业化的生活，愚蠢、自私、豪奢、执着于鸡毛蒜皮的小事。但到了战时，一切都变得野蛮，但至少更诚实，也更直接。换个角度来看：和平的时候，每个人过的只是自己的小日子，做些琐碎小事，担心自己是不是舒服、钱够不够用这种事，一切只是为自己活着。这种生活也太恶心了吧！但在战时，就算你确实被杀了（人本来就只能多活几年，难免一死），却能确切知道，自己的死是为了自己的国家。事实上，你完成了一个理想。在我看来，这在日常生活里很少能够做到。因为日常生活的基础是商业化和自私。如果你也想“有点成就”，就不可能袖手旁观。 就我个人而言，常常很高兴自己碰上了战争。这让我意识到，生命真是一件小事。我认为战争让每个人都有机会“跳出自己”，大概可以这么说吧……确实，我敢说自己一辈子从没这么激动和兴奋过，简直就像看着一场大型特技秀要开场，就像去年4月那样。我在过去大约半小时里感觉到的兴奋，实在不是这个世上任何事情能比的。</p>
</li>
<li><p>很难描述他的感觉……就像忽然顿悟。接近死亡，反而让他感到前所未有地活着。过去在生命里，他也曾经有过那么几秒的时间，感觉死亡擦身而过，就像曾有辆狂飙的车忽然急转弯，差那么一点儿就要把他撞个正着。而在那天，他就一直活在那种感觉里，死亡就在他面前呼吸……一刻、一刻，又一刻，时间有三小时以上……战斗就是……一种心理和身体意识全开的状态。在街上的那些时候，他不是肖恩·尼尔森，他没有与什么更大的世界相连，没有账单要付，没有情感联结，什么都没有。他只是一个人，要从这一纳秒活到下一纳秒，从这口气活到下一口气，清楚知道这可能是自己的最后一纳秒、最后一口气。他觉得自己永远不一样了。10</p>
</li>
<li><p>终于，我的意志成了无可争议的主人……现在感到平静而坚定，而且这种感觉持久不衰。现在就算命运带来终极的种种考验，也无法击溃我的精神或打破我的理性。</p>
</li>
<li><p>他在战壕里学到的，是在任何大学、企业总部或政府部门永远学不到的东西。人们跟随他、投票支持他，是因为认同了他的想法，也认为这个世界是个丛林，杀不死我们的，只会让我们更强大。</p>
</li>
<li><p>在社会主义看来，自由主义就像亚当的那片无花果树叶，是在为整个无情、剥削、种族歧视的制度遮羞。高举着“自由”的大旗，在意的其实却是“财富”。说着要让个体有权去做自己感觉良好的事，最后却多半演变成要保护中上阶层的财富和特权。如果连房租都付不起，还谈什么居住自由？如果连学费都付不起，又有什么学习自由？如果连车都买不起，旅行的自由又有什么意义？一则著名的嘲讽笑话就说，在自由主义之下，每个人都有饿死的自由。而更糟的是，自由主义鼓励每个人把自己视为独立的个体，于是同一阶级的成员各自独立，无法团结起来对抗压迫他们的制度。于是，自由主义让不平等永无止境，使大众走向贫困，让精英走向孤立。</p>
</li>
<li><p>在种族主义和法西斯主义眼中，自由主义妨碍了自然选择，造成人类退化。他们提出警告，如果认定所有人价值相同、生育机会相同，自然选择就无法运作。身为最适者的那些人无法继续进化成超人，只能被大批平庸的人淹没，人类终将灭绝。</p>
</li>
<li><p>如果出现许多在经济上完全没有用处的人，形成一个庞大的新阶级，会造成怎样的政治冲击？如果在纳米科技和再生医学的力量下，未来的80岁就像现在的50岁，对于人际关系、家庭和退休基金又有何影响？如果生物科技让我们能够定做婴儿，并让贫富之间出现前所未见的巨大鸿沟，人类社会又将如何？</p>
</li>
<li><p>我之所以觉得脑中浮起某个愿望，是因为大脑里某种生化过程创造出的感觉。</p>
</li>
<li><p>这些大鼠并不觉得受人控制，也不觉得做了什么违背自己意志的事。塔瓦尔教授按下遥控器，是让大鼠自己想要往左走，于是它就往左走。教授按另一个开关，是让大鼠想要爬梯子，于是它就爬了梯子。毕竟，欲望也只是神经元的某种放电模式而已。至于神经元放电的原因，究竟是其他神经元的刺激或塔瓦尔教授遥控器控制电极的刺激，真有那么重要吗？如果你去问问那只大鼠，它可能会告诉你：“我当然有自由意志啊！你看，是我想要左转，所以就左转了。是我想爬梯子，所以就爬了。这不就证明了我有自由意志吗？”</p>
</li>
<li><p>这场实验让埃迪的生命大为改观。接下来几天里，她意识到自己经历了一场“近乎灵性的体验……不是觉得更聪明或是学得更快，真正让我好像脚下忽然一空的，是我这辈子第一次觉得大脑里忽然一片安静……没有任何自我怀疑，仿佛看到一个新世界。脑中忽然静得叫人难以置信……我希望你会懂，在那次测验后的几个星期里，我心里最想做的事情，就是再回去，把电极再接回去。我也开始冒出许多疑问。平常，在我脑中总像有许多愤愤不平的小人，占满了我的心思，让我害怕尝试，最后导致失败。但除了这些声音之外，我究竟是谁？这些声音又是从哪里来的？”7</p>
</li>
<li><p>这些声音有些是重复社会的偏见，有些是附和我们个人的历史，也有些传达出我们的基因传承。埃迪认为，这一切创造出一个看不见的故事，在不知不觉中塑造着我们有意识做出的决定。如果我们可以重写这些内心独白，甚至叫它们完全噤声，会发生什么事？8</p>
</li>
<li><p>大多数人认同的都是自己的叙事自我。我们口中的“我”，讲的是我们脑中的故事，而不是身体持续感觉到的当下体验。我们认同的是自己内心的系统，想从生活的各种疯狂混乱中理出道理，编织出一个看来合理而一致的故事。不管情节是否充满谎言和漏洞，也不管故事是否因为一再重写而总是自打嘴巴，一切都不要紧。重要的是，我们总是觉得自己从出生到死亡（甚至死后）都有一个单一、不变的身份。就是这种感觉，塑造出大有问题的自由主义信念，误认为自己不可分割，内心有个清楚而一致的声音，而且能为整个宇宙提供意义。18</p>
</li>
<li><p>21世纪经济学最重要的问题，可能就是多余的人能有什么功用。一旦拥有高度智能而本身没有意识的算法接手几乎一切工作，而且能比有意识的人类做得更好时，人类还能做什么？</p>
</li>
<li><p>我已一再强调，人工智能目前绝无法做到与人类匹敌。但对大多数的现代工作来说，99%的人类特性及能力都是多余的。人工智能要把人类挤出就业市场，只要在特定行业需要的特定能力上超越人类，就已足够。</p>
</li>
<li><p>人类法律已经能够认可公司或国家这种互为主体的实体，称之为“法人”。虽然“丰田”或“阿根廷”既没有身体也没有心智，但都受到国际法的约束，都能拥有土地和金钱，也都可能成为法庭上的原告或被告。可能在不久之后，算法也能获得这样的地位。这样一来，某一套算法就能自己拥有一个运输帝国或是创投公司资本，而不必服从任何人类所有者的命令。</p>
</li>
<li><p>艺术并不是出自什么神灵或超自然灵魂，而是有机算法发现数学模式之后的产物。若真是如此，非有机算法就没有理由不能掌握。</p>
</li>
<li><p>由于接下来的科技发展潜力极其庞大，很有可能就算这些无用的大众什么事都不做，整个社会也有能力喂饱这些人，让他们活下去。然而，什么事能让他们打发时间，获得满足感？人总得做些什么，否则肯定会无聊到发疯。到时候，要怎么过完一天？答案之一可能是靠药物和电脑游戏。那些对社会来说多余的人，可以多花点时间在3D虚拟世界里；比起了无生趣的现实世界，虚拟世界能够为他们提供更多刺激，诱发更多情感投入。然而，自由主义推崇人类生命及人类体验神圣不可侵犯，这样的发展会是对这一信念的一记致命打击。这些人对社会毫无用处，整天活在现实与虚幻之间，这样的生命何来神圣？</p>
</li>
<li><p>1.我是一个不可分割的个体，也就是说，我具备单一的本质，无法再分为各个部分或子系统。确实，这个内部核心可能有许多外层，但只要把这些外层剥掉，就能在内部找到一个清晰、单一的内在声音，也就是真正的自我。 2.真正的自我是完全自由的。 3.根据前两个假设，我能够了解一些别人发现不了的自己。只有我能够进入我自己内心自由的空间，只有我能听到自己真实自我的低语。正因为如此，自由主义才赋予个人极大的权威。我不该相信其他任何人为我做出选择，因为没有别人能够真正了解我是谁、我有什么感觉、我想要什么。因此，选民能做出最好的选择，顾客永远是对的，而且情人眼里永远出西施。</p>
</li>
<li><p>1.生物就是算法，人类不是不可分割的个体，而是由可分割的部分组成。换句话说，人类是许多不同算法的组合，并没有单一的内在声音或单一的自我。 2.构成人类的算法并不“自由”，而是由基因和环境压力塑造，虽然可能依据决定论或随机做出决定，但绝不“自由”。 3.因此，外部算法理论上有可能比我更了解我自己。如果能用某个算法监测组成身体和大脑的每个子系统，就能清楚掌握我是谁、我有什么感觉、我想要什么。只要开发出这样的算法，重点就不再是选民、顾客和情人；而是算法能做出最好的选择，算法永远是对的，算法觉得美，就是美。</p>
</li>
<li><p>到了选举当天一大早，我醒来的时候有点儿感冒，脑子不太好使，也让我觉得安全和稳定实在比其他一切都更重要。结果出炉！我又把那个“会毁了我们所有人”的家伙送上台，让这个人还能再当四年总统。</p>
</li>
<li><p>而这一切生化算法的集合，正是所谓的“我”。</p>
</li>
<li><p>Waze</p>
</li>
<li><p>生命科学认为，生物就是各种算法。</p>
</li>
<li><p>自由主义面对社会不平等的解药，不是让每个人都有同样的体验，而是对于不同的人类体验赋予同等的价值。然而，如果贫富差距已经不只体现在财产价值上，而且出现了真正的生物学上的差异，这一套还行得通吗？</p>
</li>
<li><p>一方面，我们已经有能力改造心智，但另一方面，我们又几乎完全不知道心理的完整频谱是什么，再加上政府、军队和企业各怀鬼胎，灾难简直不可避免。有可能到头来，我们成功地让身体与大脑都升级了，却在过程中失去了心智。确实，科技人文主义到最后可能反而会造成人类的降级。对系统来说，降级后的人类反而更有利，原因不是这种人拥有什么卓越的特点，而是这种人少了一些可能拖慢系统、造成困扰的人类特质。农民都知道，羊群里面最聪明的那只常常会惹出最大的麻烦，所以农业革命的一点就是要降低动物的心理能力。而科技人文主义梦想推动的第二次认知革命，则可能对人类造成一样的效果，让社会大机器里的“人类小齿轮”沟通和处理数据的效率更高，但几乎不会去注意其他事，不会做梦，也不会怀疑。数百万年来，人类曾经是升级版的黑猩猩。而到了未来，人类则可能变成放大版的蚂蚁。</p>
</li>
<li><p>JSTOR</p>
</li>
<li><p>究竟是什么让人优于其他动物？数据主义有一个全新而又简洁的答案。就个体而言，人类的体验并不比狼或大象的体验来得优越。只要是数据，都无高下之别。然而，人类可以把自己的体验吟成诗、写成博客，再发表到网络上，使全球数据处理系统更为丰富。就是这样，才让他们的数据有了意义。狼做不到这件事，因此虽然狼的各种体验可能一样深远复杂，却毫无价值。这也就难怪我们会急着将自己的体验转化为各种数据。这不是赶不赶流行的问题，而是个生存问题。我们必须向自己和系统证明自己仍然有价值，而且价值不在于单纯拥有体验，而在于能将体验转化为自由流动的数据。</p>
</li>
<li><p>如果数据主义成功征服世界，人类会发生什么事？一开始，数据主义可能会让人文主义加速追求健康、幸福和力量。数据主义正是通过承诺满足这些人文主义愿望而得以传播。而为了获得永生、幸福快乐、化身为神，我们就需要处理大量数据，远远超出人类大脑的能力，也就只能交给算法了。然而，一旦权力从人类手中交给算法，人文主义的议题就可能惨遭淘汰。只要我们放弃了以人为中心的世界观，而秉持以数据为中心的世界观，人类的健康和幸福看来也就不再那么重要。都已经出现远远更为优秀的数据处理模型了，何必再纠结于这么过时的数据处理机器呢？我们正努力打造出万物互联，希望能让我们健康、快乐，拥有强大的力量。然而，一旦万物互联网开始运作，人类就有可能从设计者降级成芯片，再降成数据，最后在数据的洪流中溶解分散，如同滚滚洪流中的一块泥土。</p>
</li>
<li><p>于是，数据主义对人类造成的威胁，正如人类对其他动物所造成的威胁。在历史进程中，人类创造了一个全球性的网络，不论面对任何事物，都以它在这个网络中有何功能来给予评价。几千年来，这让人充满了自尊和偏见。人类在这个网络中执行着最重要的功能，也就很容易认为自己是这个网络所有成就的主要功臣，并认为自己就是造物的巅峰。至于其他所有动物，因为它们执行的只是网络中次要的功能，于是其生命和经验都遭到低估；只要动物不再能发挥任何功能，就躲不开惨遭灭绝的命运。然而，一旦人类对网络也不再能发挥重要功能，就会发现自己到头来也不是造物的巅峰。我们自己设定的标准，会让我们也走上长毛象和白鳍豚的灭绝之路。到时回首过去，人类也只会成为宇宙数据流里的一片小小涟漪。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>流动性藏私</title>
    <url>/year/11/23/%E6%B5%81%E5%8A%A8%E6%80%A7%E8%97%8F%E7%A7%81/</url>
    <content><![CDATA[<blockquote>
<p>当代社交的行为模式是极为变动、流动的，不管是匿名聊天、随机交友，或是流连于多种实体、软件的传播媒介，都呈现出一种非常多变且轻盈的状态。</p>
</blockquote>
<a id="more"></a>

<p><img src="http://ovlnt0xy1.bkt.clouddn.com/2017-11-23-S71120-10032474.jpg" alt="S71120-10032474-w540"><br><img src="http://ovlnt0xy1.bkt.clouddn.com/2017-11-23-S71120-10033447.jpg" alt="S71120-10033447-w540"><br><img src="http://ovlnt0xy1.bkt.clouddn.com/2017-11-23-S71120-10034431.jpg" alt="S71120-10034431-w540"><br><img src="http://ovlnt0xy1.bkt.clouddn.com/2017-11-23-S71120-10035332.jpg" alt="S71120-10035332-w540"></p>
<p>Raymond Williams 曾提出很好的理论观点——“流动的藏私”（mobile privatization），此理论表达一种既能“流动”于外在世界，又能“藏有个人财货”并且达到“隐私”目的的现象，如同人们通过网络、手机等媒介，观看游走于一个较活跃且公开的社交媒体，也同时通过相同的媒介，得以另辟一个如同匿名通讯般安静、较私人的空间，达到藏私的享受。</p>
<p>每个人都对个人空间有欲求，需要有个较为隐密的私人空间，如同人文地理学中，人们对的地方与空间的概念，反映的是人类对安全与自由的基本需求，即人类需要“开放的空间”，也需要“安顿宁静的地方”，二者皆不可缺。通过媒介屏幕，流动于公私空间之中，这种移动的私有化，有赖通讯科技的发展与允许，使新的移动自由形式成为可能。</p>
<p>学者Altman 和 Taylor 曾提出，只有当人们确信不会再碰到陌生人的时候，才会与其产生亲密感。但有别于传统的亲密关系中强调地理接近性或是面对面沟通，此处的匿名社交，通过网络即可轻易的、随时随地的与陌生人产生联系。</p>
<p>互联网上的陌生人，能使我们有扮演各种角色的自由，摆脱社会伦理与眼光的束缚。匿名的陌生人在互联网的空间中，与用户的连结是偶然性的(contingent)，且绝对的陌生人是与空洞的自由（empty freedom）个体化社会特征联系在一起的；这种空洞的自由赋予了我们挣脱社区中的伦理义务的自由，我们可以成为各种我们想要成为的角色，它是完全个人意义上的自由。另外，网络的匿名性具有激起（flaming）, 非抑制（inhibited）, 平等（equality）, 去个人化（depersonalised）等效果，由于社会线索(social cues)的减弱，因此人们将更于解放趋向自由，让用户不必担心真实身份被认出来，因此也能够和陌生人建立更加亲密的关系。</p>
<p>当代社交的行为模式是极为变动、流动的，不管是匿名聊天、随机交友，或是流连于多种实体、软件的传播媒介，都呈现出一种非常多变且轻盈的状态。关于这种状态，后现代性预言家 Bauman 曾提出“液态现代性”的主张，认为流动与易变等液态性特质能较描绘当代社会本质：人们对于瞬时与快速的追求，取代了对连续持久的期待，流动性与速度成为社会分层的决定性因素；既有的规则与标准都正快速液化，不再存有稳固的单一权威；对比于过往固态、坚固的现代性是以空间的占有为主、以先前的工业革命和资本主义体制发展为代表，而今的液态现代性，则基于技术在速度上的进一步提升，尤其是运输传播媒介的发展，以至于空间、地域的限制不再是现代社会文化的关键因素。生活于当前液态现代性社会中，人们凭借的各种传统、规则、规范与互动模式正以无法控制之势不断液化、流动与变化。</p>
<p>人们对于手机的“连结与不连结”，以及各种拉扯于个人与社会之间的爱恨心理状态，即是手机利用其“Mobile”特性，凸显出移动设备做为一种媒介现象在液态现代性脉络下所展现的流动特质。而匿名交友软件，也呈现出此液态性的传播特质 ，且从单一硬件的移动电话，转移至多种软件间的流动。用户一方面在社交媒体与亲朋好友等强连结联系，建立亲密关系，一方面又基于藏私需求，通过交友软件进行匿名交友；用户会通过不只一种匿名交友软件来进行藏私行为，且会和作为与外界联系的亲密社交软件一起交替使用；两者公开与隐匿的社交媒体之间，更因着软件的特性，只需在一只手指的点击之间，就能轻易达到多种场景间的流动。</p>
<p>随着传播科技的发展与用户的需求行为改变，液态的现代性仍然不断持续著，并且有了越来越多元丰富的表现。</p>
<p>然而，除了传播媒介与液态现代性的关系，Bauman也试图指出，在液态化影响下，一种新主体的诞生，即<strong>“没有连带的人”(the man with no bonds)</strong>。这个新主体，并非完全没有任何连带，而是在与他人相互依存的连带中，并不存有一种牢不可破、永恒不变的关系，而是倾向于一种宽松的连系状态(loosely tied)；也正因为如此，才能允诺再一次的分离(be untied again)。</p>
<p>这种稀释的、开放的关系，如同匿名交友软件中，<strong>用户允许随机配对的模式，同时也允许自己被随意的联系、中断或中止一段社交关系；他们免去了社交礼节，在匿名通讯中能够恣意的切换所不想接触的聊天对象，同时也接受了他人对自己进行相同的行为；双方心照不宣的保持着一种忽远忽近、忽冷忽热的互动关系，并且默允了这种宽松的联系状态存在于彼此之间。此经过稀释般的人际互动关系，正好呼应了现代液态性的轻盈、多变特质，呈现出后现代用户在人际互动上特有的流动关系</strong></p>
<p>Sherry Turkle 曾在一场 TED 的演讲上提及，当代的用户受新传播科技的影响，彼此已经形成一种新的相处模式：一起独处（Being alone together），人们在同一个饭桌上，却各自刷着手机，或是学生们坐在教室里，心神却早已游荡在外。意即，人们仍然习惯群聚在一起，但待在一起时，又同时希望能够置身在别处；看似地理上的群聚，实际上却是彼此遥远的。这样的模式作用下，使得“没人聆听（No one is listening）”的现象普遍存在我们的人际关系之中。人们开始享受随心游走于任何场所的快感，在意自己能够掌控和分配多少的注意力，但即便彼此持续地维系连结的关系，却无法从他人身上得到全神的关注。Turkle 也批评，社交媒体快速兴起的时代，人们忽略了对话（conversation），只在意连结（connection），我们倾向找寻更多的连结，却无法从中找到自己；我们已经无法去欣赏周围的人，我们只是在利用这些人，把他们当作是零件，用来支持我们脆弱自我的零件。</p>
<p>Turkle的观点虽然悲观，但一语道破了传播科技与人际关系的现实。不过，科技始于人性，人们也会通过不断地更新传媒技术来改善现状。匿名社交软件弥补了现实生活中“没人聆听（No one is listening）”的现象，匿名聊天因为彼此的使用动机相近，也几乎能够保证彼此的先决条件便是比较愿意聆听。另外，有别于社交媒体的一对多，匿名交友以不公开且一对一的谈话式呈现，暂缓了人们连结的压力和焦虑，转而聚焦于彼此的对话内容，正好与 Turkle 所诟病当代人际关系之情况相反，人们回到了对话中沉淀自己，以弥补现实生活中过度空泛的连结关系。然而，这也可能造成一种危险现象，如 Turkle 所说，当人们对科技抱着越来越大的期待，对彼此的人际关系就越来越不抱希望——它给了我们不需要友谊（friendship），却有人陪伴（companionship）的错觉。</p>
<p>用户会认为匿名交友中的聊天对象是不重要的，甚至可以被忽略的，他们在意的是有人陪伴、倾听的感觉，通过这种感觉从而找寻、建立自我价值。这种短暂的陪伴可以是一次性的、任意中断的、随心所欲的，人们可以在不同陌生人之间游移，因为一切的重点在于自我吐露、彼此陪伴，而不是急于建立友谊，或是担心再次失去一段关系。渐渐地，人们误将线上的陪伴视为真实且令人舒适的存在，然一旦独处，便立刻变得空虚、孤单、徬徨，立刻要把手机拿出来用，用互相连线来解决；人们开始将对现实的不满足转向寻求科技的慰藉，沉迷于科技的好，而忘了现实层面。</p>
<p>正如 Turkle 所说，科技在人性最弱的点上展现致命的吸引力，或许是人们因为害怕自己不够被喜欢、生活不够丰富，转而寻求科技的帮助，但我们和科技一同成长，应该建立更多有自我意识的关系，在人与人、人与科技之间，以防止迷失在变化多端的传播科技潮流之中。</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>live</tag>
      </tags>
  </entry>
  <entry>
    <title>狂人日记———— 关于吃人！！！</title>
    <url>/year/02/08/%E7%8B%82%E4%BA%BA%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p><img src="https://blog-1256335675.cos.ap-chengdu.myqcloud.com/2019-06-18-006tKfTcgy1fqa9h7281yj30qz0chgpg.jpg" alt=""></p>
<a id="more"></a>


<p>“他们——也有给知县打枷过的，也有给绅士掌过嘴的，也有衙役占了他妻子的，也有老子娘被债主逼死的；他们那时候的脸色，全没有昨天这么怕，也没有这么凶。</p>
<p>自己想吃人，又怕被别人吃了，都用着疑心极深的眼光，面面相觑。……</p>
<p>去了这心思，放心做事走路吃饭睡觉，何等舒服。这只是一条门槛，一个关头。他们可是父子兄弟夫妇朋友师生仇敌和各不相识的人，都结成一伙，互相劝勉，互相牵掣，死也不肯跨过这一步。</p>
<p>我认识他们是一伙，都是吃人的人。可是也晓得他们心思很不一样，一种是以为从来如此，应该吃的；一种是知道不该吃，可是仍然要吃，又怕别人说破他，所以听了我的话，越发气愤不过，可是抿着嘴冷笑。”</p>
<p>………………</p>
<p>封建礼教吃了几千年的“人”，突然有个人不吃了，还阻止别人吃。当我们站在狂人的视角看时，周边的人乃至整个社会都是扭曲的，然而站在吃人者身上看，这个“狂人”无疑是个真正的狂人——我们怎么会吃人呢？</p>
<br />

<h4 id="凡事总须研究，才能明白！"><a href="#凡事总须研究，才能明白！" class="headerlink" title="凡事总须研究，才能明白！"></a>凡事总须研究，才能明白！</h4><p>凡事总须研究，才能明白。古来时常吃人，我也还记得，可是不甚清楚。我翻开历史一查，这里是没有年代，歪歪斜斜的每夜上都写着“仁义道德”几个字。我横竖睡不着，仔细看了半夜，才从字缝里看出字来，满本都是写着两个字是“吃人”！</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>王小波《爱你就像爱生命》</title>
    <url>/year/12/08/%E7%8E%8B%E5%B0%8F%E6%B3%A2%E3%80%8A%E7%88%B1%E4%BD%A0%E5%B0%B1%E5%83%8F%E7%88%B1%E7%94%9F%E5%91%BD%E3%80%8B/</url>
    <content><![CDATA[<p><img src="https://blog-1256335675.cos.ap-chengdu.myqcloud.com/2019-06-18-165250.jpg" alt=""></p>
<a id="more"></a>

<blockquote>
<p>我的灵魂里有许多玩世不恭，对人傲慢无礼，但是它有一个核心。这个核心害怕黑暗，柔弱的像绵羊一样。只有顶平等的友爱才能使他得到安慰。你对我是属于这个核心的。我是爱你的，看见就爱上了。我爱你到不自私的地步。我会不爱你吗？不爱你？不会。爱你就像爱生命。</p>
</blockquote>
<p>你要是愿意，我就永远爱你，你要是不愿意，我就永远相思。</p>
<p>你要是喜欢了别人我会哭，但是还是喜欢你。</p>
<p>你是非常可爱的人，真应该遇到最好的人，我也真希望我就是。</p>
<p>我是爱你的，看见就爱上了，我爱你爱到不自私的地步，就像一个人手里一只鸽子飞走了，他从心里祝福那只鸽子的飞翔。你也飞吧，我会难过，也会高兴，到底会怎么样我也不知道。</p>
<p>不管我本人多么平庸，我总觉得我对你的爱很美。</p>
<p>我现在已经养成了一种习惯，就是每天要对你说几句不想对别人说的话。</p>
<p>有时候你难过了，这个时候我更爱你，只要你不拒绝我我就拥抱你，我会告诉你这是因为什么，就是我不知道是为了什么。</p>
<p>我爱你，这是我的命运。</p>
<p>我决不为了仪式爱你，我是正经爱你呢。我一正经起来，就觉得自己不坏，生活也真不坏。真的，也许不坏？我觉得信心就在这里。</p>
<p>但愿我和你，是一支唱不完的歌。</p>
<p>我真的是个好人，我对好多人怀有最深的感情，尤其是对你。我很想为别人做好事，尤其是对你，我真想把我做出的一切好事全献给你了。</p>
<p>我们是两个在宇宙里游荡的灵魂，我们不愿孤独，走到一起来，别人与我们无关。我把我的整个灵魂给你，连同它的怪癖耍小脾气，忽明忽暗，一千八百种坏毛病。它真讨厌，只有一点好，爱你。</p>
<p>只希望你和我好，互不猜忌，也互不称誉，安如平日，你和我说话像对自己说话一样，我和你说话也像对自己说话一样。</p>
<p>说吧，和我好吗？</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>真相</title>
    <url>/year/12/22/%E7%9C%9F%E7%9B%B8/</url>
    <content><![CDATA[<p>巴尔扎克小说《高老头》第三章中，伏脱冷开导拉斯蒂涅的那段话，也许是巴尔扎克所有作品中，甚至是所有文学作品中，最精彩的段落之一。</p>
<p>拉斯蒂涅是一个外省青年，满怀理想来到巴黎。久经世故的伏脱冷，教导他认清自己的处境。</p>
<a id="more"></a>

<blockquote>
<p>“照你现在这个派头，你知道你需要什么，一百万家财，而且要快；不然的话，你尽管胡思乱想，一切都是水中捞月，白费！</p>
</blockquote>
<blockquote>
<p>问题是这样：咱们肚子饿得像狼，牙齿又尖又快，怎么办才能弄到大鱼大肉？”</p>
</blockquote>
<p>当公务员，看上去似乎不错    。</p>
<blockquote>
<p>“（你学法律），第一要吞下《法典》，那可不是好玩的事，就算过了关，预备将来当一个庭长，……熬尽了千辛万苦，憋着一肚子怨气之后，你总得，不管你怎样的胸襟高旷，先要在一个混蛋手下当代理检察，在什么破落的小城里，政府丢给你一千法郎薪水，好象把残羹冷饭扔给一条肉铺里的狗。你的职责是钉在小偷背后狂吠，替有钱的人辩护，把有良心的送上断头台。你非这样不可！要没有靠山，你就在内地法院里发霉。到三十岁，你可以当一名年捧一千二的推事，倘若捧住饭碗的话。熬到四十岁，娶一个磨坊主人的女儿，带来六千上下的陪嫁。</p>
</blockquote>
<blockquote>
<p>要是有靠山，三十岁上你便是检察官，五千法郎薪水，娶的是区长的女儿。再玩一下卑鄙的政治手段，你可以在四十岁上升做首席检察官，还能当议员。还得奉告一句：首席检察官的缺份，全法国统共只有二十个，候补的有两万，其中尽有些不要脸的，为了升官发财，不惜出卖妻儿子女。”</p>
</blockquote>
<p>那么，当律师呢？</p>
<blockquote>
<p>“噢！好极了！先得熬上十年，每月一千法郎开销，要一套藏书，一间事务所，出去应酬，卑躬屈膝的巴结诉讼代理人，才能招揽案子，到法院去吃灰。要是这一行能够使你出头，那也罢了；可是你去问一问，五十岁左右每年挣五万法郎以上的律师，巴黎有没有五个？”</p>
</blockquote>
<p>这些路你不想走，还有无数人为此争破头呢！</p>
<blockquote>
<p>“跟你情形相仿的四五万青年，此刻都有一个问题要解决：赶快挣一笔财产。你是其中的一个。你想：你们要怎样的拼命，怎样的斗争；势必你吞我，我吞你，象一个瓶里的许多蜘蛛，因为根本没有四五万个好缺份。</p>
</blockquote>
<blockquote>
<p>你知道巴黎的人怎么打天下的？不是靠天才的光芒，就是靠腐蚀的本领。在这个人堆里，不象炮弹一般轰进去，就得象瘟疫一般钻进去。清白老实一无用处。……雄才大略是少有的，遍地风行的是腐化堕落。社会上多的是饭桶，而腐蚀便是饭桶的武器，你到处觉得有它的刀尖。”</p>
</blockquote>
<p>人生的真相大致如此。</p>
<blockquote>
<p>在天才的力量之下，大家会屈服；大家憎恨他，极力诋毁他，因为他一人独吞，不肯分些给别人；可是他要一意孤行的话，大家便屈服了；总而言之，没法把他埋进泥潭的时候，就向他顶礼膜拜。所以正人君子是大家的公敌。您认为什么叫做正人君子？在巴黎，正人君子就是默不作声，不愿分赃的人。社会从来都是这样。道德家永远改变不了它。人类并不完美；虚伪程度时有不同，因而傻瓜便说，什么社会风气好了或是坏了。</p>
</blockquote>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>社交中的用户价值、状态评估及算法匹配模型</title>
    <url>/year/01/19/%E7%A4%BE%E4%BA%A4%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>机器如何知道用户的匹配兴趣？其实，这其中是有着具体的匹配规则的，本文将对其进行了简要概述。</p>
</blockquote>
<a id="more"></a>

<h4 id="一、用户自身价值评估"><a href="#一、用户自身价值评估" class="headerlink" title="一、用户自身价值评估"></a>一、用户自身价值评估</h4><p>人与人社交的基础：价值交换；通过三大价值衡量：经济价值、外形价值、生活价值，分别按分值体现，从低到高1-10分；</p>
<p>经济价值计算方法：默认值值3 ，根据用户初始选择的行业、职位、收入，和默认值综合得到初始值；</p>
<p>外形价值计算方法：默认值值3 ，根据用户初始选择的头像和上传的照片，和默认值综合得到初始值；</p>
<p>生活价值计算方法：生活价值不便直接算分衡量，通过用户自选标签、内容分析等判断用户的性格和爱好，通过标签体现，作为匹配的两个要素。<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzc8d8rb2tj31hy0u07fm.jpg" alt="（传统匹配：用户间与用户间大海捞针）"></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzc8ep0rklj31i10u0k06.jpg" alt="（推荐进行分发，让用户匹配合适自己的人）"></p>
<h4 id="二、用户内容评估"><a href="#二、用户内容评估" class="headerlink" title="二、用户内容评估"></a>二、用户内容评估</h4><p>用户每次发布一条内容，可分为：展示经济价值 、展示外形价值；同时，状态也会展示个人的性格和爱好。</p>
<p>用户发布内容后，平台分析其内容，对其人物价值和标签进行更新完善（初始阶段人工打分或标注，用户量增大，数据积累增多后通过机器学习由机器完成）。</p>
<p>若状态展示价值的，对其价值分数进行调整（经济，外形）；展示性格的，为其增加性格标签；展示爱好的，对其增加爱好标签。</p>
<h4 id="三、匹配规则"><a href="#三、匹配规则" class="headerlink" title="三、匹配规则"></a>三、匹配规则</h4><p>每个用户都是外在+内在的一个人物画像：外在=外形价值+经济价值，内在=性格+爱好。匹配倾向占比：设z1=外形价值,z2=经济价值,z3=性格,z4=爱好； z1+z2+z3+z4=1。</p>
<p>用户发布内容时，判断其价值交换倾向，外在还是内在，为其做对应推荐。即找准用户此刻需求，基于历史积累的价值数据匹配。</p>
<p>举例：</p>
<p>找投资伙伴：倾向经济价值，z1=0.9，为其推荐经济价值匹配度高的人</p>
<p>找短期玩伴：倾向外形价值z2=0.8，为其推荐外形价值匹配度高的人</p>
<p>找人聊天：倾向性格 z3=0.9，为其推荐性格匹配度高的人</p>
<p>找人一起运动：倾向爱好 z4= 0.8，为其推荐爱好匹配度高的人</p>
<p>当用户没有明显需求倾向时，默认值 z1=0.3，z2=0.3, z3=0.2, z4=0.2；</p>
<p>再结合其历史匹配信息，结合协同过滤等推荐算法，为其做推荐。<br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzc8gbu180j31hc0u0n3b.jpg" alt=""></p>
<h4 id="四、各价值匹配度计算方法（初步）"><a href="#四、各价值匹配度计算方法（初步）" class="headerlink" title="四、各价值匹配度计算方法（初步）"></a>四、各价值匹配度计算方法（初步）</h4><p>经济价值匹配度计算方法：</p>
<p>用户a的经济价值为 x1（百分制）;</p>
<p>用户b的经济价值为 x2（百分制）;</p>
<p>经济价值匹配度 x = 1-|x1-x2|/100；</p>
<p>外形价值匹配度计算方法：</p>
<p>用户a的 外形价值为 y1（百分制）；</p>
<p>用户b的 外形价值为 y2（百分制）；</p>
<p>外形价值匹配度 y = 1-|y1-y2|/100；</p>
<p>性格匹配度计算方法f 以及爱好匹配度计算方法i参考业界成熟的如协同过滤等推荐算法，如推荐短视频、电影、音乐等；</p>
<p>最终两两间匹配度= x<em>z1+y</em>z2+f<em>z3+i</em>z4。</p>
<p>转自—— <a href="http://www.woshipm.com/it/1840695.html" target="_blank" rel="noopener">这里</a></p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>《祖父》 胡迁</title>
    <url>/year/12/15/%E7%A5%96%E7%88%B6-%E8%83%A1%E8%BF%81/</url>
    <content><![CDATA[<p>我的祖父，一个七十多岁的老头，他年轻时很富有，后来一场运动过后就什么都没有了，那些布店，纷纷充公，他的父亲自杀了。祖父开始酗酒，那时他三十岁，有了第一个儿子，也就是我的大伯，大伯十几岁就跑去了东北。我的祖父很快又有了第二个孩子，第三个孩子，第七个孩子，那时候大家都这样。但现在没有人管他，他没有间断过饮酒，没有人愿意跟他住在一起。</p>
<a id="more"></a>

<p>七十岁时，我的祖父被送进了养老院，他咒骂着所有人，因为所有人都欠他的，他说自己当年根本没想生这些烂猪仔，但是他要操女人，所以他们出生了，他从来不关心他们的死活，他也从来没想过让任何一个人来到这个世界上，这个一瞬间所有东西都会消失不见的世界。</p>
<p>他与另一个老人住同一间屋，他恨死这个地方了，但又不知道该去哪，即便跟自己的儿女住在一起，他也时常会发狂，然后说起自己那套理论，那套从来不想带任何人来到世上的理论。我的姑姑们，她们都嫁去了很好的人家，有建筑师，有校长，有毛巾厂老板，我的大伯娶了一个画家，我的二伯靠倒卖房子发了财，坐拥着市中心的七八套房产。唯独我的父亲，继承了祖父的一切。我的父亲跟祖父一样孤僻，不与任何人亲近，当他们父子凑在一起时也互相仇恨，他们从来不在一起喝酒，也很少见面，并同其他所有亲人老死不相往来。</p>
<p>我年初有一次去养老院探望他，那所养老院有三层，一层有南北两排屋子，每排十几间，我的祖父住在朝北最角落里的一间，所有大吼大叫的人都住在最里面。他同屋的是一个劳模，床头挂着劳模才有的徽章。我的祖父看着那个徽章，对我说，多恶心，看着就想吐。</p>
<p>但您已经七十岁了，还有那么多看着不顺眼的吗？</p>
<p>小伙子，岁数能解决什么呢？</p>
<p>对，我的祖父叫我小伙子，这已经是很好听的了，他叫他的子女猪仔子，奶奶在世时，他叫她老不死的。</p>
<p>我带来了香蕉，苹果。我对祖父说。</p>
<p>你为什么不带瓶茅台给我呢？你不是去外地上学吗？</p>
<p>我怎么能带着茅台来看您呢。</p>
<p>那你来干吗呢小伙子？</p>
<p>其实我也不知道，我只是觉得每年都应该来看祖父一次，也许我不想变成他的样子，也许我的父亲也是这么想的，不想变成他的样子。最近，每天中午我的父亲都会拨错电话打给我，他一句话也不说，但已经持续了一周，拨错号。</p>
<p>我下次会带酒来。</p>
<p>不要骗我了，每个人都在骗我。</p>
<p>我一定会带来的，我跟他们不一样。</p>
<p>有什么不一样呢小伙子，他们跟你说的也都一样。</p>
<p>我保证下次会带来。</p>
<p>为什么不现在去买呢？我又出不去这个臭烘烘的院子，你知道人老了有多臭吗？</p>
<p>我离开了养老院，我不能带酒给他，他喝了会发疯，那样我可能永远都不能再来看他了。</p>
<p>后来，我的祖父不知道从哪搞来了酒，然后，据说那个劳模偷喝了几口，祖父大吼大叫。他们关系一直不好，祖父总是觉得劳模想弄死他。劳模偷喝了他的酒，当天夜晚，祖父用一根拖把棍，把劳模的脑袋砸烂了。监控录像透过窗户记录下了一切。他们问祖父为什么要打死劳模，祖父说劳模一直想弄死自己，偷他的钱，偷他的酒喝。</p>
<p>我被通知的时候，还站在宿舍里，我刚在舍友身上扎了两刀，他就倒下了，流了一屋子的血。之前我等了好一会儿，周围也没有发生什么，就接到了这个电话，通知我祖父发生了什么，不过是两天前的事情了。</p>
<p>现在是假期，学校里人很少，我不想回家，但我的舍友要留在这里跟他女朋友在一起，也不回家。他都干过些什么呢，他经常在半夜手淫，而我有神经衰弱，有几次我发现了，我说你在干吗？我当然知道他在干吗，我意思是能不能不要发出声音，但不行。他说我在自慰。我说你把灯关了。他只是把灯的亮度调小了。还有一次，他急匆匆地跑回宿舍，脱下了一条沾着屎的裤子，整个宿舍如同固化了一般，我坐在自己的桌子前，困惑他留下裤子后去干吗了。他去厕所清洗了。天啊，我每天在遭遇的都是些什么。</p>
<p>当然这些都不是最主要的原因。我的女朋友跟人劈腿后，我每天都呆在宿舍里喝酒。实际上，喝酒这件事，不需要破产或者家破人亡，哪怕摔伤了膝盖，或者一根手指不小心被划伤，都可以喝酒。然后我的舍友，他的女朋友经常来看他，他责怪我为什么总是呆在宿舍，可我又能去哪儿呢？回家会想自杀的。而呆在宿舍会妨碍他们，于是他跟女朋友在外面开完房，他因此多花了点钱，回到宿舍嘲讽我，他说我女朋友走得对，应该去追求正常的生活。我怎么能允许一个拉裤子的人如此奚落自己，于是我在他胸口扎了两刀，他也很吃惊，摔倒的时候睁大了眼睛看着我，还说，你在干吗啊？</p>
<p>之后我坐在宿舍里，看着血顺着一切流淌，又流淌过一切。我接完了那通电话，想着祖父也许不好过了，但他起码不会进监狱，我就不一样了，作为青壮年，即便我以精神病为借口也要进去呆很多年，在里面我会真的疯掉。</p>
<p>我骑上摩托车往家跑，有三百公里，中途去油站加油。便利店里不出售酒，不过我带了一瓶朗姆。我坐在加油站，喝光了那瓶朗姆，再次骑上摩托车以后，没多会儿就失去了意识。</p>
<p>等清醒过来，已经是白天，我从路边的沟里站起来，一身的伤，可能谁撞了我。我看到摩托车在十米开外的路边，车壳碎成一片片，散落在更远的地方。我感觉是谁撞了我，以为我死了，就扔进这个土沟里。</p>
<p>我把摩托车推起来，居然还能发动，就骑上车，手腕和肩膀就像被扯开一样痛。没办法，我要回家去看我父亲一眼，告诉他发生了什么，我必须要告诉他。告诉他，他将我带到这个世界上，然后这二十多年都发生了什么，我从来不跟他交流，我们不说一句话，但现在我必须要告诉他了。</p>
<p>可惜的是，摩托车只行驶了四五公里，就再也走不动。我在路边点火有十分钟，还是发动不起来，就把摩托车扔在了路边。</p>
<p>我一瘸一拐地走着，没有什么好办法，中间我试图拦车，但他们不撞死我已经谢天谢地了。</p>
<p>走了很久，大概有两三个小时，我休息了两次，真的走了很久，接着，我看到了祖父，他撑着一根拐杖，看样子他也走了很久。</p>
<p>啊，爷爷。</p>
<p>祖父回头看我，他脸上还沾着血呢，我也是，但我分不清那是我的血还是舍友的。</p>
<p>小伙子。</p>
<p>祖父笑着，这算什么呢。</p>
<p>爷爷，您要去哪？</p>
<p>逃跑啊，他们想把我抓到别的地方去，我已经没几天可活了，还要换地方。</p>
<p>就这么走着吗？</p>
<p>你怎么一身血？</p>
<p>啊，我骑车摔伤了，我喝了一整瓶，之后就不记得怎么了，醒过来的时候就这样了。</p>
<p>够倒霉的，你不该喝酒还骑车啊小伙子。</p>
<p>是啊爷爷，我还做了别的事。我把舍友捅死了。</p>
<p>祖父停下来，看着我，好像在看一个更为陌生的人，虽然小伙子这个称谓已经很陌生了。</p>
<p>看看你都干了什么。他说。</p>
<p>我噗嗤笑了出来。我的祖父，用木棍打死劳模，把那个脑袋打成摔碎的西瓜之后，居然教育起我来了。</p>
<p>我已经忍受不了了，我不知道这么多年您是怎么坚持到现在的。</p>
<p>为什么要捅人呢？</p>
<p>那人笑话我，他拉过裤子，把那条裤子扔在宿舍里，还每天半夜起来打手枪，做了这些事之后，笑话我。</p>
<p>笑话你什么呢？</p>
<p>笑话我女朋友跑了。</p>
<p>跑了不是很好吗，我半个世纪才甩掉那个老不死的。</p>
<p>那不一样，我跟您岁数不一样，还没有结婚呢。</p>
<p>你带酒了吗？</p>
<p>都喝光啦，看看我这一身伤，我走不到家啦，也快饿死了。</p>
<p>有你受的。</p>
<p>对，太多太多了。</p>
<p>我们一起沿着马路走，这下子更没人停车了，祖父戴着一顶绅士帽，不知道他从哪搞来的，穿着风衣，那根拐杖是金属的，冒着光，他看起来气质真是很好，怎么也不会让人同一个酒鬼联系起来。我就很落魄了，衣服烂兮兮，膝盖那磨得露出红彤彤的伤口，衬衣上沾着的土怎么拍也拍不干净，我的手也是脏乎乎的，但祖父只是脸上带点血。</p>
<p>爷爷，我饿了。</p>
<p>是吗小伙子，但我身上没有吃的。</p>
<p>那怎么办呢？我已经要饿得走不动了。</p>
<p>好吧。</p>
<p>他从口袋里掏出一个塑料袋，里面是几块桃酥。他果然还是藏了东西在身上。我抓起一块儿吃了，口干舌燥。</p>
<p>我们得弄点儿水啊爷爷，这样走会渴死的。</p>
<p>谁会背着水逃跑呢。</p>
<p>但我们得喝水，不然哪也去不了。</p>
<p>祖父站住，四下看去，但周围怎么看也不像有水，没有房子，没有井，没有河流。</p>
<p>再往前走走。他说。</p>
<p>我们接着走，实在太疲惫了，我真想瘫在地上，但一个老人都不肯放弃，我又能怎么样呢，就继续跟在他身后。我从路边捡了跟树棍，这才好受些，如果能再喝点水就更好了。</p>
<p>当有骑自行车人的路过时，我去要了瓶水，他们问我怎么回事，我就说家就在附近。祖父只喝了一小口，他一滴汗也不出，现在我也没有汗流出来了。</p>
<p>后来，我们翻下了护栏，朝着田野里走去。我们远离了公路，也不知道朝着什么方向。在阴天，什么方向都判断不出来。</p>
<p>走了有多久呢，天还没黑，但已经开始暗了点儿，每多走几步又会暗一点儿，我们已经远离了公路，看不清路旁的栏杆了。而祖父，我不知道他是不是累了，他突然站定在那儿。</p>
<p>我到了。他说。</p>
<p>您到了哪？</p>
<p>出生的地方。</p>
<p>但这里什么都没有啊，而且您是出生在医院里的，至少也是在家里。</p>
<p>不，我出生在这里，我站的这个地方。</p>
<p>那好吧，接下来呢？</p>
<p>你要帮我挖一个坑。</p>
<p>我可干不了这种事儿。</p>
<p>你人都杀了，还有什么不敢的。</p>
<p>那好吧。</p>
<p>我开始帮祖父挖坑，我用他的拐杖，他虽然能走路，但体力活已经做不了了，连土都翻不起来，他大概什么力气都没有了。我也没有好到哪去，挖了很久，也才挖出一个三十公分深的坑，估计可以躺进去了。</p>
<p>祖父坐在土地上，等着我，这是我唯一替他做过的事情。四周真是太荒凉了，连棵树都没有。</p>
<p>我已经挖不动了。我说。</p>
<p>祖父掏出刚在放回口袋的桃酥，在考虑着什么，这太令人心酸了。</p>
<p>我就算吃掉这些桃酥也挖不动了，已经透支啦。我说。</p>
<p>那只能这样了。他说。</p>
<p>祖父仍旧坐在地上。</p>
<p>你走吧。他说。</p>
<p>你呢？</p>
<p>我不能再走了，这是我出生的地方。</p>
<p>好吧，那我真的走了。</p>
<p>他把桃酥递给我，我接过来，放进口袋里，像他一样。这也是他唯一给过我的东西。我站在那儿。</p>
<p>最后，祖父坐进了那个土坑里，看着我，我不知道他看到了什么。</p>
<p>对不起了。他说。</p>
<p>真的吗？</p>
<p>真的，对不起了。</p>
<p>我重新朝公路走去，一路上我嚎啕大哭，我从来没有这么伤心过，也从来不知道自己可以如此伤心，如果在此之前我知道的话，根本不会拿起那把刀。</p>
<p>哭了有多久呢，直到什么都看不到，天黑得如此彻底，没有一颗星星，没有灯光，什么都没有。</p>
<p>而我根本判断不了自己出生在哪。</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>丧</tag>
      </tags>
  </entry>
  <entry>
    <title>笔记</title>
    <url>/year/09/08/%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="自由"><a href="#自由" class="headerlink" title="自由"></a>自由</h3><blockquote>
<p>他们的自由里只包含权利，不包含任何责任和义务，而另一种情况是，他们当中的有些人，会不断的抱怨，是周围的环境，让我具备不自由的可能性。</p>
</blockquote>
<a id="more"></a>

<p>《逃避自由》</p>
<blockquote>
<p>回避承担自己的责任，会把自己的自由上交给一种更大的力量。他希望这个更大的力量来主宰他的命运，所以他就不再需要为自己的成功和失败负责。</p>
</blockquote>
<p>自由是建立在自立的基础之上的。</p>
<h3 id="命运"><a href="#命运" class="headerlink" title="命运"></a>命运</h3><p>决定或者选择即是命运。</p>
<h3 id="价值排序"><a href="#价值排序" class="headerlink" title="价值排序"></a>价值排序</h3><blockquote>
<p>你需要知道什么样的选择是让自己舒服的。</p>
</blockquote>
<p>如果足够了解自己的幸福感来源于哪些方面的时候，那我在面对诱惑，面对困顿，面对他人的意见的时候，都可以更笃定，更平静的去做出自己的坚持和舍弃。</p>
<h3 id="潜意识的束缚"><a href="#潜意识的束缚" class="headerlink" title="潜意识的束缚"></a>潜意识的束缚</h3><p>如果我们的潜意识里，有一些自己还没有处理好的冲突、矛盾、被压抑了的渴望，我们自己其实是意识不到这些存在的，但哪些就发生在我们的世界里，显得好像就是我们的命运。</p>
<blockquote>
<p>我们从自己的束缚中解脱，才能获得最高成就的自由。</p>
</blockquote>
<h3 id="觉察"><a href="#觉察" class="headerlink" title="觉察"></a>觉察</h3><blockquote>
<p>抽离，从日常生活中抽离出来，站在一个有距离的位置上，去观察自己生活中所有熟悉的细节。我们要觉察到它们对于自身的影响。</p>
<p>我们会觉察到自己身上有一些“自动化”的行为和反应模式。</p>
</blockquote>
<h3 id="如何更自由——多元化生活"><a href="#如何更自由——多元化生活" class="headerlink" title="如何更自由——多元化生活"></a>如何更自由——多元化生活</h3><ol>
<li><p>更加多样的生活侧面，和更多的价值来源。</p>
</li>
<li><p>在生活中最好保有多样的身份和活动。</p>
</li>
<li><p>避免生活价值感来源单一，拥有更多的“寄情之所”<br>就不太容易产生绝对的困顿。</p>
</li>
</ol>
<p><strong>我们所要的自由，都是为了能够自由的走向我们自己需要的幸福。</strong></p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>自由</tag>
      </tags>
  </entry>
  <entry>
    <title>我爱你如此之深，这我毫不在意</title>
    <url>/year/12/18/%E6%AF%9B%E5%A7%86%E3%80%8A%E9%9D%A2%E7%BA%B1%E3%80%8B/</url>
    <content><![CDATA[<p><img src="https://blog-1256335675.cos.ap-chengdu.myqcloud.com/2019-06-18-165648.jpg" alt=""></p>
<a id="more"></a>

<p>我对你根本没抱幻想。我知道你愚蠢、轻佻、头脑空虚，然而我爱你。我知道你的企图、你的理想，你势利，庸俗，然而我爱你。我知道你是个二流货色，然而我爱你。为了欣赏你所热衷的那些玩意我竭尽全力，为了向你展示我并非不是无知、庸俗、闲言碎语、愚蠢至极，我煞费苦心。我知道智慧将会令你大惊失色，所以处处谨小慎微，务必表现得和你交往的任何男人一样像个傻瓜。我知道你仅仅为了一已之私跟我结婚。</p>
<p>我爱你如此之深，这我毫不在意。</p>
<p>据我所知，人们在爱上一个人却得不到回报时，往往感到伤心失望，继而变成愤怒尖刻。我不是那样。我从未奢望你来爱我，我从未设想你会有理由爱我，我也从未认为我自己惹人爱慕。对我来说能被赐予机会爱你就应心怀感激了。每当我想到你跟我在一起是愉悦的，每当我从你的眼睛里看到欢乐，我都狂喜不已。我尽力将我的爱维持在不让你厌烦的限度，否则我清楚那个后果我承受不了。我时刻关注你的神色，但凡你的厌烦显现出一点蛛丝马迹，我便改变方式。一个丈夫的权利，在我看来却是一种恩惠</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>精进摘抄</title>
    <url>/year/12/06/%E7%B2%BE%E8%BF%9B%E6%91%98%E6%8A%84/</url>
    <content><![CDATA[<ul>
<li><p>对于会自然消亡的事物，生命每增加一天，其预期寿命就会缩短一些。而对于不会自然消亡的事物，生命每增加一天，则可能意味着更长的预期剩余寿命。</p>
</li>
<li><p>工作会自动膨胀，直至占满所有可用的时间。</p>
</li>
<li><p>心流”（flow）这个由心理学家齐克森米哈里创立的概念已经渐渐为大众所熟知，它是指人全情投入于一件事中的状态。在心流发生时，人心无旁骛、全神贯注，甚至忘记了自己的存在，忘记了时间的流逝，在这个过程中，人会获得很大的满足感。</p>
</li>
</ul>
<a id="more"></a>

<ul>
<li><p>保持一项爱好，让它在时间的深度和长度中慢慢生长，可能会得到始料未及的成就。</p>
</li>
<li><p>“郑重”</p>
</li>
<li><p>他对待时间的方式是“郑重”的，他把“近期未来”和“远期未来”勾连在一起，并赋予时间意义和喜悦。</p>
</li>
<li><p>用平衡观点看待过去、现在和未来，用郑重的态度过好当下的生活，并联结起过去和未来。 明确工作和生活的界限，用未来视角工作，用享乐主义视角生活。 使用“时间之尺”，审视事件的长期价值，尽可能删减非必要事件。 让“远期未来”更加具体，为“近期未来”增加挑战。 把握好做事的节奏，区分“求快”的事件和“求慢”的事件。 提升时间使用的“深度”，减少被动式休闲的比例，保持至少一项长期的业余爱好。</p>
</li>
<li><p>更高的标准，才会有更好的选择</p>
</li>
<li><p>一个成熟的人，他的标准来自他的内心，而大多数人，却受环境所左右。</p>
</li>
<li><p>你内心真正的渴望是什么？</p>
</li>
<li><p>小熊和小虎是两个很要好的朋友，他们住在河边一个有烟囱的房子里。一天小熊看到河面上漂来了一个装满香蕉的箱子，上面写着“巴拿马”。于是小熊就和小虎决定去找这个叫“巴拿马”的地方，因为那里会有很多很香的香蕉，应该就是他们梦想的地方。一路上他们向狐狸、母牛问路，后来又遇上了刺猬和兔子并和他们成为了好朋友。经过了一番跋涉之后，他们终于来到了这个叫“巴拿马”的地方。可仔细一瞧。他们发现，这里就是他们原本居住的地方！巴拿马正好是这个地方的名字。于是小熊和小虎恍然大悟，原来他们一直住在自己梦想的地方里……这个故事告诉我们：在努力跋涉之前，我们首先应该搞明白，哪里才是我们心中的“巴拿马”。</p>
</li>
<li><p>如果一个人，处处能以最高目标为原则，必然能在生活中做出正确的决定。</p>
</li>
<li><p>整个人生来看最有意义和最有价值的目标，这个目标反映了一个人内心深处的渴望：我们一直在寻找的那个“巴拿马”。</p>
</li>
<li><p>从整个人生来看最有意义和最有价值的目标，这个目标反映了一个人内心深处的渴望：我们一直在寻找的那个“巴拿马”。</p>
</li>
<li><p>人不能只为他自己而活。我们必须认知所有的生命都是珍贵的，而我们和所有的生命是结合在一起的。这种认知指引了我们心灵和宇宙的关系。</p>
</li>
<li><p>“消费型兴趣”升级为“生产型兴趣”</p>
</li>
<li><p>对现实世界中决策的研究表明，并不是所有的备选方案都是已知的，并不是所有的结果都要考虑，并不是所有的偏好都在同一时间出现。”大多数时候，我们只是粗略地审查易得的、显然的选项，一旦找到合格的选项后就停止对其他选项的探寻。</p>
</li>
<li><p>种一棵树最好的时间是十年前，其次是现在。</p>
</li>
<li><p>最悲哀的，莫过于用最高效的方式去做错误的事情了。</p>
</li>
<li><p>克服“过度准备”的惯性，向前一步，把未完成的事情完成； 2. 克服“自我防卫”的心态，乐于接受反面意见并加以慎重地审视； 3. 克服“沉没成本”的固执，有勇气否定并重新构造自己的产品。</p>
</li>
<li><p>“建构式”的，即知识不是简单地吸收而来，而是由学习者主动地建构而来，学习者必须充分地调用他们的已有知识，在主动性目标的指引下、在丰富的情境中积极地进行探索，把新知识和旧知识糅合在一起，在头脑中建构出新的知识体系。</p>
</li>
<li><p>针对当前的学习材料，我已具备了哪些相关的知识？ 2. 针对当前的学习材料，我又学到了哪些新的知识？这些知识对原有知识构成了何种补充或者挑战？ 3. 针对当前的学习材料，还有哪些未知的东西，且这些东西我通过简单的探索就可以了解？ 4. 针对当前的学习材料，还有哪些未知的东西，无法轻易地获得解答，同时又有价值成为我长期去探索的问题？</p>
</li>
<li><p>本质安全性</p>
</li>
<li><p>一个好的问题，让我们成为一个“猎手”，知识是我们主动去侦察、寻觅、狩猎的猎物，而不是我们战战兢兢供奉着的或者亦步亦趋跟随着的对象。在问题引导下的学习最大的特点是，它所希求的知识是没有边界的，为了找到问题的解，我们可能会寻访任何可能的线索，查阅任何有益的资料，而不受既定的观点的束缚。</p>
</li>
<li><p>“没有任何一个题目是彻底完成了的。总还会有些事情可做；在经过充分的研究和洞察以后，我们可以将任何解题方法加以改进；而且无论如何，我们总可以深化我们对答案的理解。”</p>
</li>
<li><p>长期探索的根本性问题，不仅可以引发我们持久的求知冲动，还能迫使我们保持持续的思考。</p>
</li>
<li><p>《人是如何学习的》</p>
</li>
<li><p>一位优秀的学习者，必定是一个优秀的提问者，他从阅读、观察和思考的过程中产生问题，先解答表层的、容易的那部分，留下深度的、探索式的问题给自己，并在由此问题招致的持续困扰和折磨中开启卓越的心智旅程。</p>
</li>
<li><p>不要只做信息的搬运工 通过解码，深入事物的深层</p>
</li>
<li><p>解码不等同于我们一般所说的理解。理解通常只涉及对字面意义的解读，常以自动化的方式进行，也无须做太深入的思考，并且理解应遵从客体本意，不可擅自演化。而解码则是一个更为主动和主观的过程，不同的解读对同一材料的解码可能是完全不一样的，就像看同一部电影，不同的人能看出不同的意味。</p>
</li>
<li><p>“见文字平铺纸上，易；见若干文字自纸面浮超凸出，难。见书中文字都是一般大小，易；见书中文字重要性有大小，而如变大或变小，难。顺书之文句之次序读书，易；因识其义理之贯通，见前面文句如跑到后面，后面文句如跑到前面，平面之纸变卷筒，难。于有字处见字而知其意义，易；心知著者未言之意，于字里行间无字处见出字来，难。”</p>
</li>
<li><p>你掌握了多少知识，并不取决于你记忆了多少知识以及知识的关联，而是取决于你能调用多少知识以及知识关联。</p>
</li>
<li><p>把知识当成一项技能来学习</p>
</li>
<li><p>求知分为三个层级：信息、知识和技能。</p>
</li>
<li><p>写作式操练 写作是一种典型的知识建构活动，或者更准确地说，是一种对知识的重构活动。 在阅读时，我们对信息的理解和纳入，常常满足于从一个“浅表”的层面去理解它们（这也是为什么我在上一章里花那么多篇幅去谈“解码”的重要性）。但是在写作时，也就是进行信息输出的时候，我们必须去分析知识的“深层结构”，观察和调用知识与知识之间的深层关联，不然我们无法自如地将它们组织起来。因为一篇文章要被人读懂、要把人说服，需要缜密的思维、清晰的表达和翔实的依据，这些都要求我们对知识的编码和组织达到一个相对高的水准才行。 除了更深层的理解，写作带来的另一个明显的益处，是获得反馈。尤其在互联网时代，你可以在任何地方发表你的文章，然后得到其他人对你的评论，这些评论中可能蕴含着一些很有价值的东西，比如指出你某个知识性的错误，或者想法上的局限性，或者认知上的某一个盲点。在心理学家看来，“获得反馈”是练习的一个最重要的原则，如果没有反馈，你在练习时发生的错漏自己无法察觉，导致你无法去校正，那么做再多的练习又有什么用呢？所以对操练来说，最关键的一点是获得高质量的反馈。像竞技体育、音乐等领域，学习者能得到高水平的老师长年累月的指导，但是在另外一些领域，学习者并不具备这样的条件，他们常常只能依靠自学。可自学怎么来获得反馈呢？这就需要一些小技巧。 一个方法是找一个与自己水平相当或略高于自己的“写作同伴”（peer writer），在完成自己作品的初稿之后，首先从写作同伴那里获得专业的反馈意见，然后接着修改完善，两人便可以互相切磋共同进步。就像过去的求学者，没有互联网的时候，他们获得反馈的方式，就是建立一个交流的圈子，或者沙龙，定期在一起讨论问题。 还有一个方法是把经典作品当作老师，让它们来给自己反馈。在这个方面，完全靠自学成才的大学者王云五先生有很多心得。比如他学习英文写作的方法，是这样的：找到一篇英文的名家佳作，熟读几次以后，把它翻译成中文，等过了一星期之后，再依据这中文反过来翻译成英文，这个期间绝不查阅英语原文。译完后再与原文比对，找出自己翻译的错误、失误和不够精良之处。这种方法就像把英文名家当成了自己的老师，并可以从他们那里得到针对性的反馈，并且这种反馈的质量非常高。如此反复练习，王云五先生练就了扎实的英文功夫。</p>
</li>
<li><p>参与性、互动性和投入性，同时它摆脱了现实规则的制约，使我们可能在更丰富多样的情境下去应用我们的知识</p>
</li>
<li><p>学习螺旋（learning spiral）模型，认为创造性的学习是想象、创造、游戏、分享、反思和想象的螺旋式循环。</p>
</li>
<li><p>编程语言是用来帮助思考程序的，而不是用来表达你已经想好的程序。它应该是一支铅笔，而不是一支钢笔”。因此在编程中，过早优化（premature optimization）是一件危险</p>
</li>
<li><p>所谓灵感，所谓潜意识的思考，并非平白无故产生的，而是有赖于思考者已经拥有了丰富的、充足的、多元的思考材料，潜意识的作用是借用其强大的并行计算能力，把这些思考材料进行各种组合。可以说，你在灵感酝酿之前，所做的素材准备工作越是充分，那么获得创造性成果的概率就越大。</p>
</li>
<li><p>掌握了多少知识，并不取决于记忆了多少知识以及知识的关联，而是取决于能调用多少知识以及知识关联。</p>
</li>
<li><p>任何孤立的事物自身都毫无简洁可言。一切事物只有被恰当地置于某个有机的整体中，才可能实现这个局部自身的简洁。</p>
</li>
<li><p>当每天发生的事情都在意料之中，当每天我们都在重复接收相同或者相似的信息，当每天我们只是在一遍遍重复和强化我们固有的想法，那么我们的潜意识就很可能无所作为。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>自由</title>
    <url>/year/10/09/%E8%87%AA%E7%94%B1/</url>
    <content><![CDATA[<blockquote>
<p>当我们说想要自由的时候，意思是说，我想要挣脱我不喜欢的束缚，奔向另一场我想要的归属。绝对自由是不存在的，只存在想要的约束。</p>
</blockquote>
<p>人生而自由，却又无往而不在枷锁之中。           ——卢梭</p>
<a id="more"></a>

<br>


<p>一个所谓能适应社会的正常人远不如一个所谓人类价值角度意义上的精神病症患者健康。前者很好地适应社会，其代价就是放弃自我，以便成为别人期望的样子。……相反，精神病症患者则可以被视为在争夺自我的战斗中不准备彻底投降的人。</p>
<br>

<p>按照他人的要求对自己的一切作出规划，被孤独感，恐惧感和各种直接威胁着我们的自由，生命和舒适的力量所驱使.</p>
<p>我们欺骗自己找到了为之拼命奋斗的自我，最后却发现那只不过是社会中的自我。</p>
<p><strong>安全感</strong></p>
<p>自发性的活动，爱和创造的活动。</p>
<p>逃避自由，还是忍受孤独？</p>
<blockquote>
<p>我们多数人至少可以在刹那间察觉到我们自身的自发性，而正是在这刹那间，我们获得了真正的欢乐。</p>
</blockquote>
<p>逃避自由机制：</p>
<ul>
<li>权威主义</li>
<li>破坏欲</li>
<li>机械趋同。（伪自我）</li>
</ul>
<p>读完 一本书后，就是能够站在更高的地方看我们与世界的关系。感觉自己很沧海一粟，却又是撬动世界的支点。</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>自由</tag>
      </tags>
  </entry>
  <entry>
    <title>叔本华：菲利斯特人</title>
    <url>/year/01/18/%E8%8F%B2%E5%88%A9%E6%96%AF%E7%89%B9%E4%BA%BA/</url>
    <content><![CDATA[<blockquote>
<p>Philister ———— 菲利斯特人</p>
<p>原义：被文艺女神抛弃的人</p>
<p>特质：没有精神需求的人，也没有精神上的乐趣</p>
</blockquote>
<a id="more"></a>

<p>在这里，我得提及这样一类人：他们由于仅仅具备了那常规的、有限的智力配给，所以，他们并没有精神思想上的要求，他们也就是德语里的Philister——“菲利斯特人”。这名称源自德国的大学生词汇。后来，这一名称有了更深一层的含义，虽然它和原来的意思依然相似；“菲利斯特人”指的是和“缪斯的孩子”恰恰相反的意思，那就是“被文艺女神抛弃的人”。确实，从更高的角度审视，我应该把菲利斯特人的定义确定为所有那些总是严肃古板地关注着那并非现实之现实的人。不过，这样一个超验的定义却跟大众视角不相吻合——而我在这本书里所采用的就是大众视角——所以，这样的定义或者不会被每一个读者所透彻理解。相比之下，这名称的第一定义更加容易解释清楚，它也详细表现了菲利斯特人的特质及其根源。因此，菲利斯特人就是一个没有精神需求的人。</p>
<p>根据我提及过的原则，“没有真正的需求也就没真正的快乐”就可以推断：首先，在他们的自身方面，菲利斯特人并没有什么精神上的乐趣。他的存在并没有受到任何对知识的追求和对真理的探索这一强烈欲望的驱动，也没有要享受真正的美的热望——美的享受与对知识、真理的追求密切相关。但如果时尚或者权威把这一类快乐强加给他们，那他们就会像应付强制性苦役般地尽快把它们打发了事。对这种人来说，真正的快乐只能是感官上的快乐。牡蛎和香槟就是他们生存的最高境界。他们生活的目的，也就是为自己获得所有能为他们带来身体上安逸和舒适的东西。如果这些事情把他们忙得晕头转向，那他们就的确快乐了！因为如果从一开始就把这些好东西大量提供给他们，他们就会不可避免地陷入无聊之中，而为了对抗无聊，他们是无所不用其极的：舞会、社交、看戏、玩牌、赌博、饮酒、旅行、马匹、女人，等等。但所有这些都不足以赶走无聊，因为缺少了精神的需求，精神的快乐也就是不可能的。因此，菲利斯特人都有一个奇异的特征，那就是：他们都有一副呆滞、干巴巴的类似于动物的一本正经和严肃表情。没有什么事情能使他们愉快、激动，能提起他们的兴趣。感官的乐趣很快就会烟消云散。由同样的菲利斯特人所组成的社交聚会，很快就变得乏味无聊，纸牌游戏到最后也变得令人厌倦。</p>
<p>不管怎样，这种人最终还剩下虚荣心。他们以各自不同的方式享受虚荣心所带给他们的乐趣，那就是：他们尽力在财富或者社会地位，或者权力和影响力方面胜人一筹，并藉此获得他人对自己的尊崇。又或者，他们至少可以追随那些拥有上述本事的人，以沐浴在这些人身上折射出来的余辉之中。从我们提到的这些菲利斯特人的本质，可以引出第二点：对于他人，由于菲利斯特人没有精神上的需求，而只有身体上的需要，所以，他们在与他人的交往中，会寻求那些能够满足自己身体上的需要，而不是精神上的需求的人。因此，在他们对别人的诸多要求当中，最不重要的，就是别人必须具备一定的头脑思想。当他看见别人具有突出头脑思想时，那反而只会引起菲利斯特人的反感，甚至憎恨。因为他们有着一股可憎的自卑感，以及呆笨的、不为人知的嫉妒心——他们小心翼翼地试图把它们掩饰起来，甚至对自己也是这样。但这样一来，这种嫉妒有时候就会变成某种私下里的苦涩和愤怒。因此，他们永远也不会想到要对卓越的精神思想给予恰如其分的尊崇和敬意；他们一心一意地把尊崇和敬意留给拥有地位、财富、权力、影响力的人，因为这些东西在他们的眼中才是真正优越的东西。在这些方面出风头也就成了他们的愿望。所有这一切都源于这一事实：他们是一个没有精神需求的人。</p>
<p>菲利斯特人的巨大痛苦，就在于任何理念性的东西都无法带给他们愉快。他们为了逃避无聊，不断需要现实性的事物。但由于现实性的东西很快就会被穷尽，一旦这样，它们就不但不再提供快乐，反而会使人厌烦；并且，这些东西还会带来各种祸殃。相比较而言，理念性的东西却是不可穷尽的，它们本身既无邪也无害。</p>
<p>摘自叔本华的《人生的智慧》</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>跟一只蜘蛛讲了很久的心事，然后把她拍死了</title>
    <url>/year/11/19/%E8%B7%9F%E4%B8%80%E5%8F%AA%E8%9C%98%E8%9B%9B%E8%AE%B2%E4%BA%86%E5%BE%88%E4%B9%85%E7%9A%84%E5%BF%83%E4%BA%8B%EF%BC%8C%E7%84%B6%E5%90%8E%E6%8A%8A%E4%BB%96%E6%8B%8D%E6%AD%BB%E4%BA%86/</url>
    <content><![CDATA[<p>我没有办法，我向来经不住别人的哀求，是她一再的要求我这样做的。二十多年里这不是第一次了，从小到大她都陪在我身边，聆听了我生活中的所有喜怒哀乐。所有的黑色情绪我都丢给她，她也安静的接受着我的每一次生气和大哭。今晚我照常和她说起一些令人难过的事，又一次提起想要一场车祸，或是从天桥上坠下后选择性失忆，或者吞下一大把阿普唑仑被抢救后，忘记之前的生活，过去太让人痛苦了，我真是难以承受……</p>
<a id="more"></a>
<p>听着听着她突然打断我，你真的想要这样吗？忘记过去你会幸福吗？唔，或许吧！她说，既然这样，那你杀死我吧。我背负了你所有的过去，杀死我，丢掉过去以后好好生活。 我一时语塞，心里却有些动摇。这未尝不是一个好办法，过去压的我喘不过气来，要杀死她吗？要和过去说再见吗？我犹豫不决站在原地。动手吧，做个了断，她往前走了走，也不知道沉默了多久，终于我还是随手抓起一本书，我知道我还是对这些伤人的过往依依不舍，手里的书缓缓下落，这样轻易应该是杀不死她的，我侥幸想着，但当书接触到桌面的那一刹，我还是听到了爆裂的“噗呲”声，忽然，我的四肢开始无力，身体支撑不住的瘫倒在地，瞳孔慢慢扩散，皮肤也渐渐干瘪至骨缝，蜘蛛死了，过去真的消失了，我也不存在了，真好。</p>
<p><img src="http://ovlnt0xy1.bkt.clouddn.com/2017-11-19-Snip20171119_110.png" alt="Snip20171119_110"></p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>脑洞</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试学习整理</title>
    <url>/year/10/10/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<pre><code>&lt;!--more--&gt;</code></pre><p><img src="http://ovlnt0xy1.bkt.clouddn.com/2017-09-22-ST.png" alt="ST"></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。</li>
<li>测试就是发现程序中的错误而执行的过程。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">给自己一个心理设定，就是要找出程序中的错误。（克服心理障碍）</span><br></pre></td></tr></table></figure>



<h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ul>
<li>测试用例中必需部分是对预期输出或结果进行定义</li>
<li>程序员应当避免测试自己编写的程序</li>
<li>编写软件的组织不应当测试自己编写的软件</li>
<li>应当彻底检查每个测试的执行结果</li>
<li>测试用例的编写不仅应当根据有效和预料到的输入情况，而且也应当根据无效和未预料到的输入情况</li>
<li>检查程序是否“ 未做其应该做的” 仅是测试的一半，测试的另一半是检查程序是否 “ 做了其不应该做的”</li>
<li>应避免测试用例用后即弃，除非软件本身就是一个一次性的软件</li>
<li>计划测试工作时不应默许假定不会发现错误</li>
<li>程序某部分存在更多错误的可能性，与该部分已发现错误的数量成正 比</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>是否运行程序<ul>
<li>动态测试</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">通过运行软件来检验软件的动态行为和运行结果的正确性。</span><br></pre></td></tr></table></figure>
<pre><code>- 静态测试</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">通过分析或检查源程序的语法、结构、过程、接口等来检查程序的正确性</span><br></pre></td></tr></table></figure>
<ul>
<li>是否查看源码</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">是否查看源码</span><br></pre></td></tr></table></figure>
<pre><code>- 黑箱测试</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">		black-box testing，也称黑盒测试，测试应用程序的功能，测试者不需具备应用程序的代码、内部结构和编程语言的专门知识。</span><br><span class="line"></span><br><span class="line">数据驱动</span><br><span class="line"></span><br><span class="line">穷举路径测试</span><br></pre></td></tr></table></figure>
<pre><code>    - 通过有限的测试用例，最大限度的发现问题。
    - 可用性测试
- 灰盒测试</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">多用于集成测试阶段</span><br></pre></td></tr></table></figure>
<pre><code>- 白箱测试</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">		white-box testing，又称透明盒测试，结构测试等。测试程序内部运作。以编程语言角度来设计测试案例。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">逻辑驱动型</span><br></pre></td></tr></table></figure>
<pre><code>- 利用错误列表进行代码检查
- 小组代码走查
- 同行评审</code></pre><ul>
<li>测试阶段<ul>
<li>单元测试</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">		对软件组成单元进行测试，其目的是检验软件基本组成单位的正确性。</span><br><span class="line"></span><br><span class="line">测试的对象是软件设计的最小单位：函数。</span><br></pre></td></tr></table></figure>
<pre><code>- 集成测试</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">集成测试也称综合测试、组装测试、联合测试，将程序模块采用适当的集成策略组装起来，对系统的接口及集成后的功能进行正确性检测的测试工作。目的是检查软件单元之间的接口是否正常。</span><br></pre></td></tr></table></figure>
<pre><code>- 系统测试</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对一个完整的软件以用户的角度测试。</span><br></pre></td></tr></table></figure>
<pre><code>- 确认测试</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">验证被测对象有测性</span><br></pre></td></tr></table></figure>
<pre><code>- 安全测试
- 回归测试
    - QTP
- 验收测试</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">验收测试的目的是确保软件准备就绪</span><br></pre></td></tr></table></figure>
<ul>
<li>测试进程<ul>
<li>Alpha测试</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">验证测试。模拟运行。由开发人员与测试的测试人员。</span><br></pre></td></tr></table></figure>
<pre><code>- Beta测试</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">公众参与的测试的阶段。确认测试，在一个真实的环境中以实际的数据来运行测试，，以确认性能，系统运行有效率，系统撤消与备份作业正常。</span><br></pre></td></tr></table></figure>
<pre><code>- 封闭测试Closed Beta</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">公开上市前的测试过程。</span><br></pre></td></tr></table></figure>
<pre><code>- 公开测试Open Beta</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">又称压力测试</span><br></pre></td></tr></table></figure>
<pre><code>- Gamma测试</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对“存在缺陷”产品的测试，这个概念存在着一定的不确定性。</span><br></pre></td></tr></table></figure>
<ul>
<li>压力测试与性能测试</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">压力测试和性能测试常常混淆。</span><br></pre></td></tr></table></figure>
<pre><code>- 压力测试</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">		压力测试要求进行超过规定性能指标的测试。</span><br><span class="line"></span><br><span class="line">判断准则：</span><br><span class="line"><span class="number">1</span>、系统能够恢复。</span><br><span class="line"><span class="number">2</span>、压力测试过程中，不要有明显的性能下降。</span><br></pre></td></tr></table></figure>
<pre><code>- 性能测试</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。</span><br></pre></td></tr></table></figure>
<ul>
<li>其他<ul>
<li>探索性测试</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">		没有很多实际的测试方法、技术和工具，但是却是所有测试人员都应该掌握的一种测试思维方式。</span><br><span class="line">探索性强调测试人员的主观能动性，抛弃繁杂的测试计划和测试用例设计过程，强调在碰到问题时及时改变测试策略。</span><br></pre></td></tr></table></figure>
<pre><code>    -
- 冒烟测试</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">检查对象是否具有可测性</span><br></pre></td></tr></table></figure>
<pre><code>- 敏捷测试</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">		利用测试记录需求和驱动开发的思想。</span><br><span class="line"></span><br><span class="line">敏捷测试思想是面向结果的、技术性的、协作的，乐于学习的、勇于不断生产业务价值的。</span><br></pre></td></tr></table></figure>

<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul>
<li>程序</li>
<li>数据</li>
<li>文档</li>
</ul>
<h2 id="缺陷（bug）"><a href="#缺陷（bug）" class="headerlink" title="缺陷（bug）"></a>缺陷（bug）</h2><ul>
<li>缺陷的跟踪流程（流程基本要素）</li>
<li>5C原则<ul>
<li>准确</li>
<li>清晰</li>
<li>简洁</li>
<li>完整</li>
<li>一致</li>
</ul>
</li>
<li>内容<ul>
<li>bug编号</li>
<li>严重级别／优先级</li>
<li>产生条件</li>
<li>产生模块</li>
<li>bug摘要</li>
<li>bug对应版本</li>
<li>bug详细描述，截图，录屏</li>
</ul>
</li>
</ul>
<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><ul>
<li>原则<ul>
<li>单个用例最小化原则</li>
<li>测试用例替代产品文档功能原则</li>
<li>单次投入成本和多次投入成本原则</li>
<li>使测试结果分析和调试最简单化原则</li>
</ul>
</li>
<li>方法<ul>
<li>等价类划分</li>
<li>边界值分析</li>
<li>错误推测</li>
<li>因果图</li>
<li>判定表驱动分析</li>
<li>正交实验设计</li>
<li>场景设计法</li>
<li>状态转换图</li>
</ul>
</li>
<li>内容<ul>
<li>用例编号</li>
<li>用例描述</li>
<li>前提条件</li>
<li>输入数据</li>
<li>测试步骤</li>
<li>期望结果</li>
</ul>
</li>
</ul>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul>
<li>测试管理工具<ul>
<li>TestDirector</li>
</ul>
</li>
<li>功能测试工具</li>
<li>负载压力测试工具<ul>
<li>loadrunner</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Web性能测试工具</span><br></pre></td></tr></table></figure>
<ul>
<li>测试辅助工具</li>
<li>白盒测试工具</li>
</ul>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试学习笔记</title>
    <url>/year/09/21/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<ul>
<li><p>在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。</p>
</li>
<li><p><strong>测试就是发现错误而执行程序的过程。</strong></p>
</li>
</ul>
</blockquote>
<a id="more"></a>


<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ol>
<li>保证测试的覆盖度，但是穷举测试是不可能的。</li>
<li>所有的测试都应该追溯到用户。</li>
<li>越早测越好，测试过程与开发过程应该是互相结合的。</li>
<li>测试的规模 从小到大，从单元测试到系统测试。</li>
<li>不能为了便于测试而擅自修改程序。</li>
<li>既应该测试软件能做什么，也应该测试软件不能做什么。</li>
</ol>
<h3 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h3><ul>
<li>测试覆盖率</li>
<li>缺陷发现率</li>
<li>测试成功率（或者说用例通过率）</li>
</ul>
<p>测试做到什么程度并没有一个固定答案。只要满足两个显式条件和一个隐含条件就要一直进行。</p>
<h4 id="显式条件："><a href="#显式条件：" class="headerlink" title="显式条件："></a>显式条件：</h4><ul>
<li>项目风险</li>
<li>项目经费</li>
</ul>
<h4 id="隐含条件："><a href="#隐含条件：" class="headerlink" title="隐含条件："></a>隐含条件：</h4><ul>
<li>老板们从当前的测试结果已经获得了足够的信心,或者彻底摧毁了信心。只要他们还在犹豫咱就得继续干活。</li>
</ul>
<h3 id="测试的原则🌟"><a href="#测试的原则🌟" class="headerlink" title="测试的原则🌟"></a>测试的原则🌟</h3><blockquote>
<p><strong>测试只是展示缺陷</strong></p>
<p>测试只能表明缺陷存在,却不能证明没有缺陷。测试能降低未发现缺陷留存的概率,却 不能证明软件是绝对正确的。 正如某些数学命题,你可以穷举 1-n,证明其正确,却依然无法证明对于 n+1 仍然正确。</p>
<br>
**穷尽测试是不可能的**

<p>测试所有的输入和条件组合是不可能的,除非是极其简单的情况。可以取而代之的是基 于风险和优先级的测试。 当不懂装懂的老板要求你彻底测试一个软件的时候,这是你反驳的最好支持,当然要说 的委婉一点。</p>
<p><strong>早期测试</strong></p>
<p>要较早发现缺陷,就要在软件周期尽可能早的时候开始测试,而且要专注于已定义的测 试目标。 尽早开始测试!这句话估计早就把大家的耳朵磨起茧了。为什么要早?因为越早发现问 题,解决的代价就越小。</p>
<p><strong>缺陷簇生</strong></p>
<p>要对缺陷发现率高的模块投入更多的测试。少量的模块往往隐藏了大部分的缺陷。 这不仅仅是所谓的物以类聚。缺陷发现率高的模块往往于需求不清,设计不当,编码复 杂度高等内在原因关联,所以从风险的角度来看必然较高,多花些时间绝对值得。</p>
<p><strong>杀虫剂悖论</strong></p>
<p>相同的测试再重复多次后就无法再找到缺陷了。要克服“杀虫剂悖论”,测试用例要不断评审修改,不断添加新的和不同的测试,就有可能找到更多缺陷。 随着对系统的加深理解,必然会有更多的测试用例产生。另外缺陷本身也是新用例的很 好来源。</p>
<p><strong>测试是上下文相关的</strong></p>
<p>测试在不同上下文环境中的执行是不同的。比方说 安全关键系统 (safety critical system)和电子商务网站的测试方法就有很大不同。 这个原理相对难理解。这里其实强调的是不能用相同的态度和手段来测试不同类型的系 统。安全关键系统的概念要到高级大纲中才出现,指的是对系统安全要求苛刻的系统, 较之一般的电子商务系统的测试要求更为严苛。</p>
<p><strong>无错谬论</strong></p>
<p>假如建立的系统不稳定或不能满足用户需要和期望,那么发现和修复缺陷就毫无帮助了。 缺陷数量往往用来评估某软件的质量,但要是系统本身背离了用户要求,那就算缺陷再 少也没用,因为没有人会去用它。所以测试时要注意验证(verification)和确认(validation)的区别。需求规格说明和其他文档只是需求的不完全载体。文字说明必然有遗漏和偏差, 而各人的理解更有可能出错。要不断通过各种途径保证所生产的的确就是用户需要的。 常用的方式就是邀请领域专家或用户尽可能多地参与到开发活动来,特别是需求评审和 演示(Demo)。</p>
</blockquote>
<h4 id="测试的标准"><a href="#测试的标准" class="headerlink" title="测试的标准"></a>测试的标准</h4><ul>
<li><p>测试的标准是用户的需求。</p>
<p>所有的软件测试都应该追溯用户的需求，测试人员要始终站在用户的角度去看问题、去判断的软件缺陷的影响，系统最严重的错误是那些导致程序无法满足用户需求的缺陷。</p>
</li>
</ul>
<h3 id="测试主要步骤"><a href="#测试主要步骤" class="headerlink" title="测试主要步骤"></a>测试主要步骤</h3><ul>
<li>计划与控制</li>
<li>分析与设计</li>
<li>实施与执行</li>
<li>评估出口准则和报告</li>
<li>测试结束活动</li>
</ul>
<h3 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h3><p>1-项目经理通过和客户的交流，完成需求文档，由开发人员和测试人员共同完成需求文档的评审，评审的内容包括：需求描述不清楚的地方和可能有明显冲突或者无法实现的功能的地方。项目经理通过综合开发人员，测试人员以及客户的意见，完成项目计划。然后sqa进入项目，开始进行统计和跟踪</p>
<br>
2-开发人员根据需求文档完成需求分析文档，测试人员进行评审，评审的主要内容包括是否有遗漏或者双方理解不同的地方。测试人员完成测试计划文档，测试计划包括的内容上面有描述。

<br>
3-测试人员根据修改好的需求分析文档开始写测试用例，同时开发人员完成概要设计文档，详细设计文档。此两份文档成为测试人员撰写测试用例的补充材料。

<br>
4-测试用例完成后，测试和开发需要进行评审。

<br>
5-测试人员搭建环境

<br>
6-开发人员提交第一个版本，可能存在未完成功能，需要说明。测试人员进行测试，发现bug后提交给bugzilla。

<br>
7-开发提交第二个版本，包括bug fix以及增加了部分功能，测试人员进行测试。

<br>
8-重复上面的工作，一般是3-4个版本后bug数量减少，达到出货的要求。

<br>
9-如果有客户反馈的问题，需要测试人员协助重现以及回归测试。


<h4 id="为什么要避免测试自己的程序？"><a href="#为什么要避免测试自己的程序？" class="headerlink" title="为什么要避免测试自己的程序？"></a>为什么要避免测试自己的程序？</h4><p>由于心理因素，人们潜意识都不希望找到自己的错误。基于这种思维定势，人们难于发现自己的错误。</p>
<p>###软件测试的要素</p>
<blockquote>
<ul>
<li>质量：</li>
</ul>
<p>软件质量是软件测试的目标，也是软件测试工作的中心，一切从质量出发，也就是一切从客户需求出发。任何违背质量的东西都是问题，测试就是要找出这些问题。</p>
</blockquote>
<blockquote>
<ul>
<li>人员：</li>
</ul>
<p>人是决定的因素，测试人员的态度、素质、能力决定着测试的效果，对测试产品的质量也有很大的影响。测试人员因素包括测试组织结构、角色和责任的定义。</p>
</blockquote>
<blockquote>
<ul>
<li>技术：</li>
</ul>
<p>软件测试技术，包括方法、工具。</p>
</blockquote>
<blockquote>
<ul>
<li>资源：</li>
</ul>
<p>主要是指测试环境中所需要的硬件设备、网络环境，甚至包括测试数据。另外一个重要因素就是测试时间，时间也是测试的资源，但测试人员不能看做资源，每个人的能力千差万别，不同的测试人员担任不同的角色，不能相互代替。这也是软件图书的经典之作——《人件》的作者反对将人作为资源对待的原因。</p>
</blockquote>
<blockquote>
<ul>
<li>流程：</li>
</ul>
<p>从测试计划和测试用例的创建、评审到测试的执行、报告，设定每个阶段的进出标准。</p>
</blockquote>
<h3 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h3><p>软件产品质量评价国际标准<code>ISO 14598</code> 把软件质量定义为：<strong>软件特性的总和</strong>，<strong>软件满足规定或潜在用户需求的能力</strong>。上述定义反应如下3个方面的问题：</p>
<blockquote>
<ul>
<li>软件需求是度量软件质量的标准；</li>
<li>软件人员必须遵循软件过程过程的规范；</li>
<li>如果软件只是满足规定的需求，而不能满足可能存在的隐含需求，软件质量也不能保证。</li>
</ul>
</blockquote>
<h3 id="软件团队的责任"><a href="#软件团队的责任" class="headerlink" title="软件团队的责任"></a>软件团队的责任</h3><blockquote>
<ul>
<li>发现软件程序、系统或产品中“所有”的问题</li>
</ul>
</blockquote>
<ul>
<li>尽早地发现问题</li>
<li>督促和协助开发人员尽快地解决程序中的缺陷</li>
<li>帮助项目管理人员制定合理的开发计划</li>
<li>对缺陷进行跟踪、分析和分类总结，以便让项目的管理人员和相关的负责人员能够及时、清楚地了解产品当前的质量状态</li>
<li>帮助改善开发流程、调高产品开发效率</li>
<li>促进程序编写的规范性、易读性、可维护性等</li>
</ul>
<h3 id="缺陷发现率"><a href="#缺陷发现率" class="headerlink" title="缺陷发现率"></a>缺陷发现率</h3><p>缺陷发现率DDP是另一个衡量测试工作效率的软件质量成本的指标。<br><img src="http://ovlnt0xy1.bkt.clouddn.com/2017-09-21-15058962940319.jpg" alt=""></p>
<blockquote>
<p>缺陷发现率DDP＝Bugs（tester）/ （Bugs（tester）+ Bugs（customer））</p>
</blockquote>
<p>缺陷发现率越高，也就是测试者发现的错误多，发布后客户发现的错误就越少，降低了外部故障不一致成本，达到节约总成本的目的，可获得较高的测试投资回报率。</p>
<h3 id="测试分类"><a href="#测试分类" class="headerlink" title="测试分类"></a>测试分类</h3><h4 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h4><ul>
<li><p>又称<strong>功能测试</strong>或数<strong>据驱动测试</strong>，是针对软件的功能需求/实现进行测试，通过测试来检测每个功能是否符合需求，<strong>不考虑程序内部的逻辑结构</strong>。</p>
</li>
<li><p>方法：</p>
<ol>
<li>功能划分</li>
<li>等价类划分</li>
<li>边界值划分</li>
<li>因果图（鱼骨图）</li>
<li>错误推测</li>
</ol>
<h4 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h4></li>
<li><p>白盒测试也称<strong>结构测试</strong>或<strong>逻辑驱动测试</strong>，<strong>必须知道软件内部工作过程</strong>，通过测试来检测软件内部是否按照需求、设计正常运行。</p>
</li>
<li><p>方法：</p>
</li>
</ul>
<p>对应于程序的一些主要结构：语句、分支、逻辑路径、变量；</p>
<ol>
<li>语句覆盖方法</li>
<li>分支覆盖方法</li>
<li>逻辑覆盖方法</li>
</ol>
<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><ul>
<li>定义： 又称<strong>模块测试</strong>，是针对软件设计的最小单位程序模块进行正确性检查的测试工作；可以从程序的内部结构出发设计测试用例，多个模块测试可以平行地独立进行测试；</li>
<li>目的：发现模块内部可能存在的差错；</li>
<li>内容：模块接口测试（数据流入流出）、局部数据结构测试、路径测试、错误处理测试、边界测试。</li>
<li>步骤：利用设计文档设计测试用例；创建被测模块的桩模块或驱动模块；利用被测试模块、驱动模块和桩模块来建立测试环境，进行测试。</li>
</ul>
<h4 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h4><ul>
<li><p>定义：又称组装测试或联合测试，在单元测试的基础上，将所有模块按概要设计和详细设计进行组装。</p>
</li>
<li><p>目的：发现模块连接中的接口可能存在的各种差错</p>
</li>
<li><p>内容：</p>
<ol>
<li><p>穿越模块之间的数据是否会丢失；</p>
<ol start="2">
<li><p>一个模块组装后是否会对另一模块或其他模块存在影响</p>
</li>
<li><p>各个子功能组装在一起是否会达到预期的父功能</p>
</li>
<li><p>全局数据结构是否有问题；</p>
</li>
<li><p>单个模块的错误累积起来是否会放在。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>组装方法：包括一次性组装方式、增殖式组装方式两种组装方法</p>
</li>
<li><p>完成标志：成功地执行了测试计划中规定的所有测试用例；修正了所发现的错误；测试结果通过专门小组的评审</p>
</li>
</ul>
<h4 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h4><ul>
<li>目的：验证和确认系统是否达到其原始目标，而对集成的硬件和软件系统进行的测试</li>
<li>测试内容：在真实或模拟系统运行环境下，检查完整的程序系统能否和系统（硬件设备、网络、系统软件）正确配置、连接，满足用户需求</li>
</ul>
<h4 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h4><ul>
<li><p>测试目的：在用户环境中进行测试，以确定系统和产品是否能够满足合同或用户所规定的需求</p>
</li>
<li><p>测试内容：根据任务书或合同、供需双方约定的验收依据文档进行对整个系统的测试与评审，确认是否接收或拒绝系统</p>
</li>
</ul>
<h3 id="Alpha测试"><a href="#Alpha测试" class="headerlink" title="Alpha测试"></a>Alpha测试</h3><ul>
<li>属于验证测试。模拟运行。由开发人员与测试的测试人员。</li>
</ul>
<h3 id="Beta测试"><a href="#Beta测试" class="headerlink" title="Beta测试"></a>Beta测试</h3><ul>
<li>属于验收测试。由软件的最终用户在一个或多个用户场所来进行的，开发者通常不在现场，用户记录测试中遇到的问题并报告给开发者。</li>
</ul>
<h3 id="静态测试"><a href="#静态测试" class="headerlink" title="静态测试"></a>静态测试</h3><ul>
<li>静态测试又称为<strong>静态分析技术</strong>，<strong>不执行被测试软件</strong>，对<strong>需求分析说明书</strong>、<strong>软件设计说明书</strong>、<strong>源程序做结构</strong>检测、<strong>流图分析</strong>、<strong>符号执行</strong>等找出软件的错误。</li>
</ul>
<h3 id="动态测试"><a href="#动态测试" class="headerlink" title="动态测试"></a>动态测试</h3><ul>
<li>通过输入一组预先按照一定的测试准则构造的实例数据动态运行程序，而达到发现程序错误的过程。</li>
</ul>
<h3 id="如何进行单元测试"><a href="#如何进行单元测试" class="headerlink" title="如何进行单元测试"></a>如何进行单元测试</h3><ul>
<li>完成最小的软件设计单元——模块验证工作。</li>
<li>确保模块的正确编码</li>
<li>使用过程设计描述作为指南，对重要的控制路径进行测试以发现模块内错误。</li>
<li>通常情况下面向白盒的</li>
<li>对代码风格和规则、程序设计结构、业务逻辑等进行静态测试，及早地发现和解决不易显现的错误。</li>
<li>单元测试的内容<ul>
<li>接口测试</li>
<li>内部数据结构</li>
<li>全局数据结构</li>
<li>边界</li>
<li>语句覆盖，错误路径</li>
</ul>
</li>
</ul>
<h3 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h3><blockquote>
<p>自动化测试是把以人为驱动的测试行为转化为机器执行的一种过程。</p>
</blockquote>
<ul>
<li>在设计了测试用例并通过评审之后，由测试人员根据测试用例中描述的规程一步步执行测试，得到实际结果与期望结果的比较。在此过程中，为了节省人力、时间或硬件资源，提高测试效率，便引入了自动化测试的概念。</li>
</ul>
<h3 id="手工和自动化"><a href="#手工和自动化" class="headerlink" title="手工和自动化"></a>手工和自动化</h3><blockquote>
<ul>
<li>手工测试缺点在于测试工作量大，重复多，回归测试难以实现</li>
</ul>
<br>

<ul>
<li>自动测试利用软件测试工具自动实现全部或部分测试工作：管理、设计、执行和报告；节省大量的测试开销，并能够完成一些手工测试无法实现的测试</li>
</ul>
</blockquote>
<br>
<br>

<ul>
<li><p>手工完成测试的全部过程无法保证测试的科学性与严密性:</p>
<ul>
<li>修改缺陷越多，回归测试约困难</li>
<li>没有人能向决策层提供精确的数据以度量当前的工作进度及工作效率</li>
<li>反复测试带来的倦怠情绪及其他人为因素使得测试标准前后不一</li>
<li>测试花费的时间越长，测试的严格性也就越低</li>
</ul>
</li>
<li><p>自动测试将测试人员从反复、烦杂的测试执行中解放出来，用更多的时间进行测试设计和结果分析</p>
<ul>
<li>软件测试不可能全部自动化</li>
<li>不能完成所有手工测试任务</li>
<li>无创造性，且灵活性差，不能改进测试的有效率</li>
<li>过程中可能会遇到很多想不到的问题，尤其是在软件不稳定的情况下</li>
<li>测试脚本的维护高</li>
</ul>
</li>
</ul>
<h3 id="测试用例设计原则"><a href="#测试用例设计原则" class="headerlink" title="测试用例设计原则"></a>测试用例设计原则</h3><ul>
<li><p>单个用例最小化原则</p>
<ul>
<li>这条原则是所有这四条原则中的“老大“，也是在工程中最容易被忘记和忽略的，它或多或少的都影响到其它几条原则。</li>
</ul>
<ul>
<li><p>测试用例的覆盖边界定义更清晰，则测试结果对产品问题的指向性更强。</p>
</li>
<li><p>测试用例间的耦合度最低，则彼此之间的干扰也就越低。</p>
</li>
<li><p>上述这些优点所能带来直接好处是，测试用例的调试、分析和维护成本最低。每个测试用例应该尽可能的简单，只验证你所要验证的内容。</p>
</li>
</ul>
</li>
<li><p>测试用例替代产品文档功能原则</p>
<ul>
<li>通常我们会在开发的初期（Scrum每个Sprint的头两天）用Word文档或者OneNote的记录产品的需求、功能描述、以及当前所能确定的任何细节等信息，勾勒将要实现功能的样貌，便于团队进行交流和细化，并在团队内达成对产品功能共识。但随着产品开发深入，团队会对产品的功能有更新的认识，产品功能也会被更具体细化，在一个迭代或者Sprint结束的时候最终实现的功能很可能是A+。如此往复，在不断倾听和吸收用户的反馈，多个迭代过后，原本被描述为A的功能很可能最终变为了Z。这是时候再去看看曾经的Word文档和OneNote页面，它们仍然记录的是A。之所以会这样 ，是因为很少有人会去以及能够去不断地去更新那些文档，以准确地反映出功能当前准确的状态。</li>
</ul>
</li>
<li><p>单次投入成本和多次投入成本原则</p>
<ul>
<li>成本永远是任何项目进行决策时所要考虑的首要因素，项目中的测试也是如此，对成本的考虑也应该客观和全面的体现在测试的设计、执行和维护的整个阶段中。</li>
<li>测试中的成本按其时间跨度可以分为：单次投入成本和多次投入成本。例如：编写测试用例可以看作是单次投入成本，因为编写测试用例一般是在测试的计划阶段进行（Scrum每个Sprint的开始阶段）的，虽然后期会有小的改动，但绝大多数是在一开始的设计阶段就基本上成型了；</li>
</ul>
</li>
<li><p>使测试结果分析和调试最简单化原则</p>
<ul>
<li>这条原则实际上是单次投入成本和多次投入成本原则 – 针对自动化测试用例的扩展和延续。在编写自动化测试代码时，要重点考虑如何使得测试结果分析和测试调试更为简单，包括：用例日志、调试辅助信息输出等。</li>
</ul>
</li>
</ul>
<h3 id="测试用例方法"><a href="#测试用例方法" class="headerlink" title="测试用例方法"></a>测试用例方法</h3><ul>
<li>等价类划分</li>
<li>等价类划分</li>
<li>错误推测</li>
<li>因果图</li>
<li>判定表驱动分析</li>
<li>正交实验设计</li>
<li>场景设计法</li>
<li>状态转换图</li>
</ul>
<h3 id="测试用例内容"><a href="#测试用例内容" class="headerlink" title="测试用例内容"></a>测试用例内容</h3><p>测试用例主要包括用例编号、用例描述、前提条件、输入数据、测试步骤和期望结果6项关键内容：</p>
<ul>
<li><p>用例编号</p>
<p> 用例的组织要方便测试人员执行测试用例，应设计一套良好的用例编号体系。</p>
</li>
<li><p>用例描述</p>
<p> 用例描述应使用最精简的文字，描述出用例的全貌。让测试人员不用看测试步骤，只看这个描述就可以知道这个用例是描述哪个场景、哪个功能点。</p>
</li>
</ul>
<ul>
<li><p>前提条件</p>
<p> 一个测试用例一般是针对一个特点的场景，而需要测试的场景发生时通常会有一些铺垫场景，即测试用例的前提，如软硬件环境配置、权限设置，数据准备。</p>
</li>
</ul>
<ul>
<li><p>输入数据</p>
<p> 一个测试用例可以有一个或多个输入数据，也可以无输入数据。</p>
</li>
</ul>
<ul>
<li><p>测试步骤</p>
<p> 测试步骤是测试用例的主体，一个测试用例由一个或多个步骤组成，每个步骤之间有一定的前后关系。每个步骤必须表述详细，描述清晰，用于规范、严谨而又客观，最基本的要求是能够使其他人理解，并能正确的执行编写者希望的操作。</p>
</li>
<li><p>期望结果</p>
<p> 期望结果是测试执行对执行结果进行对比的标尺，是测试是否通过的判断依据。测试结果必须保证其正确性。</p>
</li>
</ul>
<h3 id="测试计划"><a href="#测试计划" class="headerlink" title="测试计划"></a>测试计划</h3><p>根据项目相关文档，需要定义测试范围、测试策略、人员分配、软硬件配置、进度表以及测试过程每个阶段需要达到的目标。</p>
<h3 id="查询遗漏问题的方法"><a href="#查询遗漏问题的方法" class="headerlink" title="查询遗漏问题的方法"></a>查询遗漏问题的方法</h3><ul>
<li><p>说明书是基础和标准</p>
<p>  测试的执行，通常按测试用例来进行，但测试用例的设计编写是依据产品规格说明书、需求规格说明书、界面设计规范等。写测试用例时难免有考虑不到的地方，因此反复阅读说明文档，也许会有一些新的思路和启发。在项目后期，回归测试阶段，容易思维定势、疲惫，这是可以把这些文档拿出来，再看一下功能点是否覆盖，覆盖到的是不是和需求一致，没有偏差。</p>
</li>
</ul>
<ul>
<li><p>相关变动邮件，讨论记录</p>
<p>  变动是一个项目过程中不可少的部分，而这些变动，通常是通过讨论的方式定下来的，因此会有一些文档记录和邮件。反复阅读这些邮件和文档记录，可以更深入的理解项目。</p>
</li>
<li><p>不定期阅读别人的缺陷</p>
<p>  每个人的思路、考虑的角度和操作习惯各不相同，因此发现的问题就会不一样。多阅读别人的缺陷可以拓宽思路，看多了，也会不自觉把多种思路集中到一起，慢慢得应用到测试实践中了。</p>
</li>
<li><p>多和开发人员沟通</p>
<p>  功能测试对测试人员来说大多是黑盒测试，只有开发人员最清楚哪个函数调用哪个函数、哪块单元测试不够充分、哪个逻辑结构比较复杂，多和他们沟通，可以知道哪里还需要多关注一下。</p>
</li>
<li><p>有选择的重新验证以前的缺陷</p>
<p>  特别在回归测试、验收测试阶段，除了验证前面发现的缺陷，还要重视那些与缺陷相关的模块。一个底层参数的变动，可能会引起很多相关功能的问题，继而造成缺陷的遗漏。</p>
</li>
<li><p>关注变化</p>
<p>  一段代码的改动，需要开发人员和测试人员去识别。开发人员知道改动的地方会被哪些模块调用或者会引起哪些模块的变化，但由于时间紧、任务重、很难做好单元测试，因此开发人员要通知测试人员需要关注的测试点。</p>
</li>
<li><p>简单思维方式，一主线为主，减少大遗漏</p>
<p>  一个项目的成功不是把缺陷全报出来，而是在有限的代价下达到预期的质量。按计划进行的项目，主要功能的质量在一定程度上决定了产品的好坏。在项目工期紧张时，全部走完所有测试用例是很难的，可以基本功能为主线，做好相关测试用例的执行，保证不会发生大的质量事故。</p>
<p>  在测试后期，测试人员可能对质量已经很有信心，受思维和经验的局限性，可能仅限于此。若此时，在产品发布之前，调动其他组的员工参与限时测试并给予奖励，必然能有效减少软件缺陷带来的风险，提高产品质量。</p>
</li>
</ul>
<h3 id="软件缺陷（bug）"><a href="#软件缺陷（bug）" class="headerlink" title="软件缺陷（bug）"></a>软件缺陷（bug）</h3><p>软件缺陷是指系统或系统部件中那些导致系统或部件不能实现其应有功能的缺陷。一般定义缺陷有以下5条原则：</p>
<ul>
<li><p>软件未实现产品说明书要求的功能。</p>
</li>
<li><p>软件出现产品说明书指明不应该出现的错误。</p>
</li>
<li><p>软件实现了产品说明书未说明的功能。</p>
</li>
<li><p>软件未实现产品说明书虽未明确提及但应该实现的目标。</p>
</li>
<li><p>软件难以理解，不易使用，运行速度慢，或者软件测试员认为最终用户会认为不好。</p>
</li>
</ul>
<h3 id="提交缺陷（bug）的要求"><a href="#提交缺陷（bug）的要求" class="headerlink" title="提交缺陷（bug）的要求"></a>提交缺陷（bug）的要求</h3><p><img src="http://ovlnt0xy1.bkt.clouddn.com/2017-09-21-15059595218432.jpg" alt=""></p>
<p>Bug描述的基本要求是分类准确、叙述简洁、步骤清楚、实际结果描述准确、复杂问题有据可查（截图或其他形式的附件）。基本要求如下：</p>
<ul>
<li><p>问题描述一般格式：模块或功能点=&gt;测试步骤=&gt;期望结果=&gt;实际结果=&gt;其他信息</p>
</li>
<li><p>单一：尽量一个bug只针对一个软件缺陷</p>
</li>
<li><p>简洁：每个步骤尽量简单明了</p>
</li>
<li><p>再现：问题必须能在自己机器上重现方可上报（个别严重问题重现不了也可上报，但必须标明）</p>
</li>
<li><p>复杂问题：附截图补充说明或直接通知指定的修改人，截图文件格式建议用JPG或GIF</p>
</li>
<li><p>报告中不允许使用抽象的词语：“有错误”，“有时候”之类的不确定语句</p>
</li>
</ul>
<br>
<br>


<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ul>
<li><p><a href="http://www.testtao.cn/" target="_blank" rel="noopener">测试之道网</a></p>
</li>
<li><p><a href="https://www.amazon.cn/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF-%E6%A2%85%E8%80%B6/dp/B007VITCNA/ref=sr_1_1?ie=UTF8&qid=1505960207&sr=8-1&keywords=%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF" target="_blank" rel="noopener">软件测试的艺术（第三版）</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>software testing</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试（一）</title>
    <url>/year/09/18/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h3 id="术语："><a href="#术语：" class="headerlink" title="术语："></a>术语：</h3><blockquote>
<p>“软件测试就是证明软件不存在错误的过程。”</p>
<p>“软件测试的目的在于证明软件能够正确完成其预定的功能。”</p>
<p>“软件测试就是建立一个‘软件做了其应该做的’信心的过程。”</p>
</blockquote>
<a id="more"></a>

<p>这些定义都是本末倒置的。 </p>
<p>每当测试一个程序时，应当想到要为程序增加一些价值。通过测试来增加程<br>序的价值，是指测试提高了程序的可靠性或质量。提高了程序的可靠性，是指找 出并最终修改了程序的错误。</p>
<blockquote>
<p>应该一开始就假设程序中隐藏着错误(这种假设对于几乎所有的程序都成立)，然后测试程 序，发现尽可能多的错误。</p>
<br>
定义：**测试就是发现错误而执行程序的过程。**

<p>给自己一个心理设定：就是要找出程序中的错误。</p>
</blockquote>
<p>人类行为总是倾向于具有高度目标性，确立一个正确的目标有着重要的心理 学影响。如果我们的目的是证明程序中不存在错误，那就会在潜意识中倾向于实 现这个目标;也就是说，我们会倾向于选择可能较少导致程序失效的测试数据。 另一方面，如果我们的目标在于证明程序中存在错误，我们设计的测试数据就有 可能更多地发现问题。</p>
<p> <strong>什么是“成功的测试”和“不成功的测试”</strong></p>
<p> 在大多数情况下，未能找出错误的测试被认为是“不成 功的”，这是因为认为软件中不包含错误的观点基本上是不切实际的（例子：患者看病）</p>
<p> 总结：<br> 软件测试更适宜被视为试图发现程序中错误(假设其存在)的破 坏性的过程。一个成功的测试用例，通过诱发程序发生错误，可以在这个方向上 促进软件质量的改进。</p>
<blockquote>
<p>测试投入的目标在 于通过有限的测试用例，最大限度地提高发现的问题的数量，以取得最好的测试 效果。</p>
</blockquote>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>轻</title>
    <url>/year/11/15/%E8%BD%BB/</url>
    <content><![CDATA[<p>意义的原因很可能是意义本身。干吗要有意义？干吗要有生命？干吗要有存在？干吗要有有？重量的原因是引力，引力的原因呢？又是重量。学物理的人告诉我：千万别把运动和能量，以及和时空分割开来理解。我随即得了启发：也千万别把人和意义分割开来理解。不是人有欲望，而是人即欲望。这欲望就是能量，是能量就是运动，是运动就走去前面或者未来。前面和未来都是什么和都是为什么？这必来的疑问使意义诞生，上帝便在第六天把人造成。上帝比靡菲斯特更有力量，任何魔法和咒语都不能把这一天的成就删除。在这一天以后所有的光阴里，你逃得开某种意义，但逃不开意义，如同你逃得开一次旅行但逃不开生命之旅。</p>
<a id="more"></a>

<p>你不是这种意义，就是那种意义。什么意义都不是，就掉进昆德拉所说的“生命不能承受之轻”。你是一个什么呢？生命算是个什么玩意儿呢？轻得称不出一点儿重量你可就要消失。我向L讨回那件东西，归途中的惶茫因年幼而无以名状，如今想来，分明就是为了一个“轻”字：珍宝转眼被处理成垃圾，一段生命轻得飘散了，没有了，以为是什么原来什么也不是，轻易、简单、灰飞烟灭。一段生命之轻，威胁了生命全面之重，惶茫往灵魂里渗透：是不是生命的所有段落都会落此下场啊？人的根本恐惧就在这个“轻”字上，比如歧视和漠视，比如嘲笑，比如穷人手里作废的股票，比如失恋和死亡。轻，最是可怕。</p>
<p>要求意义就是要求生命的重量。各种重量。各种重量在撞墙之时被真正测量。但很多重量，在死神的秤盘上还是轻，秤砣平衡在荒诞的准星上。因而得有一种重量，你愿意为之生也愿意为之死，愿意为之累，愿意在它的引力下耗尽性命。不是强言不悔，是清醒地从命。神圣是上帝对心魂的测量，是心魂被确认的重量。死亡光临时有一个仪式，灰和土都好，看往日轻轻地蒸发，但能听见，有什么东西沉沉地还在。不期还在现实中，只望还在美丽的位置上。我与L的情谊，可否还在美丽的位置上沉沉地有着重量？</p>
]]></content>
  </entry>
  <entry>
    <title>弗洛姆-《逃避自由》</title>
    <url>/year/12/17/%E9%80%83%E9%81%BF%E8%87%AA%E7%94%B1/</url>
    <content><![CDATA[<blockquote>
<p>我没有身份，根本没有我自己，我不过是他人希望我什么的一种反映；我是「如同你希望的」。</p>
</blockquote>
<a id="more"></a>

<p>自由意志的虚幻性，它的可怕之处就在于很多人都没有意识到这一点。 </p>
<p>在现代社会中，人们似乎拥有了「可以不做什么」的自由，似乎可以按照自己的想法而活，但真是如此吗？想想我们自己所做的那些决定吧，学习，工作，赚钱，买房，结婚，生子……究竟是出自内心的真实想法还是仅仅为了过上他人眼中「正常的生活」？我们拼命工作，戴上面具进行各种表演，为了「责任」而放弃乐趣和幸福，难道真是为了不愧对自己这一生？ </p>
<p>与外在权威相对应，弗洛姆把公共舆论和大众意识称为「匿名权威」，这股看不见的力量正是操控我们生活的幕后黑手，一举剥夺了我们感觉，思考和意志的真实性。我们无可救药地「按照他人的要求对自己的一切作出规划，被孤独感，恐惧感和各种直接威胁着我们的自由，生命和舒适的力量所驱使」；我们欺骗自己找到了为之拼命奋斗的自我，最后却发现那只不过是社会的自我。 </p>
<p>金钱，地位，权力，家庭，民族，偶像……支撑起了我们脆弱的生活，依靠这些外在的力量，我们获得了安全感，当然同时也放弃了自由。但是，「这种安全感只是表面上的，一旦支撑它的那些因素不存在了，安全感也随之消失」。 可是另一条路也布满了荆棘，物质上的损失倒是小事，不被人理解的孤独和不安定的生活并不是每个人都能坦然接受的。 </p>
<p>弗洛姆给出的药方是投身于自发性的活动，也即爱和创造性活动，在这种积极的自由状态下，我们按自己内心生活，同时也能感知和世界，他人的紧密联系。他觉得艺术家和小孩子是积极自由的典型代表。 </p>
<p>但我觉得弗洛姆太过理想化了，要不怎么会在七十多年后的今天，很多人依旧会迷茫，会不快乐呢？对于绝大多数人来说，这就是一个残酷的选择题：逃避自由，还是忍受孤独？而很多人还是会选择前者，也正常，追寻自由的代价太大，倒不如糊涂一世来得安稳。「为自己而活」这几个字说得轻巧，真要做到太不容易，所以每个人的选择我也都能理解。只是可笑人们追寻了那么久的自由，到头来仍是镜花水月。 </p>
<p>但希望总是有的，正如弗洛姆说到自发性给我们带来的欢乐：「我们多数人至少可以在刹那间察觉到我们自身的自发性，而正是在这刹那间，我们获得了真正的欢乐。」 </p>
<p>幸运的是，还有人愿意坚持把这一刹那变为永恒。这样的人从来都不会很多，但有这么一群人就足够了。</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>逃避自由书摘</title>
    <url>/year/11/27/%E9%80%83%E9%81%BF%E8%87%AA%E7%94%B1%E4%B9%A6%E6%91%98/</url>
    <content><![CDATA[<ul>
<li><p>由于想超越自然，想脱离自然及其他的人类。使他裸露，使他觉得羞耻。他是孤独而自由的，但也是无权力和恐惧的。新获得的自由显然像是一个惩罚；他脱离天堂的可爱的枷锁，获得了自由，但是他却不能自由地去管理自己，去实现他的“个人人格”。</p>
</li>
<li><p>他属于而且根深蒂固地生活在一个有组织的整体中，在这个整体中，他拥有一个无可怀疑的位置。他可能受到饥饿或压迫的痛苦，但是，他不会受到所有痛苦中最痛苦的一种——那就是全然的孤独与怀疑。</p>
</li>
</ul>
<a id="more"></a>

<ul>
<li><p>这种日益个人化的过程，却意味着日渐的孤独、不安全，和日益怀疑他在宇宙中的地位，生命的意义，以及日益感到自己的无权力及不重要。</p>
</li>
<li><p>以一个自由而独立的个人身分，再度把他与世界连接起来。</p>
</li>
<li><p>如果人类个人化过程所依赖的经济，社会与政治环境（条件），不能作为实现个人化的基础，而同时人们又已失去了给予他们安全的那些关系（束缚），那么这种脱节的现象将使得自由成为一项不能忍受的负担。于是自由就变成为和怀疑相同的东西，也表示一种没有意义和方向的生活。这时，便产生了有力的倾向，想要逃避这种自由，屈服于某人的权威下，或与他人及世界建立某种关系，使他可以解脱不安之感，虽然这种屈服或关系会剥夺了他的自由。</p>
</li>
<li><p>由于人从生下来开始，在社会中便有一个明确的、不会改变的和没有疑问的位置，他已经生根在一个结构固定的整体中，所以，生活是有意义的</p>
</li>
<li><p>社会秩序被视为如同一种自然秩序，而人成为社会秩序中的一个确定的部分，使人有安全和相属之感</p>
</li>
<li><p>“在中世纪，人性意识的两个方面——对内与对外——都是像做梦似的或半醒状态地卧在一张共同的面纱下。这个面纱是用信仰、幻觉、和幼稚的先入之见所编织成的，透过这具面纱，世界和历史看起来都是披着奇怪的色彩。人只能意识到他自己是一个种族。民族、党派、家族或社会集团的一份子——人只有透过某普通的种类，来认识自己。”</p>
</li>
<li><p>个人之脱离原始关系（束缚）。人发现他自己与他人是“分开而独立的人”</p>
</li>
<li><p>如果一个人可以希望，他的名能永垂不朽，那么，他的生命便可籍着别人的判断对他生命的反应，而获得意义，和重要性</p>
</li>
<li><p>效率的观念成为最高德行的一种。同对，追求财富与物质成功的欲望，成为最吸引人的一种热望</p>
</li>
<li><p>由于人失去了他在一个封闭社会中的固定地位，他也失去他生活的意义，其结果是，他对自己和对生活的目的感到怀疑。</p>
</li>
<li><p>他自由了，但这也就表示，他是孤独的、隔离的，受到来自各方面的威胁。他没有文艺复兴时代财主所拥的财富或权力，也失去与人及宇宙的同一感，于是，一种他个人无价值和无可救药的感觉压倒了他。</p>
</li>
<li><p>他充满一种极端孤独、无权力、软弱的感觉，而同时又满身是想要统治的欲望。他受到疑虑的煎熬，同时，他不断地追求某种能给予他安全，和使他解脱疑虑之折磨的事物。他恨其他的人，尤其是“贱民”，他恨他自己，他恨生命；由这种恨，产生了想要被爱的迫切欲望。他整个的人都被恐惧、怀疑和内在的孤独所充满了。</p>
</li>
<li><p>路德宣称“敬神的人没有‘自由意志’，而是上帝意志，或撒旦意志的俘虏、奴隶、和仆人。”（同前注）。路德认为，人不过是上帝手中的一个无权力的工具，人是本性邪恶的，人的惟一职责便是服从上帝的意旨，上帝以无比之正义行为，拯救人类。</p>
</li>
<li><p>惟有当个人成为一个有意义的世界的一部分时，这种非理性的怀疑才会消失。如果一个人不能这样地与一个有意义的世界结合为一体——正如同路德和他所代表的中产阶级不能做到这一点——那么，怀疑便会被压抑转入地下，而想要压制怀疑的方法，就是保证给予绝对的肯定。</p>
</li>
<li><p>只要人一天不能克服他的孤立，只要他在世界的地位一天不能成为有意义，怀疑的本身便一天不会消失。</p>
</li>
<li><p>人解脱了一切使他必须服从精神权威的束缚（关系），但是这种自由也使他处放孤独与焦虑的状态中，使他觉得个人的不重要与无权力。这种个人觉得无关重要的经验，把一个自由而孤独的个人给压垮了。</p>
</li>
<li><p>如果你可以完全抹杀自己，摆脱一切个人的缺点和怀疑，你便会不再觉得自己无价值，于是可以得到上帝的荣耀。</p>
</li>
<li><p>“上帝知道政府是罪恶的，但是他并不计较政府是多么的罪恶，仍希望有个政府，而不愿让暴民去暴动，虽然，他们可能有充分的理由去暴动……君主不可废除，虽然他可能是万分暴虐的。必要时，他可以下令斩首一些人，因为他必须有属民，以便可以做一个统治者。”</p>
</li>
<li><p>努力与工作完全是无理性的。工作与努力的目的不是想要改变命运，因为命运早已由上帝决定了。努力与工作不过是一种预算已定之命运的方法而已；同时，这种发狂的努力是为了逃避一种无法忍受的无能为力感。</p>
</li>
<li><p>“良知”是驱策奴隶工具，它驱使人自以为是按照自己的希望与目标而活动，其实，这些希望与目标不过是外在社会要求的“普遍化”而已。“良知”残忍而无情地驱策着人，禁止他享受乐趣和幸福，使人的整个生活作为某种神秘罪恶的补偿。</p>
</li>
<li><p>要完全地承认自己的无权力和本性的邪恶，要认为他的整个生命是为赎罪而有的，要羞侮自己，而且还要不停地努力——藉着这种种做法，人才能克服他的怀疑与焦虑；必须完全地屈服，才能得到上帝的宠爱，或者至少可以希望能属于获救的一类人物中。</p>
</li>
<li><p>新的宗教教条是在中古社会制度的瓦解及资本主义的逐渐抬头之下的一种人类心理上的需求。</p>
</li>
<li><p>个人虽然得到了不受牵制的一种新的生活自由，却也同时感到孤独彷徨，内心充满焦急忧虑，必使他一再屈服于新的环境，而终至作出冲动及不理智的事情来。</p>
</li>
<li><p>中古世纪，人们的等级在一出世即已决定，个人的一生命运已非自己所能掌握。而在资本主义社会中，虽然限制很多，但个人的努力和所作所为，是成功的惟一要素，特别是中产阶级的人，成功的机会更多。</p>
</li>
<li><p>中古时代的社会，人是资本的主宰，而在现代社会中，人已被资本所凌驾。中世纪的人，以经济为工具，来达到提高宗教生活的目的，也就是以经济为基础，从事许多觅求精神解脱的宗教活动。</p>
</li>
<li><p>资本主义的经济制度，是为赚钱而赚钱的，个人的成功与物质所得，只是构成与促进整个经济发展的一份子，谈不上解脱或享乐。个人就像是大机器中的一个齿轮一样，其重要性决定于他的资本的多寡，资本多的就成为一个重要的齿轮，资本少的就无足轻重了。</p>
</li>
<li><p>今天的人类，只是把过去一直是侍奉上帝的观念，转而为侍奉现代的经济制度而已，永远成为这个大机械的奴隶。</p>
</li>
<li><p>广义的说：增加资本对于全人类的进展有许多裨益，而狭义的看，则个人永远是他所建造的这个大机体中的奴仆，毫无个人利益，因而使个人感到生活空虚，无力可施</p>
</li>
<li><p>“自私就是爱自己”，爱别人是美德，而爱自己是一种罪行，同时，“爱别人”与“爱自己”是互相冲突的。</p>
</li>
<li><p>自私乃产生于一种对生命缺乏目标以及不知如何去爱真正的自我所造成，一般人之所谓“自我”只是广义的，属于社会的“自我”，是一个被社会所固定后而不得不依样去扮演的“自我”，而毫无自主的余地，因而，人往往会在这种呆滞的社会形态下去找寻漏洞，企图寻求利己的事物，“自私”心理遂乃产生。</p>
</li>
<li><p>人类的逐渐征服大自然，是否也增加了“个人”在社会的地位和能力呢？我想大体上说是增加了。但是，虽然人类已创造出许多力量，征服了大自然，但却不能自己控制这些力量。人类运用智慧，开创了许多科学的发明，但一方面却又毫无理智地用这些科学发明或科学知识来毁坏自己，所谓经济危机，人力膨胀，战争等等。常常环绕在我们四周。人类建造了这个世界，设立工厂，发明汽车，缝制衣服，耕种稻麦，可是，这一个由自己双手所建造起来的世界却已不由我们自己主宰了，而是使这个世界成了我的主宰，任由其摆布。人类幻觉中以为自己是世界的中枢，实际上却有一种强烈的孤独、彷徨和无权之感。遂使人与人之间趋于疏淡，只有彼此互相利用的价值了。</p>
</li>
<li><p>至于雇主与受雇者之间的关系亦复如是，彼此毫不关心，资本家雇用一个人，就如同使用一部机器一样，彼此互相利用，各为其经济利益而奋斗。他们之间，都把对方当作做具，以求达到自己的目的。而商人与顾客之间也是这种关系，商人把顾客当做操纵的对象，而不是为了大众的利益作牺牲的。至于人们对于“工作”的态度也是如此，目前的制造商与中古时期大异其趣，以从事工艺的人来说，中古时期的人，不但要以产品赚钱，并且也对工作发生兴趣，成为一种嗜好，而现代人则纯以它为一种商业投资，只求赚钱，从不谈兴趣与否。</p>
</li>
<li><p>人与人之间的关系日趋淡薄，而最重要的，是人类与其本身的关系日谈所致，因为人类似乎不是在出卖他所制造的货物，而是在出卖他自己，他感觉到，他把自己也像货物一样的在出卖给别人，譬如：工人出卖劳力，商人、医生、普通职员等都在出卖灵魂，人的价值各因环境及才能而异。才能须与环境配合，如果在某一环境中不需要某一类人才，则他的才能即毫无价值，就像货品一样，不买的人是对它不予估价的。所以，人的自身无法为自己估价，行情好，价格就高，行情不景，则乏人问津，而越是大众化，有名气的则愈被钟爱，这就是为什么“大众欢迎”四字是那么重要的原因了。</p>
</li>
<li><p>人如何才能在这种社会现象之下感到有安全感呢？第一，他必须要有财产，譬如衣物及房地是其财产之一部分，他如拥有的愈多，安全感也随之愈强，如果没有财产，或失去了所有的，则他自己和他以外的别人都会觉得是一个不完整的人。其次是权位及声望，此两者一方面是视同个人财产之另一部分外，也是他在与人竞争之中成败的关键，被人赞赏及有驾驭人的权力，是稳固及增加财产的象征。</p>
</li>
<li><p>至于一般财产不多，声望不高的人，则以家庭为施展之所，在家庭中受到妻子儿女的尊敬与服从，从事领导统御，发泄了内心的领导欲。他在外也许不太有地位，但在家中却是“王”。另有一些人，曾经获得国家授予之荣衔，也自认为了不起，像欧洲国家的阶衔制度，得到爵位的人则往往自妄自大，目中无人。</p>
</li>
<li><p>人类之自由，若从它的积极意义看来，是在获得人性尊严及个人力量。</p>
</li>
<li><p>一般人工作之余，尽量参加社团活动，与外界建立各种社会关系，不断接触，尽情享乐，到处游历，而孤寂感暂时不会产生。然而，在心灵的深处，仍充满了空虚，恐惧，与孤寂感，迫使我们时时企图挣脱这种精神上的压力。而去争取新自由。</p>
</li>
<li><p>所谓正常或健康其定义可分为二，第一站在社会功用的立场言，一个正常或健康的人只要履行其社会上应尽的义务即可。更具体的讲，即一个只要能符合其特定社会需要，能参与其社会的再造，换言之，即是能够养家，便是一健康之人。另外，从个人的观点看，对个体的成长与幸福最适宜的条件即为健康与正常。</p>
</li>
<li><p>一个是以社会需要为准则，另外一个则以与个体生存之目的有关的价值与标准为准则。</p>
</li>
<li><p>如果我们将正常者与精神病者加以区别，可得下列之结论。一个适应性好的正常人反而不如一个有人类价值的精神病者健康。一个适应性好的人常常抛弃其原来的真面目，希求逐渐改变成其希望中的人，以至所有纯真的特性与自然个性一扫而尽，然而在精神病者而言，他们并未完全屈服于为自己的战斗中，虽然这种战斗并未成功，但为了拯救自己乃至于产生精神病的症候，并将自己投入一个幻想的生活中，因此，如站在人类价值的立场而言，这些人比起那些失去个性的正常人还要来得活力。</p>
</li>
<li><p>组成分子如不能正常的发展其人格，则该社会即非正常者，因此缺乏社会功能就谓之不健全，</p>
</li>
<li><p>当个人一旦失去了原始的关联，并因而感到不安全时，立刻即会产生无能为力与孤独之感之双重现象，必须克服这种感觉的方法有二：一个自然就是靠自己与世间的爱去工作，很真诚的去表现情绪、感觉与智能，他可以无须放弃其个体的独立与完整而再度恢复其本来面目。另外，就只有后退，放弃其自由，并努力去克服其与外界隔离而造成的孤独现象，但后者却因个体已与世界分开，很难再与世界合而为一。这是一种企图逃避无法忍受情况的行为，如果，无法忍受的情况一直存在的话，则生活将成为苦不堪言的。这种逃避的特点是强制性的，正如同逃避恐怖一样，其特性是完全放弃自己的个性与完整性，这个并不是可导致幸福与积极的自由的解决办法，却是所有在不健全现象中可以发现到的一种解决办法。它的目的是想减轻生活上焦躁不安，避免恐慌，但实际上并不能解决问题，只不过是一种自动与强制生活的产物而已。</p>
</li>
<li><p>他开始朦胧地发觉自己——或者可以说，发觉他的团体——与大自然不是同一的。他渐渐地明白，他的命运是悲剧性的：既是自然的一部，又要超越自然。他开始发觉，死亡是他的最后命运，虽然他试图以各种幻想，来否认这项事实。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>阿飞正传台词</title>
    <url>/year/01/10/%E9%98%BF%E9%A3%9E%E6%AD%A3%E4%BC%A0%E5%8F%B0%E8%AF%8D/</url>
    <content><![CDATA[<blockquote>
<p>“我听别人说这世界上有一种鸟是没有脚的，它只能够一直的飞呀飞呀，飞累了就在风里面睡觉，这种鸟一辈子只能下地一次，那一次就是它死的时候。”</p>
<p>“以前我以为有一种鸟从一开始飞就可以飞到死的一天才落地，其实他什么地方都没有去过，这只鸟从一开始就已经死了。”</p>
</blockquote>
<a id="more"></a>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1944473&auto=1&height=66"></iframe>

<h4 id="一分钟"><a href="#一分钟" class="headerlink" title="一分钟:"></a>一分钟:</h4><p>张国荣：十六号，四月十六号。一九六零年四月十六号下午三点之前的一分钟你和我在一起，因为你我会记住这一分钟。从现在开始我们就是一分钟的朋友，这是事实，你改变不了，因为已经过去了。我明天会再来。<br>　　<br>张曼玉独白：我不知道他有没有因为我而记住那一分钟，但我一直都记住这个人。之后他真的每天都来，我们就从一分钟的朋友变成两分钟的朋友，没多久，我们每天至少见一个小时。 </p>
<p>张曼玉：我以前以为一分钟很快就会过去，其实是可以很长的。有一天有个人指着手表跟我说，他说会因为那一分钟而永远记住我，那时候我觉得很动听…但现在我看着时钟，我就告诉自己，我要从这一分钟开始忘掉这个人。 </p>
<p>刘德华：“去年四月十六号三点你在做什么？”<br>张国荣说：“她告诉你的啊”<br>　　<br>“要记得的我永远都会记得。”</p>
<h4 id="妥协"><a href="#妥协" class="headerlink" title="妥协:"></a>妥协:</h4><p>张曼玉：我想搬到这里和你一起住。<br>张国荣：好。<br>张曼玉：那我怎样跟我爸说呀？<br>张国荣：说什么？<br>张曼玉：我们的事呀。<br>张国荣：我们的什么事？<br>。。。<br>张曼玉：你会不会和我结婚？<br>张国荣：不会<br>张曼玉：我以后不会再来了</p>
<p>张曼玉：我还是想搬到这里和你一起住。<br>张国荣：我不会和你结婚<br>张曼玉：不结婚也没关系，我就是想和你在一起<br>张国荣：你能容忍一刻，难道你一辈子不结婚？ </p>
<h4 id="那只鸟"><a href="#那只鸟" class="headerlink" title="那只鸟:"></a>那只鸟:</h4><p>“我听别人说这世界上有一种鸟是没有脚的，它只能够一直的飞呀飞呀，飞累了就在风里面睡觉，这种鸟一辈子只能下地一次，那一次就是它死的时候。”</p>
<p>“以前我以为有一种鸟从一开始飞就可以飞到死的一天才落地，其实他什么地方都没有去过，这只鸟从一开始就已经死了。” </p>
<h4 id="生母"><a href="#生母" class="headerlink" title="生母:"></a>生母:</h4><p>张国荣从母亲家里出来后，那一段的独白：我终于来到亲生母亲的家了，但是她不肯见我，佣人说她已经不住这里了。当我离开这房子的时候，我知道身后有一双眼睛盯着我，但我是一定不会回头的。我只不过想见见她，看看她的样子，既然她不给我机会，我也一定不会给她机会。</p>
<h4 id="无情"><a href="#无情" class="headerlink" title="无情:"></a>无情:</h4><p> 张国荣：你走出去以后就不要再回来了。<br> 刘嘉玲：你是不是对每个女人都是这样子。</p>
<p>  张国荣：我这一辈子不知道还会喜欢多少个女人，不到最后我也不知道会喜欢哪一个。 </p>
<h4 id="两个女人"><a href="#两个女人" class="headerlink" title="两个女人:"></a>两个女人:</h4><p>张曼玉：坐一会儿好了，过会我们要关门了。 </p>
<p>刘嘉玲：其实我不应该来的，我不应该给你一个痛快的机会。不过我始终觉得他爱我多一点，说到底他是因为我而离开你的。<br>张曼玉：这种事，早点知道比晚点知道要好。现在哭的是你又不是我。我已经没事很久了。 </p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title>青春</title>
    <url>/year/04/12/%E9%9D%92%E6%98%A5/</url>
    <content><![CDATA[<p><img src="https://blog-1256335675.cos.ap-chengdu.myqcloud.com/2019-06-18-006tKfTcgy1fq9pshwuo2j30rl0b3jtc.jpg" alt=""></p>
<a id="more"></a>

<p>《青春》 </p>
<p>Samuel Ullman  </p>
<p>文/塞缪尔·厄尔曼 </p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=200 height=86 src="//music.163.com/outchain/player?type=2&id=26145696&auto=1&height=66"></iframe>

<p>青春不是年华，而是心境；青春不是桃面、丹唇、柔膝，而是深沉的意志，恢宏的想 </p>
<p>象，炙热的恋情；青春是生命的深泉在涌流。 </p>
<p>青春气贯长虹，勇锐盖过怯弱，进取压倒苟安。如此锐气，二十后生而有之，六旬男子 </p>
<p>则更多见。年岁有加，并非垂老，理想丢弃，方堕暮年。 </p>
<p>岁月悠悠，衰微只及肌肤；热忱抛却，颓废必致灵魂。忧烦，惶恐，丧失自信，定使心 </p>
<p>灵扭曲，意气如灰。 </p>
<p>无论年届花甲，拟或二八芳龄，心中皆有生命之欢乐，奇迹之诱惑，孩童般天真久盛不 </p>
<p>衰。人人心中皆有一台天线，只要你从天上人间接受美好、希望、欢乐、勇气和力量的 </p>
<p>信号，你就青春永驻，风华常存。 </p>
<p>一旦天线下降，锐气便被冰雪覆盖，玩世不恭、自暴自弃油然而生，即使年方二十，实 </p>
<p>已垂垂老矣；然则只要树起天线，捕捉乐观信号，你就有望在八十高龄告别尘寰时仍觉 </p>
<p>年轻。 </p>
<p><br><br></p>
<p>【原文】 </p>
<br>

<p>《YOUTH》 </p>
<p>Samuel Ullman </p>
<p>Youth is not a time of life; it is a state of mind; it is not a matter of </p>
<p>rosy cheeks, red lips and supple knees; it is a matter of the will, a </p>
<p>quality of the imagination, a vigor of the emotions; it is the freshness of </p>
<p>the deep springs of life. </p>
<p>Youth means a tempera-mental predominance of courage over timidity, of the </p>
<p>appetite for adventure over the love of ease. This often exists in a man of </p>
<p>60 more than a boy of 20. Nobody grows old merely by a number of years. We </p>
<p>grow old by deserting our ideals. </p>
<p>Years may wrinkle the skin, but to give up enthusiasm wrinkles the soul. </p>
<p>Worry, fear, self-distrust bows the heart and turns the spring back to dust. </p>
<p>Whether 60 or 16, there is in every human being’s heart the lure of wonder, </p>
<p>the unfailing childlike appetite of what’s next and the joy of the game of </p>
<p>living. In the center of your heart and my heart there is a wireless </p>
<p>station: so long as it receives messages of beauty, hope, cheer, courage and </p>
<p>power from men and from the Infinite, so long are you young. </p>
<p>When the aerials are down, and your spirit is covered with snows of cynicism </p>
<p>and the ice of pessimism, then you are grown old, even at 20, but as long as </p>
<p>your aerials are up, to catch waves of optimism, there is hope you may die </p>
<p>young at 80.</p>
<div align=center>    
![](https://blog-1256335675.cos.ap-chengdu.myqcloud.com/2019-06-18-006tKfTcgy1fq9pv3y2hyj307407vq31.jpg)



]]></content>
      <tags>
        <tag>诗</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac下IDEA2018.3破解方法</title>
    <url>/year/01/27/idea%E6%BF%80%E6%B4%BB/</url>
    <content><![CDATA[<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkqvjktslj30ns03oweq.jpg" alt=""></p>
<a id="more"></a>

<p>下载最新版的<a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">idea</a>，安装。这里就不多介绍了。</p>
<h4 id="开始破解："><a href="#开始破解：" class="headerlink" title="开始破解："></a>开始破解：</h4><p>1.下载破解补丁文件 <a href="http://idea.lanyus.com/" target="_blank" rel="noopener">JetbrainsIdesCrack-4.2-release-sha1</a>，记得下载最新的哦。<br>2. 下载好之后拷贝到idea的bin目录<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkqenqetcj31a00u0dyo.jpg" alt=""><br>3. 编辑<code>bin</code>目录下的<code>idea.vmoptions</code>文件，添加<code>-javaagent:JetbrainsIdesCrack-4.2-release-sha1.jar</code></p>
<p>注：-javaagent:跟自己下载的破解补丁的版本。<br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkqh5o8zqj315s0t47h9.jpg" alt=""></p>
<p>保存后重新打开<code>idea</code>再到<a href="http://idea.lanyus.com/" target="_blank" rel="noopener">这里</a>复制激活码到<code>Activation code</code>里点击ok就大功告成了。</p>
<p>或者，直接复制这个：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">K71U8DBPNE-eyJsaWNlbnNlSWQiOiJLNzFVOERCUE5FIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiR08iLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJSU1UiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifV0sImhhc2giOiI4OTA4Mjg5LzAiLCJncmFjZVBlcmlvZERheXMiOjAsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-Owt3/+LdCpedvF0eQ8635yYt0+ZLtCfIHOKzSrx5hBtbKGYRPFDrdgQAK6lJjexl2emLBcUq729K1+ukY9Js0nx1NH09l9Rw4c7k9wUksLl6RWx7Hcdcma1AHolfSp79NynSMZzQQLFohNyjD+dXfXM5GYd2OTHya0zYjTNMmAJuuRsapJMP9F1z7UTpMpLMxS/JaCWdyX6qIs+funJdPF7bjzYAQBvtbz+<span class="number">6</span>SANBgN36gG1B2xHhccTn6WE8vagwwSNuM70egpahcTktoHxI7uS1JGN9gKAr6nbp+<span class="number">8</span>DbFz3a2wd+XoF3nSJb/d2f/<span class="number">6</span>zJR8yJF8AOyb30kwg3zf5cWw==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/<span class="number">5</span>oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/<span class="number">78</span>TmVqFl8nOeD5+<span class="number">07</span>B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/<span class="number">8</span>vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+<span class="number">0</span>gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+<span class="number">2</span>yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++<span class="number">2</span>+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog==</span><br></pre></td></tr></table></figure>

<h4 id="破解成功："><a href="#破解成功：" class="headerlink" title="破解成功："></a>破解成功：</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkqj9k16fj313b0u0ah7.jpg" alt=""></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>无题</title>
    <url>/year/11/15/%E6%97%A0%E9%A2%98/</url>
    <content><![CDATA[<p>从某种角度来讲，一个人之所以是他自己而不是别的什么人，在于他只能经历他所经历的事，所以一个人做什么事就在很大程度上决定着这个人是什么样的人。</p>
<a id="more"></a>

<p>我的头脑有些混乱了，事件与个体之所是，这正是我在想的问题，以及我所想与我所是。可能每个点单独拎出来都可以长篇大论一番吧！我已经厌倦了长篇大论、喋喋不休…</p>
<p>不知道从什么时候开始，对时间就产生了一种恐惧。好像在我面前有一个漏斗，好像在说你的时间正在一天天的逝去，而你… 你在自己的岁月里却没有成为那个最想成为的自己。</p>
<p>我想可能与年龄有关，在世俗的领域里一个人到了某个年纪就该干什么事，然而… 问题就出在了本该做些什么的年纪却什么也没有去做。</p>
<p>为什么一定要去做些什么呢？</p>
<p>人的存在总在行动中，即使不去做些什么，事实上只是做了自认为没有做些什么的事而没有去做自认为应该去做些什么的事而已！而很多事情都不由得自己想要去做或者应该做就可以去做，对的时间、地点、人。好像一切都在一个超出人类智力理解范围的复杂网络里遵循着某种规定，而作为独特个体的人所有的困惑全在于不能理解这种规定。</p>
<p>也许能理解，以一种自以为理解的方式。或者真的理解了，只要永远不去思考…</p>
<p>前段时间读到一句很治愈的话 —— “我不在幻想了，也获得了很多平静。“我也以为自己可以不再幻想，从而获得许多内心的平静。可是我错了，我还没有找到一种确实的生活，而不再去幻想其他的可能的生活，对我来说就是一种置之不理，随波逐流的态度来放任自己。</p>
<p>我还是经常幻想一种我所能幻想的美好生活，还是时常拷问自己所是的哪种自己的才更接近自己。只是我还没有足够的能力去实现它，而关于自我 —— 每个自我都跑出来喊着那个才是我，事实上他们都是，或者都不是…</p>
<p>我不知道，我只是在时间的混流中遵循着自我的意志，也许在某刻我所幻想的一切已被我实现，然而我却厌倦了当时所幻想的一切呢？</p>
]]></content>
  </entry>
  <entry>
    <title>【转】Vim from zero to hero - Vim 从入门到精通</title>
    <url>/year/01/20/Vim-from-zero-to-hero-Vim-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</url>
    <content><![CDATA[<p><img src="http://ovlnt0xy1.bkt.clouddn.com/2018-04-12-15235438494047.jpg" alt=""></p>
<a id="more"></a>

<blockquote>
<p>Vim from zero to hero - Vim 从入门到精通</p>
</blockquote>
<ul>
<li>原文地址：<a href="https://github.com/mhinz/vim-galore" target="_blank" rel="noopener">https://github.com/mhinz/vim-galore</a></li>
<li>原文作者：Marco Hinz</li>
</ul>
<!-- vim-markdown-toc GFM -->

<ul>
<li><a href="#简介">简介</a><ul>
<li><a href="#什么是-vim">什么是 Vim？</a></li>
<li><a href="#vim-哲学">Vim 哲学</a></li>
<li><a href="#入门">入门</a></li>
<li><a href="#精简的-vimrc">精简的 vimrc</a></li>
<li><a href="#我正在使用什么样的-vim">我正在使用什么样的 Vim</a></li>
<li><a href="#备忘录">备忘录</a></li>
</ul>
</li>
<li><a href="#基础">基础</a><ul>
<li><a href="#缓冲区窗口标签">缓冲区，窗口，标签</a></li>
<li><a href="#已激活已载入已列出已命名的缓冲区">已激活、已载入、已列出、已命名的缓冲区</a></li>
<li><a href="#参数列表">参数列表</a></li>
<li><a href="#按键映射">按键映射</a></li>
<li><a href="#映射前置键">映射前置键</a></li>
<li><a href="#寄存器">寄存器</a></li>
<li><a href="#范围">范围</a></li>
<li><a href="#标注">标注</a></li>
<li><a href="#补全">补全</a></li>
<li><a href="#动作操作符文本对象">动作，操作符，文本对象</a></li>
<li><a href="#自动命令">自动命令</a></li>
<li><a href="#变更历史跳转历史">变更历史，跳转历史</a></li>
<li><a href="#内容变更历史记录">内容变更历史记录</a></li>
<li><a href="#全局位置信息表局部位置信息表">全局位置信息表，局部位置信息表</a></li>
<li><a href="#宏">宏</a></li>
<li><a href="#颜色主题">颜色主题</a></li>
<li><a href="#折叠">折叠</a></li>
<li><a href="#会话">会话</a></li>
<li><a href="#局部化">局部化</a></li>
</ul>
</li>
<li><a href="#用法">用法</a><ul>
<li><a href="#获取离线帮助">获取离线帮助</a></li>
<li><a href="#获取离线帮助补充">获取离线帮助（补充）</a></li>
<li><a href="#获取在线帮助">获取在线帮助</a></li>
<li><a href="#执行自动命令">执行自动命令</a><ul>
<li><a href="#用户自定义事件">用户自定义事件</a></li>
<li><a href="#事件嵌套">事件嵌套</a></li>
</ul>
</li>
<li><a href="#剪切板">剪切板</a><ul>
<li><a href="#剪贴板的使用windows-osx">剪贴板的使用（Windows, OSX）</a></li>
<li><a href="#剪贴板的使用linux-bsd-">剪贴板的使用（Linux, BSD, …）</a></li>
</ul>
</li>
<li><a href="#打开文件时恢复光标位置">打开文件时恢复光标位置</a></li>
<li><a href="#临时文件">临时文件</a><ul>
<li><a href="#备份文件">备份文件</a></li>
<li><a href="#交换文件">交换文件</a></li>
<li><a href="#撤销文件">撤销文件</a></li>
<li><a href="#viminfo-文件">viminfo 文件</a></li>
<li><a href="#临时文件管理设置示例">临时文件管理设置示例</a></li>
</ul>
</li>
<li><a href="#编辑远程文件">编辑远程文件</a></li>
<li><a href="#插件管理">插件管理</a></li>
<li><a href="#多行编辑">多行编辑</a></li>
<li><a href="#使用外部程序和过滤器">使用外部程序和过滤器</a></li>
<li><a href="#cscope">Cscope</a><ul>
<li><a href="#1-构建数据库">1. 构建数据库</a></li>
<li><a href="#2-添加数据库">2. 添加数据库</a></li>
<li><a href="#3-查询数据库">3. 查询数据库</a></li>
</ul>
</li>
<li><a href="#matchit">MatchIt</a><ul>
<li><a href="#在-vim-8-中安装">在 Vim 8 中安装</a></li>
<li><a href="#在-vim-7-或者更早的版本中安装">在 Vim 7 或者更早的版本中安装</a></li>
<li><a href="#简短的介绍">简短的介绍</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#技巧">技巧</a><ul>
<li><a href="#聪明地使用-n-和-n">聪明地使用 n 和 N</a></li>
<li><a href="#聪明地使用命令行历史">聪明地使用命令行历史</a></li>
<li><a href="#智能-ctrl-l">智能 Ctrl-l</a></li>
<li><a href="#禁用错误报警声音和图标">禁用错误报警声音和图标</a></li>
<li><a href="#快速移动当前行">快速移动当前行</a></li>
<li><a href="#快速添加空行">快速添加空行</a></li>
<li><a href="#快速编辑自定义宏">快速编辑自定义宏</a></li>
<li><a href="#快速跳转到源头文件">快速跳转到源(头)文件</a></li>
<li><a href="#在-gui-中快速改变字体大小">在 GUI 中快速改变字体大小</a></li>
<li><a href="#根据模式改变光标类型">根据模式改变光标类型</a></li>
<li><a href="#防止水平滑动的时候失去选择">防止水平滑动的时候失去选择</a></li>
<li><a href="#重新载入保存文件">重新载入保存文件</a></li>
<li><a href="#更加智能的当前行高亮">更加智能的当前行高亮</a></li>
<li><a href="#更快的关键字补全">更快的关键字补全</a></li>
<li><a href="#改变颜色主题的默认外观">改变颜色主题的默认外观</a></li>
<li><a href="#命令">命令</a><ul>
<li><a href="#global-和-vglobal---在所有匹配行执行命令">:global 和 :vglobal - 在所有匹配行执行命令</a></li>
<li><a href="#normal-和-execute---脚本梦之队">:normal 和 :execute - 脚本梦之队</a></li>
<li><a href="#重定向消息">重定向消息</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#调试">调试</a><ul>
<li><a href="#常规建议">常规建议</a></li>
<li><a href="#调整日志等级">调整日志等级</a></li>
<li><a href="#查看启动日志">查看启动日志</a></li>
<li><a href="#查看运行时日志">查看运行时日志</a></li>
<li><a href="#vim-脚本调试">vim 脚本调试</a></li>
<li><a href="#语法文件调试">语法文件调试</a></li>
</ul>
</li>
<li><a href="#杂项">杂项</a><ul>
<li><a href="#附加资源">附加资源</a></li>
<li><a href="#vim-配置集合">Vim 配置集合</a></li>
<li><a href="#内置插件">内置插件</a></li>
<li><a href="#将-control-映射到-capslock">将 Control 映射到 CapsLock</a></li>
<li><a href="#复活节彩蛋">复活节彩蛋</a></li>
<li><a href="#为何使用-hjkl">为何使用 hjkl</a></li>
<li><a href="#常见问题">常见问题</a><ul>
<li><a href="#编辑小文件时很慢">编辑小文件时很慢</a></li>
<li><a href="#编辑大文件的时候很慢">编辑大文件的时候很慢</a></li>
<li><a href="#持续粘贴为什么我每次都要设置-paste-模式">持续粘贴（为什么我每次都要设置 ‘paste’ 模式）</a></li>
<li><a href="#在终端中按-esc-后有延时">在终端中按 ESC 后有延时</a></li>
<li><a href="#无法重复函数中执行的搜索">无法重复函数中执行的搜索</a></li>
</ul>
</li>
<li><a href="#主题列表">主题列表</a></li>
<li><a href="#插件列表">插件列表</a></li>
</ul>
</li>
<li><a href="#neovim">Neovim</a><ul>
<li><a href="#加入我们">加入我们</a></li>
<li><a href="#致谢">致谢：</a></li>
</ul>
</li>
</ul>
<!-- vim-markdown-toc -->

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="什么是-Vim？"><a href="#什么是-Vim？" class="headerlink" title="什么是 Vim？"></a>什么是 Vim？</h2><p><a href="http://www.vim.org" target="_blank" rel="noopener">Vim</a> 是一个历史悠久的文本编辑器，可以追溯到 <a href="https://en.wikipedia.org/wiki/QED_(text_editor)" target="_blank" rel="noopener">qed</a>。<a href="https://en.wikipedia.org/wiki/Bram_Moolenaar" target="_blank" rel="noopener">Bram<br>Moolenaar</a> 于 1991 年发布初始版本。</p>
<p>该项目托管在 <a href="http://www.vim.org/index.php" target="_blank" rel="noopener">vim.org</a>。</p>
<p>获取 Vim：用包管理器安装或者直接到 vim.org <a href="http://www.vim.org/download.php" target="_blank" rel="noopener">下载</a>。</p>
<p>返回主目录 <a href="#简介">:arrow_heading_up:</a></p>
<h2 id="Vim-哲学"><a href="#Vim-哲学" class="headerlink" title="Vim 哲学"></a>Vim 哲学</h2><p>Vim 采用模式编辑的理念，即它提供了多种模式，按键在不同的模式下作用不同。你可以在 <em>普通模式</em> 下浏览文件，在 <em>插入模式</em> 下插入文本，在 <em>可视模式</em> 下选择行，在 <em>命令模式</em> 下执行命令等等。起初这听起来可能很复杂，但是这有一个很大的优点：不需要通过同时按住多个键来完成操作，大多数时候你只需要依次按下这些按键即可。越常用的操作，所需要的按键数量越少。</p>
<p>和模式编辑紧密相连的概念是“操作符”和“动作”。<em>操作符</em> 开始一些行为，例如：修改，删除，或者选择文本。之后你要用一个 <em>动作</em> 来指定需要操作的文本区域。比如，要改变括号内的文本，需要执行 <code>ci(</code> （读做 _change inner parentheses_）；删除整个段落的内容，需要执行 <code>dap</code> （读做：_delete<br>around paragraph_）。</p>
<p>如果你能看见 Vim 老司机操作，你会发现他们使用 Vim 脚本语言就如同钢琴师弹钢琴一样。复杂的操作只需要几个按键就能完成。他们甚至不用刻意去想，因为这已经成为<a href="https://en.wikipedia.org/wiki/Muscle_memory" target="_blank" rel="noopener">肌肉记忆</a>了。这减少<a href="https://en.wikipedia.org/wiki/Cognitive_load" target="_blank" rel="noopener">认识负荷</a>并帮助人们专注于实际任务。</p>
<p>返回主目录 <a href="#简介">:arrow_heading_up:</a></p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>Vim 自带一个交互式的教程，内含你需要了解的最基础的信息，你可以通过终端运行以下命令打开教程：</p>
<pre><code>$ vimtutor</code></pre><p>不要因为这个看上去很无聊而跳过，按照此教程多练习。你以前用的 IDE 或者其他编辑器很少是有“模式”概念的，因此一开始你会很难适应模式切换。但是你 Vim 使用的越多，<a href="https://en.wikipedia.org/wiki/Muscle_memory" target="_blank" rel="noopener">肌肉记忆</a> 将越容易形成。</p>
<p>Vim 基于一个 <a href="https://en.wikipedia.org/wiki/Vi" target="_blank" rel="noopener">vi</a> 克隆，叫做 <a href="https://en.wikipedia.org/wiki/Stevie_(text_editor)" target="_blank" rel="noopener">Stevie</a>，支持两种运行模式：”compatible” 和 “nocompatible”。在兼容模式下运行 Vim 意味着使用 vi 的默认设置，而不是 Vim 的默认设置。除非你新建一个用户的 <code>vimrc</code> 或者使用 <code>vim -N</code> 命令启动 Vim，否则就是在兼容模式下运行 Vim！请大家不要在兼容模式下运行 Vim。</p>
<p>下一步</p>
<ol>
<li>创建你自己的 <a href="#精简的-vimrc">vimrc</a>。</li>
<li>在第一周准备<a href="#备忘录">备忘录</a>。</li>
<li>通读<a href="#基础-1">基础</a>章节了解 Vim 还有哪些功能。</li>
<li>按需学习！Vim 是学不完的。如果你遇到了问题，先上网寻找解决方案，你的问题可能已经被解决了。Vim 拥有大量的参考文档，知道如何利用这些参考文档很有必要：<a href="#获取离线帮助">获取离线帮助</a>。</li>
<li>浏览<a href="#附加资源">附加资源</a>。</li>
</ol>
<p>最后一个建议：使用<a href="#插件管理">插件</a>之前，请先掌握 Vim 的基本操作。很多插件都只是对 Vim 自带功能的封装。</p>
<p>返回主目录 <a href="#简介">:arrow_heading_up:</a></p>
<h2 id="精简的-vimrc"><a href="#精简的-vimrc" class="headerlink" title="精简的 vimrc"></a>精简的 vimrc</h2><p>用户的 vimrc 配置文件可以放在 <code>~/.vimrc</code>，或者为了更好的分离放在 <code>~/.vim/vimrc</code>，后者更便于通过版本控制软件备份和同步整个配置，比方说 Github。</p>
<p>你可以在网上找到许多精简的 vimrc 配置文件，我的版本可能并不是最简单的版本，但是我的版本提供了一套我认为良好的，非常适合入门的设置。</p>
<p>最终你需要阅读完那些设置，然后自行决定需要使用哪些。:-)</p>
<p>精简的 vimrc 地址：<a href="contents/minimal-vimrc.vim">minimal-vimrc</a></p>
<p>如果你有兴趣，这里是我（原作者）的 <a href="https://github.com/mhinz/dotfiles/blob/master/vim/vimrc" target="_blank" rel="noopener">vimrc</a>。</p>
<p><strong>建议</strong>：大多数插件作者都维护不止一个插件并且将他们的 vimrc 放在 Github 上展示（通常放在叫做 “vim-config” 或者 “dotfiles” 的仓库中），所以当你发现你喜欢的插件时，去插件维护者的 Github 主页看看有没有这样的仓库。</p>
<p>返回主目录 <a href="#简介">:arrow_heading_up:</a></p>
<h2 id="我正在使用什么样的-Vim"><a href="#我正在使用什么样的-Vim" class="headerlink" title="我正在使用什么样的 Vim"></a>我正在使用什么样的 Vim</h2><p>使用 <code>:version</code> 命令将向你展示当前正在运行的 Vim 的所有相关信息，包括它是如何编译的。</p>
<p>第一行告诉你这个二进制文件的编译时间和版本号，比如：7.4。接下来的一行呈现 <code>Included patches: 1-1051</code>，这是补丁版本包。因此你 Vim 确切的版本号是  7.4.1051。</p>
<p>另一行显示着一些像 <code>Tiny version without GUI</code> 或者 <code>Huge version with GUI</code> 的信息。很显然这些信息告诉你当前的 Vim 是否支持 GUI，例如：从终端中运行 <code>gvim</code> 或者从终端模拟器中的 Vim 内运行 <code>:gui</code> 命令。另一个重要的信息是 <code>Tiny</code> 和 <code>Huge</code>。Vim 的特性集区分被叫做 <code>tiny</code>，<code>small</code>，<code>normal</code>，<code>big</code> and <code>huge</code>，所有的都实现不同的功能子集。</p>
<p><code>:version</code> 主要的输出内容是特性列表。<code>+clipboard</code> 意味这剪贴板功能被编译支持了，<code>-clipboard</code> 意味着剪贴板特性没有被编译支持。</p>
<p>一些功能特性需要编译支持才能正常工作。例如：为了让 <code>:prof</code> 工作，你需要使用 <code>huge</code> 模式编译的 Vim，因为那种模式启用了 <code>+profile</code> 特性。</p>
<p>如果你的输出情况并不是那样，并且你是从包管理器安装 Vim 的，确保你安装了 <code>vim-x</code>，<code>vim-x11</code>，<code>vim-gtk</code>，<code>vim-gnome</code> 这些包或者相似的，因为这些包通常都是 <code>huge</code> 模式编译的。</p>
<p>你也可以运行下面这段代码来测试 Vim 版本以及功能支持：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">" Do something if running at least Vim 7.4.42 with +profile enabled.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">v:version</span> &gt; <span class="number">704</span> || <span class="variable">v:version</span> == <span class="number">704</span> &amp;&amp; <span class="built_in">has</span>(<span class="string">'patch42'</span>)) &amp;&amp; <span class="built_in">has</span>(<span class="string">'profile'</span>)</span><br><span class="line">  <span class="comment">" do stuff</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p>相关帮助：</p>
<pre><code>:h :version
:h feature-list
:h +feature-list
:h has-patch</code></pre><p>返回主目录 <a href="#简介">:arrow_heading_up:</a></p>
<h2 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h2><p>为了避免版权问题，我只贴出链接：</p>
<ul>
<li><a href="http://people.csail.mit.edu/vgod/vim/vim-cheat-sheet-en.png" target="_blank" rel="noopener">http://people.csail.mit.edu/vgod/vim/vim-cheat-sheet-en.png</a></li>
<li><a href="https://cdn.shopify.com/s/files/1/0165/4168/files/preview.png" target="_blank" rel="noopener">https://cdn.shopify.com/s/files/1/0165/4168/files/preview.png</a></li>
<li><a href="http://www.nathael.org/Data/vi-vim-cheat-sheet.svg" target="_blank" rel="noopener">http://www.nathael.org/Data/vi-vim-cheat-sheet.svg</a></li>
<li><a href="http://michael.peopleofhonoronly.com/vim/vim_cheat_sheet_for_programmers_screen.png" target="_blank" rel="noopener">http://michael.peopleofhonoronly.com/vim/vim_cheat_sheet_for_programmers_screen.png</a></li>
<li><a href="http://www.rosipov.com/images/posts/vim-movement-commands-cheatsheet.png" target="_blank" rel="noopener">http://www.rosipov.com/images/posts/vim-movement-commands-cheatsheet.png</a></li>
</ul>
<p>或者在 Vim 中快速打开备忘录：<a href="https://github.com/lifepillar/vim-cheat40" target="_blank" rel="noopener">vim-cheat40</a>。</p>
<p>返回主目录 <a href="#简介">:arrow_heading_up:</a></p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="缓冲区，窗口，标签"><a href="#缓冲区，窗口，标签" class="headerlink" title="缓冲区，窗口，标签"></a>缓冲区，窗口，标签</h2><p>Vim 是一个文本编辑器。每次文本都是作为<strong>缓冲区</strong>的一部分显示的。每一份文件都是在他们自己独有的缓冲区打开的，插件显示的内容也在它们自己的缓冲区中。</p>
<p>缓冲区有很多属性，比如这个缓冲区的内容是否可以修改，或者这个缓冲区是否和文件相关联，是否需要同步保存到磁盘上。</p>
<p><strong>窗口</strong> 是缓冲区上一层的视窗。如果你想同时查看几个文件或者查看同一文件的不同位置，那样你会需要窗口。</p>
<p>请别把他们叫做 <em>分屏</em> 。你可以把一个窗口分割成两个，但是这并没有让这两个窗口完全 <em>分离</em> 。</p>
<p>窗口可以水平或者竖直分割并且现有窗口的高度和宽度都是可以被调节设置的，因此，如果你需要多种窗口布局，请考虑使用标签。</p>
<p><strong>标签页</strong> （标签）是窗口的集合。因此当你想使用多种窗口布局时候请使用标签。</p>
<p>简单的说，如果你启动 Vim 的时候没有附带任何参数，你会得到一个包含着一个呈现一个缓冲区的窗口的标签。</p>
<p>顺带提一下，缓冲区列表是全局可见的，你可以在任何标签中访问任何一个缓冲区。</p>
<p>返回主目录 <a href="#基础">:arrow_heading_up:</a></p>
<h2 id="已激活、已载入、已列出、已命名的缓冲区"><a href="#已激活、已载入、已列出、已命名的缓冲区" class="headerlink" title="已激活、已载入、已列出、已命名的缓冲区"></a>已激活、已载入、已列出、已命名的缓冲区</h2><p>用类似 <code>vim file1</code> 的命令启动 Vim 。这个文件的内容将会被加载到缓冲区中，你现在有一个<strong>已载入的缓冲区</strong>。如果你在 Vim 中保存这个文件，缓冲区内容将会被同步到磁盘上（写回文件中）。</p>
<p>由于这个缓冲区也在一个窗口上显示，所以他也是一个<strong>已激活的缓冲区</strong>。如果你现在通过 <code>:e file2</code> 命令加载另一个文件，<code>file1</code> 将会变成一个<strong>隐藏的缓冲区</strong>，并且 <code>file2</code> 变成已激活缓冲区。</p>
<p>使用 <code>:ls</code> 我们能够列出所有可以列出的缓冲区。插件缓冲区和帮助缓冲区通常被标记为不可以列出的缓冲区，因为那并不是你经常需要在编辑器中编辑的常规文件。通过 <code>:ls!</code> 命令可以显示被放入缓冲区列表的和未被放入列表的缓冲区。</p>
<p><strong>未命名的缓冲区</strong>是一种没有关联特定文件的缓冲区，这种缓冲区经常被插件使用。比如 <code>:enew</code> 将会创建一个无名临时缓冲区。添加一些文本然后使用 <code>:w /tmp/foo</code> 将他写入到磁盘，这样这个缓冲区就会变成一个<strong>已命名的缓冲区</strong>。</p>
<p>返回主目录 <a href="#基础">:arrow_heading_up:</a></p>
<h2 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h2><p><a href="#缓冲区窗口标签">全局缓冲区列表</a>是 Vim 的特性。在这之前的 vi 中，仅仅只有参数列表，参数列表在 Vim 中依旧可以使用。</p>
<p>每一个通过 shell 命令传递给 Vim 的文件名都被记录在一个参数列表中。可以有多个参数列表：默认情况下所有参数都被放在全局参数列表下，但是你可以使用 <code>:arglocal</code> 命令去创建一个新的本地窗口的参数列表。</p>
<p>使用 <code>:args</code> 命令可以列出当前参数。使用 <code>:next</code>，<code>:previous</code>，<code>:first</code>，<code>:last</code> 命令可以在切换在参数列表中的文件。通过使用 <code>:argadd</code>，<code>:argdelete</code> 或者 <code>:args</code> 等命令加上一个文件列表可以改变参数列表。</p>
<p>偏爱缓冲区列表还是参数列表完全是个人选择，我的印象中大多数人都是使用缓冲区列表的。</p>
<p>然而参数列表在有些情况下被大量使用：批处理<br>使用 <code>:argdo</code>！ 一个简单的重构例子：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">args</span> **/*.[ch]</span><br><span class="line">:<span class="keyword">argdo</span> %s/foo/bar/ge | <span class="keyword">update</span></span><br></pre></td></tr></table></figure>

<p>这条命令将替换掉当前目录下以及当前目录的子目录中所有的 C 源文件和头文件中的“foo”，并用“bar”代替。</p>
<p>相关帮助：<code>:h argument-list</code></p>
<p>返回主目录 <a href="#基础">:arrow_heading_up:</a></p>
<h2 id="按键映射"><a href="#按键映射" class="headerlink" title="按键映射"></a>按键映射</h2><p>使用 <code>:map</code> 命令家族你可以定义属于你自己的快捷键。该家族的每一个命令都限定在特定的模式下。从技术上来说 Vim 自带高达 12 中模式，其中 6 种可以被映射。另外一些命令作用于多种模式：</p>
<table>
<thead>
<tr>
<th>递归</th>
<th>非递归</th>
<th>模式</th>
</tr>
</thead>
<tbody><tr>
<td><code>:map</code></td>
<td><code>:noremap</code></td>
<td>normal, visual, operator-pending</td>
</tr>
<tr>
<td><code>:nmap</code></td>
<td><code>:nnoremap</code></td>
<td>normal</td>
</tr>
<tr>
<td><code>:xmap</code></td>
<td><code>:xnoremap</code></td>
<td>visual</td>
</tr>
<tr>
<td><code>:cmap</code></td>
<td><code>:cnoremap</code></td>
<td>command-line</td>
</tr>
<tr>
<td><code>:omap</code></td>
<td><code>:onoremap</code></td>
<td>operator-pending</td>
</tr>
<tr>
<td><code>:imap</code></td>
<td><code>:inoremap</code></td>
<td>insert</td>
</tr>
</tbody></table>
<p>例如：这个自定义的快捷键只在普通模式下工作。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">nmap</span> <span class="symbol">&lt;space&gt;</span> :<span class="keyword">echo</span> <span class="string">"foo"</span><span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>:nunmap &lt;space&gt;</code> 可以取消这个映射。</p>
<p>对于更少数，不常见的模式（或者他们的组合），查看 <code>:h map-modes</code>。</p>
<p>到现在为止还好，对新手而言有一个问题会困扰他们：<code>:nmap</code> 是<strong>递归执行</strong>的！结果是，右边执行可能的映射。</p>
<p>你自定义了一个简单的映射去输出“Foo”：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">nmap</span> <span class="keyword">b</span> :<span class="keyword">echo</span> <span class="string">"Foo"</span><span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是如果你想要映射 <code>b</code> （回退一个单词）的默认功能到一个键上呢？</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">nmap</span> <span class="keyword">a</span> <span class="keyword">b</span></span><br></pre></td></tr></table></figure>

<p>如果你敲击<kbd>a</kbd>，我们期望着光标回退到上一个单词，但是实际情况是“Foo”被输出到命令行里！因为在右边，<code>b</code> 已经被映射到别的行为上了，换句话说就是 <code>:echo &quot;Foo&quot;&lt;cr&gt;</code>。</p>
<p>解决此问题的正确方法是使用一种 <em>非递归</em> 的映射代替：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">nnoremap</span> <span class="keyword">a</span> <span class="keyword">b</span></span><br></pre></td></tr></table></figure>

<p>经验法则：除非递归是必须的，否则总是使用非递归映射。</p>
<p>通过不给一个右值来检查你的映射。比如<code>:nmap</code> 显示所以普通模式下的映射，<code>:nmap &lt;leader&gt;</code> 显示所有以 <code>&lt;leader&gt;</code> 键开头的普通模式下的映射。</p>
<p>如果你想禁止用标准映射，把他们映射到特殊字符 <code>&lt;nop&gt;</code> 上，例如：<code>:noremap &lt;left&gt; &lt;nop&gt;</code>。</p>
<p>相关帮助：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:h key-notation</span><br><span class="line">:h mapping</span><br><span class="line">:h <span class="number">05.3</span></span><br></pre></td></tr></table></figure>

<p>返回主目录 <a href="#基础">:arrow_heading_up:</a></p>
<h2 id="映射前置键"><a href="#映射前置键" class="headerlink" title="映射前置键"></a>映射前置键</h2><p>映射前置键（Leader 键）本身就是一个按键映射，默认为 <kbd>\</kbd>。我们可以通过在 <code>map</code> 中调用 <code>&lt;leader&gt;</code> 来为把它添加到其他按键映射中。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span>h :<span class="keyword">helpgrep</span><span class="symbol">&lt;space&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，我们只需要先按 <kbd>\</kbd> 然后连续按 <kbd>\h</kbd> 就可以激活这个映射 <code>:helpgrep&lt;space&gt;</code>。如果你想通过先按 <kbd>空格</kbd> 键来触发，只需要这样做：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mapleader = <span class="string">' '</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span>h :<span class="keyword">helpgrep</span><span class="symbol">&lt;space&gt;</span></span><br></pre></td></tr></table></figure>

<p>另外，还有一个叫 <code>&lt;localleader&gt;</code> 的，可以把它理解为局部环境中的 <code>&lt;leader&gt;</code>，默认值依然为 <kbd>\</kbd>。当我们需要只对某一个条件下（比如，特定文件类型的插件）的缓冲区设置特别的 <code>&lt;leader&gt;</code> 键，那么我们就可以通过修改当前环境下的 <code>&lt;localleader&gt;</code> 来实现。</p>
<p><strong>注意</strong>：如果你打算设置 Leader 键，请确保在设置按键映射之前，先设置好 Leader 键。如果你先设置了含有 Leader 键的映射，然后又修改了 Leader 键，那么之前映射内的 Leader 键是不会因此而改变的。你可以通过执行 <code>:nmap &lt;leader&gt;</code> 来查看普通模式中已绑定给 Leader 键的所有映射。</p>
<p>请参阅 <code>:h mapleader</code> 与 <code>:h maploacalleader</code> 来获取更多帮助。</p>
<p>返回主目录 <a href="#基础">:arrow_heading_up:</a></p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>寄存器就是存储文本的地方。我们常用的「复制」操作就是把文本存储到寄存器，「 粘贴」 操作就是把文本从寄存器中读出来。顺便，在 Vim 中复制的快捷键是 <kbd>y</kbd>，粘贴的快捷键是 <kbd>p</kbd>。</p>
<p>Vim 为我们提供了如下的寄存器：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>标识</th>
<th>读写者</th>
<th>是否为只读</th>
<th>包含的字符来源</th>
</tr>
</thead>
<tbody><tr>
<td>Unnamed</td>
<td><code>&quot;</code></td>
<td>vim</td>
<td>否</td>
<td>最近一次的复制或删除操作 (<code>d</code>, <code>c</code>, <code>s</code>, <code>x</code>, <code>y</code>)</td>
</tr>
<tr>
<td>Numbered</td>
<td><code>0</code>至<code>9</code></td>
<td>vim</td>
<td>否</td>
<td>寄存器 <code>0</code>: 最近一次复制。寄存器 <code>1</code>: 最近一次删除。寄存器 <code>2</code>: 倒数第二次删除，以此类推。对于寄存器 <code>1</code> 至 <code>9</code>，他们其实是只读的最多包含 9 个元素的队列。这里的队列即为数据类型 <a href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)" target="_blank" rel="noopener">queue</a></td>
</tr>
<tr>
<td>Small delete</td>
<td><code>-</code></td>
<td>vim</td>
<td>否</td>
<td>最近一次行内删除</td>
</tr>
<tr>
<td>Named</td>
<td><code>a</code>至<code>z</code>, <code>A</code>至<code>Z</code></td>
<td>用户</td>
<td>否</td>
<td>如果你通过复制操作存储文本至寄存器 <code>a</code>，那么 <code>a</code> 中的文本就会被完全覆盖。如果你存储至 <code>A</code>，那么会将文本添加给寄存器 <code>a</code>，不会覆盖之前已有的文本</td>
</tr>
<tr>
<td>Read-only</td>
<td><code>:</code>与<code>.</code>和<code>%</code></td>
<td>vim</td>
<td>是</td>
<td><code>:</code>: 最近一次使用的命令，<code>.</code>: 最近一次添加的文本，<code>%</code>: 当前的文件名</td>
</tr>
<tr>
<td>Alternate buffer</td>
<td><code>#</code></td>
<td>vim</td>
<td>否</td>
<td>大部分情况下，这个寄存器是当前窗口中，上一次访问的缓冲区。请参阅 <code>:h alternate-file</code> 来获取更多帮助</td>
</tr>
<tr>
<td>Expression</td>
<td><code>=</code></td>
<td>用户</td>
<td>否</td>
<td>复制 VimL 代码时，这个寄存器用于存储代码片段的执行结果。比如，在插入模式下复制 <code>&lt;c-r&gt;=5+5&lt;cr&gt;</code>，那么这个寄存器就会存入 10</td>
</tr>
<tr>
<td>Selection</td>
<td><code>+</code>和<code>*</code></td>
<td>vim</td>
<td>否</td>
<td><code>*</code> 和 <code>+</code> 是 <a href="#剪贴板">剪贴板</a> 寄存器</td>
</tr>
<tr>
<td>Drop</td>
<td><code>~</code></td>
<td>vim</td>
<td>是</td>
<td>最后一次拖拽添加至 Vim 的文本（需要 “+dnd” 支持，暂时只支持 GTK GUI。请参阅 <code>:help dnd</code> 及 <code>:help quote~</code>）</td>
</tr>
<tr>
<td>Black hole</td>
<td><code>_</code></td>
<td>vim</td>
<td>否</td>
<td>一般称为黑洞寄存器。对于当前操作，如果你不希望在其他寄存器中保留文本，那就在命令前加上 <code>_</code>。比如，<code>&quot;_dd</code> 命令不会将文本放到寄存器 <code>&quot;</code>、<code>1</code>、<code>+</code> 或 <code>*</code> 中</td>
</tr>
<tr>
<td>Last search pattern</td>
<td><code>/</code></td>
<td>vim</td>
<td>否</td>
<td>最近一次通过 <code>/</code>、<code>?</code> 或 <code>:global</code> 等命令调用的匹配条件</td>
</tr>
</tbody></table>
<p>只要不是只读的寄存器，用户都有权限修改它的内容，比如：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">let</span> @/ = <span class="string">'register'</span></span><br></pre></td></tr></table></figure>

<p>这样，我们按 <kbd>n</kbd> 的时候就会跳转到单词”register” 出现的地方。</p>
<p>有些时候，你的操作可能已经修改了寄存器，而你没有察觉到。请参阅 <code>:h registers</code> 获取更多帮助。</p>
<p>上面提到过，复制的命令是 <kbd>y</kbd>，粘贴的命令是 <kbd>p</kbd> 或者 <kbd>P</kbd>。但请注意，Vim 会区分「字符选取」与「行选取」。请参阅 <code>:h linewise</code> 获取更多帮助。</p>
<p><strong>行选取</strong>：<br>命令 <code>yy</code> 或 <code>Y</code> 都是复制当前行。这时移动光标至其他位置，按下 <code>p</code> 就可以在光标下方粘贴复制的行，按下 <code>P</code> 就可以在光标上方粘贴至复制的行。</p>
<p><strong>字符选取</strong>：<br>命令 <code>0yw</code> 可以复制第一个单词。这时移动光标至其他位置，按下 <code>p</code> 就可以在当前行、光标后的位置粘贴单词，按下 <code>P</code> 就可以在当前行、光标前的位置粘贴单词。</p>
<p><strong>将文本存到指定的寄存器中</strong>：<br>命令 <code>&quot;aY</code> 可以将当前行复制，并存储到寄存器 <code>a</code> 中。这时移动光标至其他位置，通过命令 <code>&quot;AY</code> 就可以把这一行的内容扩展到寄存器 <code>a</code> 中，而之前存储的内容也不会丢失。</p>
<p>为了便于理解和记忆，建议大家现在就试一试上面提到的这些操作。操作过程中，你可以随时通过 <code>:reg</code> 来查看寄存器的变化。</p>
<p><strong>有趣的是</strong>：<br>在 Vim 中，<code>y</code> 是复制命令，源于单词 “yanking”。而在 Emacs 中，”yanking” 代表的是粘贴（或者说，重新插入刚才删掉的内容），而并不是复制。</p>
<p>返回主目录 <a href="#基础">:arrow_heading_up:</a></p>
<h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>范围 (Ranges) 其实很好理解，但很多 Vim 用户的理解不到位。</p>
<ul>
<li>很多命令都可以加一个数字，用于指明操作范围</li>
<li>范围可以是一个行号，用于指定某一行</li>
<li>范围也可以是一对通过 <code>,</code> 或 <code>;</code> 分割的行号</li>
<li>大部分命令，默认只作用于当前行</li>
<li>只有 <code>:write</code> 和 <code>:global</code> 是默认作用于所有行的</li>
</ul>
<p>范围的使用是十分直观的。以下为一些例子（其中，<code>:d</code> 为 <code>:delete</code> 的缩写）：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>操作的行</th>
</tr>
</thead>
<tbody><tr>
<td><code>:d</code></td>
<td>当前行</td>
</tr>
<tr>
<td><code>:.d</code></td>
<td>当前行</td>
</tr>
<tr>
<td><code>:1d</code></td>
<td>第一行</td>
</tr>
<tr>
<td><code>:$d</code></td>
<td>最后一行</td>
</tr>
<tr>
<td><code>:1,$d</code></td>
<td>所有行</td>
</tr>
<tr>
<td><code>:%d</code></td>
<td>所有行（这是 <code>1,$</code> 的语法糖）</td>
</tr>
<tr>
<td><code>:.,5d</code></td>
<td>当前行至第 5 行</td>
</tr>
<tr>
<td><code>:,5d</code></td>
<td>同样是当前行至第 5 行</td>
</tr>
<tr>
<td><code>:,+3d</code></td>
<td>当前行及接下来的 3 行</td>
</tr>
<tr>
<td><code>:1,+3d</code></td>
<td>第一行至当前行再加 3 行</td>
</tr>
<tr>
<td><code>:,-3d</code></td>
<td>当前行及向上的 3 行（Vim 会弹出提示信息，因为这是一个保留的范围）</td>
</tr>
<tr>
<td><code>:3,&#39;xdelete</code></td>
<td>第三行至<a href="#标注">标注</a> 为 x 的那一行</td>
</tr>
<tr>
<td><code>:/^foo/,$delete</code></td>
<td>当前行以下，以字符 “foo” 开头的那一行至结尾</td>
</tr>
<tr>
<td><code>:/^foo/+1,$delete</code></td>
<td>当前行以下，以字符 “foo” 开头的那一行的下一行至结尾</td>
</tr>
</tbody></table>
<p>需要注意的是，<code>;</code> 也可以用于表示范围。区别在于，<code>a,b</code> 的 <code>b</code> 是以当前行作为参考的。而 <code>a;b</code> 的 <code>b</code> 是以 <code>a</code> 行作为参考的。举个例子，现在你的光标在第 5 行。这时 <code>:1,+1d</code> 会删除第 1 行至第 6 行，而 <code>:1;+1d</code> 会删除第 1 行和第 2 行。</p>
<p>如果你想设置多个寻找条件，只需要在条件前加上 <code>/</code>，比如：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:/foo//bar//quux/d</span><br></pre></td></tr></table></figure>

<p>这就会删除当前行之后的某一行。定位方式是，先在当前行之后寻找第一个包含 “foo” 字符的那一行，然后在找到的这一行之后寻找第一个包含 “bar” 字符的那一行，然后再在找到的这一行之后寻找第一个包含 “quux” 的那一行。删除的就是最后找到的这一行。</p>
<p>有时，Vim 会在命令前自动添加范围。举个例子，如果你先通过 <code>V</code> 命令进入行选取模式，选中一些行后按下 <code>:</code> 进入命令模式，这时候你会发现 Vim 自动添加了 <code>&#39;&lt;,&#39;&gt;</code> 范围。这表示，接下来的命令会使用之前选取的行号作为范围。但如果后续命令不支持范围，Vim 就会报错。为了避免这样的情况发生，有些人会设置这样的按键映射：<code>:vnoremap foo :&lt;c-u&gt;command</code>，组合键 <kbd>Ctrl + u</kbd> 可以清除当前命令行中的内容。</p>
<p>另一个例子是在普通模式中按下 <code>!!</code>，命令行中会出现 <code>:.!</code>。如果这时你如果输入一个外部命令，那么当前行的内容就会被这个外部命令的输出替换。你也可以通过命令 <code>:?^$?+1,/^$/-1!ls</code> 把当前段落的内容替换成外部命令 <code>ls</code> 的输出，原理是向前和向后各搜索一个空白行，删除这两个空白行之间的内容，并将外部命令 <code>ls</code> 的输出放到这两个空白行之间。</p>
<p>请参阅以下两个命令来获取更多帮助：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:h cmdline-ranges</span><br><span class="line">:h <span class="number">10.3</span></span><br></pre></td></tr></table></figure>

<p>返回主目录 <a href="#基础">:arrow_heading_up:</a></p>
<h2 id="标注"><a href="#标注" class="headerlink" title="标注"></a>标注</h2><p>你可以使用标注功能来标记一个位置，也就是记录文件某行的某个位置。</p>
<table>
<thead>
<tr>
<th>标注</th>
<th>设置者</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td><code>a</code>-<code>z</code></td>
<td>用户</td>
<td>仅对当前的一个文件生效，也就意味着只可以在当前文件中跳转</td>
</tr>
<tr>
<td><code>A</code>-<code>Z</code></td>
<td>用户</td>
<td>全局标注，可以作用于不同文件。大写标注也称为「文件标注」。跳转时有可能会切换到另一个缓冲区</td>
</tr>
<tr>
<td><code>0</code>-<code>9</code></td>
<td>viminfo</td>
<td><code>0</code> 代表 viminfo 最后一次被写入的位置。实际使用中，就代表 Vim 进程最后一次结束的位置。<code>1</code> 代表 Vim 进程倒数第二次结束的位置，以此类推</td>
</tr>
</tbody></table>
<p>如果想跳转到指定的标注，你可以先按下 <code>&#39;</code> / <code>g&#39;</code> 或者 <code>`</code> / <code>g`</code> 然后按下标注名。</p>
<p>如果你想定义当前文件中的标注，可以先按下 <code>m</code> 再按下标注名。比如，按下 <code>mm</code> 就可以把当前位置标注为 <code>m</code>。在这之后，如果你的光标切换到了文件的其他位置，只需要通过 <code>&#39;m</code> 或者 <code>\</code>m<code>即可回到刚才标注的行。区别在于，</code>‘m<code>会跳转回被标记行的第一个非空字符，而</code>`m<code>会跳转回被标记行的被标记列。根据 viminfo 的设置，你可以在退出 Vim 的时候保留小写字符标注。请参阅</code>:h viminfo-‘` 来获取更多帮助。</p>
<p>如果你想定义全局的标注，可以先按下 <code>m</code> 再按下大写英文字符。比如，按下 <code>mM</code> 就可以把当前文件的当前位置标注为 <code>M</code>。在这之后，就算你切换到其他的缓冲区，依然可以通过 <code>&#39;M</code> 或 <code>\</code>M` 跳转回来。</p>
<p>关于跳转，还有以下的方式：</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>跳转至</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#39;[</code> 与 <code>`[</code></td>
<td>上一次修改或复制的第一行或第一个字符</td>
</tr>
<tr>
<td><code>&#39;]</code> 与 <code>`]</code></td>
<td>上一次修改或复制的最后一行或最后一个字符</td>
</tr>
<tr>
<td><code>&#39;&lt;</code> 与 <code>`&lt;</code></td>
<td>上一次在可视模式下选取的第一行或第一个字符</td>
</tr>
<tr>
<td><code>&#39;&gt;</code> 与 <code>`&gt;</code></td>
<td>上一次在可视模式下选取的最后一行或最后一个字符</td>
</tr>
<tr>
<td><code>&#39;&#39;</code> 与 <code>`&#39;</code></td>
<td>上一次跳转之前的光标位置</td>
</tr>
<tr>
<td><code>&#39;&quot;</code> 与 <code>`&quot;</code></td>
<td>上一次关闭当前缓冲区时的光标位置</td>
</tr>
<tr>
<td><code>&#39;^</code> 与 <code>`^</code></td>
<td>上一次插入字符后的光标位置</td>
</tr>
<tr>
<td><code>&#39;.</code> 与 <code>`.</code></td>
<td>上一次修改文本后的光标位置</td>
</tr>
<tr>
<td><code>&#39;(</code> 与 <code>`(</code></td>
<td>当前句子的开头</td>
</tr>
<tr>
<td><code>&#39;)</code> 与 <code>`)</code></td>
<td>当前句子的结尾</td>
</tr>
<tr>
<td><code>&#39;{</code> 与 <code>`{</code></td>
<td>当前段落的开头</td>
</tr>
<tr>
<td><code>&#39;}</code> 与 <code>`}</code></td>
<td>当前段落的结尾</td>
</tr>
</tbody></table>
<p>标注也可以搭配 <a href="#范围">范围</a> 一起使用。前面提到过，如果你在可视模式下选取一些文本，然后按下 <code>:</code>，这时候你会发现命令行已经被填充了 <code>:&#39;&lt;,&#39;&gt;</code>。对照上面的表格，现在你应该明白了，这段代表的就是可视模式下选取的范围。</p>
<p>请使用 <code>:marks</code> 命令来显示所有的标注，参阅 <code>:h mark-motions</code> 来获取关于标注的更多帮助。</p>
<p>返回主目录 <a href="#基础">:arrow_heading_up:</a></p>
<h2 id="补全"><a href="#补全" class="headerlink" title="补全"></a>补全</h2><p>Vim 在插入模式中为我们提供了多种补全方案。如果有多个补全结果，Vim 会弹出一个菜单供你选择。</p>
<p>常见的补全有标签、项目中引入的模块或库中的方法名、文件名、字典及当前缓冲区的字段。</p>
<p>针对不同的补全方案，Vim 为我们提供了不同的按键映射。这些映射都是在<strong>插入模式中</strong>通过 <kbd>Ctrl</kbd> + <kbd>x</kbd> 来触发：</p>
<table>
<thead>
<tr>
<th>映射</th>
<th>类型</th>
<th>帮助文档</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;c-x&gt;&lt;c-l&gt;</code></td>
<td>整行</td>
<td><code>:h i^x^l</code></td>
</tr>
<tr>
<td><code>&lt;c-x&gt;&lt;c-n&gt;</code></td>
<td>当前缓冲区中的关键字</td>
<td><code>:h i^x^n</code></td>
</tr>
<tr>
<td><code>&lt;c-x&gt;&lt;c-k&gt;</code></td>
<td>字典（请参阅 <code>:h &#39;dictionary&#39;</code>）中的关键字</td>
<td><code>:h i^x^k</code></td>
</tr>
<tr>
<td><code>&lt;c-x&gt;&lt;c-t&gt;</code></td>
<td>同义词字典（请参阅 <code>:h &#39;thesaurus&#39;</code>）中的关键字</td>
<td><code>:h i^x^t</code></td>
</tr>
<tr>
<td><code>&lt;c-x&gt;&lt;c-i&gt;</code></td>
<td>当前文件以及包含的文件中的关键字</td>
<td><code>:h i^x^i</code></td>
</tr>
<tr>
<td><code>&lt;c-x&gt;&lt;c-]&gt;</code></td>
<td>标签</td>
<td><code>:h i^x^]</code></td>
</tr>
<tr>
<td><code>&lt;c-x&gt;&lt;c-f&gt;</code></td>
<td>文件名</td>
<td><code>:h i^x^f</code></td>
</tr>
<tr>
<td><code>&lt;c-x&gt;&lt;c-d&gt;</code></td>
<td>定义或宏定义</td>
<td><code>:h i^x^d</code></td>
</tr>
<tr>
<td><code>&lt;c-x&gt;&lt;c-v&gt;</code></td>
<td>Vim 命令</td>
<td><code>:h i^x^v</code></td>
</tr>
<tr>
<td><code>&lt;c-x&gt;&lt;c-u&gt;</code></td>
<td>用户自定义补全（通过 <code>&#39;completefunc&#39;</code> 定义）</td>
<td><code>:h i^x^u</code></td>
</tr>
<tr>
<td><code>&lt;c-x&gt;&lt;c-o&gt;</code></td>
<td>Omni Completion（通过 <code>&#39;omnifunc&#39;</code> 定义）</td>
<td><code>:h i^x^o</code></td>
</tr>
<tr>
<td><code>&lt;c-x&gt;s</code></td>
<td>拼写建议</td>
<td><code>:h i^Xs</code></td>
</tr>
</tbody></table>
<p>尽管用户自定义补全与 Omni Completion 是不同的，但他们做的事情基本一致。共同点在于，他们都是一个监听当前光标位置的函数，返回值为一系列的补全建议。用户自定义补全是由用户定义的，基于用户的个人用途，因此你可以根据自己的喜好和需求随意定制。而 Omni Completion 是针对文件类型的补全，比如在 C 语言中补全一个结构体（struct）的成员（members），或者补全一个类的方法，因而它通常都是由文件类型插件设置和调用的。</p>
<p>如果你设置了 <code>&#39;complete&#39;</code> 选项，那么你就可以在一次操作中采用多种补全方案。这个选项默认包含了多种可能性，因此请按照自己的需求来配置。你可以通过 <code>&lt;c-n&gt;</code> 来调用下一个补全建议，或通过 <code>&lt;c-p&gt;</code> 来调用上一个补全建议。当然，这两个映射同样可以直接调用补全函数。请参阅 <code>:h i^n</code> 与 <code>:h &#39;complete&#39;</code> 来获得更多帮助。</p>
<p>如果你想配置弹出菜单的行为，请一定要看一看 <code>:h &#39;completeopt&#39;</code> 这篇帮助文档。默认的配置已经不错了，但我个人（原作者）更倾向于把 “noselect” 加上。</p>
<p>请参阅以下文档获取更多帮助：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:h ins-completion</span><br><span class="line">:h popupmenu-<span class="built_in">keys</span></span><br><span class="line">:h <span class="keyword">new</span>-omni-completion</span><br></pre></td></tr></table></figure>

<p>返回主目录 <a href="#基础">:arrow_heading_up:</a></p>
<h2 id="动作，操作符，文本对象"><a href="#动作，操作符，文本对象" class="headerlink" title="动作，操作符，文本对象"></a>动作，操作符，文本对象</h2><p><strong>动作</strong>也就是指移动光标的操作，你肯定很熟悉 <code>h</code>、<code>j</code>、<code>k</code> 和 <code>l</code>，以及 <code>w</code> 和 <code>b</code>。但其实，<code>/</code> 也是一个动作。他们都可以搭配数字使用，比如 <code>2?the&lt;cr&gt;</code> 可以将光标移动到倒数第二个 “the” 出现的位置。</p>
<p>以下会列出一些常用的动作。你也可以通过 <code>:h navigation</code> 来获取更多的帮助。</p>
<p><strong>操作符</strong>是对某个区域文本执行的操作。比如，<code>d</code>、<code>~</code>、<code>gU</code> 和 <code>&gt;</code> 都是操作符。这些操作符既可以在普通模式下使用，也可以在可视模式下使用。在普通模式中，顺序是先按操作符，再按动作指令，比如 <code>&gt;j</code>。在可是模式中，选中区域后直接按操作符就可以，比如 <code>Vjd</code>。</p>
<p>与动作一样，操作符也可以搭配数字使用，比如 <code>2gUw</code> 可以将当前单词以及下一个单词转成大写。由于动作和操作符都可以搭配数字使用，因此 <code>2gU2w</code> 与执行两次 <code>gU2w</code> 效果是相同的。</p>
<p>请参阅 <code>:h operator</code> 来查看所有的操作符。你也可以通过 <code>:set tildeop</code> 命令把 <code>~</code> 也变成一个操作符</p>
<p>值得注意的是，动作是单向的，而<strong>文本对象</strong>是双向的。文本对象不仅作用于符号（比如括号、中括号和大括号等）标记的范围内，也作用于整个单词、整个句子等其他情况。</p>
<p>文本对象不能用于普通模式中移动光标的操作，因为光标还没有智能到可以向两个方向同时跳转。但这个功能可以在可视模式中实现，因为在对象的一端选中的情况下，光标只需要跳转到另一端就可以了。</p>
<p>文本对象操作一般用 <code>i</code> 或 <code>a</code> 加上对象标识符操作，其中 <code>i</code> 表示在对象内（英文 inner）操作，<code>a</code> 表示对整个对象（英文 around）操作，这时开头和结尾的空格都会被考虑进来。举个例子，<code>diw</code> 可以删除当前单词，<code>ci(</code> 可以改变括号中的内容。</p>
<p>文本对象同样可以与数字搭配使用。比如，像 <code>(((  )))</code> 这样的文本，假如光标位于最内层的括号上或最内层的括号内，那么 <code>d2a(</code> 将会删除从最内层开始的两对括号，以及他们之间的所有内容。其实，<code>d2a(</code> 这个操作等同于 <code>2da(</code>。在 Vim 的命令中，如果有两处都可以接收数字作为参数，那么最终结果就等同于两个数字相乘。在这里，<code>d</code> 与 <code>a(</code> 都是可以接收参数的，一个参数是 1，另一个是 2，我们可以把它们相乘然后放到最前面。</p>
<p>请参阅 <code>:h text-objects</code> 来获取更多关于文本对象的帮助。</p>
<p>返回主目录 <a href="#基础">:arrow_heading_up:</a></p>
<h2 id="自动命令"><a href="#自动命令" class="headerlink" title="自动命令"></a>自动命令</h2><p>在特定的情况下，Vim 会传出事件。如果你想针对这些事件执行回调方法，那么就需要用到自动命令这个功能。</p>
<p>如果没有了自动命令，那你基本上是用不了 Vim 的。自动命令一直都在执行，只是很多时候你没有注意到。不信的话，可以执行命令 <code>:au</code> ，不要被结果吓到，这些是当前有效的所有自动命令。</p>
<p>请使用 <code>:h {event}</code> 来查看 Vim 中所有事件的列表，你也可以参考 <code>:h autocmd-events-abc</code> 来获取关于事件的更多帮助。</p>
<p>一个很常用的例子，就是针对文件类型执行某些设置：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">autocmd</span> FileType <span class="keyword">ruby</span> <span class="keyword">setlocal</span> <span class="built_in">shiftwidth</span>=<span class="number">2</span> softtabstop=<span class="number">2</span> comments-=:#</span><br></pre></td></tr></table></figure>

<p>但是缓冲区是如何知道当前的文件中包含 Ruby 代码呢？这其实是另一个自动命令检测的到的，然后把文件类型设置成为 Ruby，这样就触发了上面的 <code>FileType</code> 事件。</p>
<p>在配置 vimrc 的时候，一般第一行加进去的就是 <code>filetype on</code>。这就意味着，Vim 启动时会读取 <code>filetype.vim</code> 文件，然后根据文件类型来触发相应的自动命令。</p>
<p>如果你勇于尝试，可以查看下 <code>:e $VIMRUNTIME/filetype.vim</code>，然后在输出中搜索 “Ruby”。这样，你就会发现其实 Vim 只是通过文件扩展名 <code>.rb</code> 判断某个文件是不是 Ruby 的。</p>
<p><strong>注意</strong>：对于相同事件，如果有多个自动命令，那么自动命令会按照定义时的顺序执行。通过 <code>:au</code> 就可以查看它们的执行顺序。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">au</span> BufNewFile,BufRead *.rb,*.rbw <span class="keyword">setf</span> <span class="keyword">ruby</span></span><br></pre></td></tr></table></figure>

<p><code>BufNewFile</code> 与 <code>BufRead</code> 事件是被写在 Vim 源文件中的。因此，每当你通过 <code>:e</code> 或者类似的命令打开文件，这两个事件都会触发。然后，就是读取 <code>filetype.vim</code> 文件来判断打开的文件类型。</p>
<p>简单来说，事件和自动命令在 Vim 中的应用十分广泛。而且，Vim 为我们留出了一些易用的接口，方便用户配置适合自己的事件驱动回调。</p>
<p>请参阅 <code>:h autocommand</code> 来获取更多帮助</p>
<p>返回主目录 <a href="#基础">:arrow_heading_up:</a></p>
<h2 id="变更历史，跳转历史"><a href="#变更历史，跳转历史" class="headerlink" title="变更历史，跳转历史"></a>变更历史，跳转历史</h2><p>在 Vim 中，用户最近 100 次的文字改动都会被保存在<strong>变更历史</strong>中。如果在同一行有多个小改动，那么 Vim 会把它们合并成一个。尽管内容改动会合并，但作用的位置还是会只记录下最后一次改动的位置。</p>
<p>在你移动光标或跳转的时候，每一次的移动或跳转前的位置会被记录到<strong>跳转历史</strong>中。类似地，跳转历史也可以最多保存 100 条记录。对于每个窗口，跳转记录是独立的。但当你分离窗口时（比如使用 <code>:split</code> 命令），跳转历史会被复制过去。</p>
<p>Vim 中的跳转命令，包括 <code>&#39;</code>、<code>`</code>、<code>G</code>、<code>/</code>、<code>?</code>、<code>n</code>、<code>N</code>、<code>%</code>、<code>(</code>、<code>)</code>、<code>[[</code>、<code>]]</code>、<code>{</code>、<code>}</code>、<code>:s</code>、<code>:tag</code>、<code>L</code>、<code>M</code>、<code>H</code> 以及开始编辑一个新文件的命令。</p>
<table>
<thead>
<tr>
<th>列表</th>
<th>显示所有条目</th>
<th>跳转到上一个位置</th>
<th>跳转到下一个位置</th>
</tr>
</thead>
<tbody><tr>
<td>跳转历史</td>
<td><code>:jumps</code></td>
<td><code>[count]&lt;c-o&gt;</code></td>
<td><code>[count]&lt;c-i&gt;</code></td>
</tr>
<tr>
<td>变更历史</td>
<td><code>:changes</code></td>
<td><code>[count]g;</code></td>
<td><code>[count]g,</code></td>
</tr>
</tbody></table>
<p>如果你执行第二列的命令显示所有条目，这时 Vim 会用 <code>&gt;</code> 标记来为你指示当前位置。通常这个标记位于 1 的下方，也就代表最后一次的位置。</p>
<p>如果你希望关闭 Vim 之后还保留这些条目，请参阅 <code>:h viminfo-&#39;</code> 来获取更多帮助。</p>
<p><strong>注意</strong>：上面提到过，最后一次跳转前的位置也会记录在<a href="#标注">标注</a>中，也可以通过连按 <kbd>``</kbd> 或 <kbd>''</kbd> 跳转到那个位置</p>
<p>请参阅以下两个命令来获取更多帮助：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:h changelist</span><br><span class="line">:h jumplist</span><br></pre></td></tr></table></figure>

<p>返回主目录 <a href="#基础">:arrow_heading_up:</a></p>
<h2 id="内容变更历史记录"><a href="#内容变更历史记录" class="headerlink" title="内容变更历史记录"></a>内容变更历史记录</h2><p>Vim 会记录文本改变之前的状态。因此，你可以使用「撤销」操作 <kbd>u</kbd> 来取消更改，也可以通过「重做」操作 <kbd>Ctrl + r</kbd> 来恢复更改。</p>
<p>值得注意的是，Vim 采用 <a href="https://en.wikipedia.org/wiki/Tree_(data_structure)" target="_blank" rel="noopener">tree</a> 数据结构来存储内容变更的历史记录，而不是采用 <a href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)" target="_blank" rel="noopener">queue</a>。你的每次改动都会成为存储为树的节点。而且，除了第一次改动（根节点），之后的每次改动都可以找到一个对应的父节点。每一个节点都会记录改动的内容和时间。其中，「分支」代表从任一节点到根节点的路径。当你进行了撤销操作，然后又输入了新的内容，这时候就相当于创建了分支。这个原理和 git 中的 branch（分支）十分类似。</p>
<p>考虑以下这一系列按键操作：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">ifoo<span class="symbol">&lt;esc&gt;</span></span><br><span class="line">obar<span class="symbol">&lt;esc&gt;</span></span><br><span class="line">obaz<span class="symbol">&lt;esc&gt;</span></span><br><span class="line"><span class="keyword">u</span></span><br><span class="line">oquux<span class="symbol">&lt;exc&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么现在，Vim 中会显示三行文本，分别是 “foo”、”bar” 和 “quux”。这时候，存储的树形结构如下：</p>
<pre><code>     foo(1)
       /
    bar(2)
   /      \
baz(3)   quux(4)</code></pre><p>这个树形结构共包含四次改动，括号中的数字就代表时间顺序。</p>
<p>现在，我们有两种方式遍历这个树结构。一种叫「按分支遍历」，一种叫「按时间遍历」。</p>
<p>撤销 <kbd>u</kbd> 与重做 <kbd>Ctrl + r</kbd> 操作是按分支遍历。对于上面的例子，现在我们有三行字符。这时候按 <kbd>u</kbd> 会回退到 “bar” 节点，如果再按一次 <kbd>u</kbd> 则会回退到 “foo” 节点。这时，如果我们按下 <kbd>Ctrl + r</kbd> 就会前进至 “bar” 节点，再按一次就回前进至 “quux” 节点。在这种方式下，我们无法访问到兄弟节点（即 “baz” 节点）。</p>
<p>与之对应的是按时间遍历，对应的按键是 <code>g-</code> 和 <code>g+</code>。对于上面的例子，按下 <code>g-</code> 会首先回退到 “baz” 节点。再次按下 <code>g-</code> 会回退到 “bar” 节点。</p>
<table>
<thead>
<tr>
<th>命令/按键</th>
<th>执行效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>[count]u</code> 或 <code>:undo [count]</code></td>
<td>回退到 <code>[count]</code> 次改动之前</td>
</tr>
<tr>
<td><code>[count]&lt;c-r&gt;</code> 或 <code>:redo [count]</code></td>
<td>重做 <code>[count]</code> 次改动</td>
</tr>
<tr>
<td><code>U</code></td>
<td>回退至最新的改动</td>
</tr>
<tr>
<td><code>[count]g-</code> 或 <code>:earlier [count]?</code></td>
<td>根据时间回退到 <code>[count]</code> 次改动之前。”?” 为 “s”、”m”、”h”、”d” 或 “f”之一。例如，<code>:earlier 2d</code> 会回退到两天之前。<code>:earlier 1f</code> 则会回退到最近一次文件保存时的内容</td>
</tr>
<tr>
<td><code>[count]g+</code> 或 <code>:later [count]?</code></td>
<td>类似 <code>g-</code>，但方向相反</td>
</tr>
</tbody></table>
<p>内容变更记录会储存在内存中，当 Vim 退出时就会清空。如果需要持久化存储内容变更记录，请参阅<a href="#备份文件交换文件撤销文件以及viminfo文件的处理">备份文件，交换文件，撤销文件以及viminfo文件的处理</a>章节的内容。</p>
<p>如果你觉得这一部分的内容难以理解，请参阅 <a href="https://github.com/mbbill/undotree" target="_blank" rel="noopener">undotree</a>，这是一个可视化管理内容变更历史记录的插件。类似的还有 <a href="https://github.com/simnalamburt/vim-mundo" target="_blank" rel="noopener">vim-mundo</a>。</p>
<p>请参阅以下链接获取更多帮助：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:h <span class="keyword">undo</span>.txt</span><br><span class="line">:h usr_32</span><br></pre></td></tr></table></figure>

<p>返回主目录 <a href="#基础">:arrow_heading_up:</a></p>
<h2 id="全局位置信息表，局部位置信息表"><a href="#全局位置信息表，局部位置信息表" class="headerlink" title="全局位置信息表，局部位置信息表"></a>全局位置信息表，局部位置信息表</h2><p>在某一个动作返回一系列「位置」的时候，我们可以利用「全局位置信息表」和「局部位置信息表」来存储这些位置信息，方便以后跳转回对应的位置。每一个存储的位置包括文件名、行号和列号。</p>
<p>比如，编译代码是出现错误，这时候我们就可以把错误的位置直接显示在全局位置信息表，或者通过外部抓取工具使位置显示在局部位置信息表中。</p>
<p>尽管我们也可以把这些信息显示到一个空格缓冲区中，但用这两个信息表显示的好处在于接口调用很方便，而且也便于浏览输出。</p>
<p>Vim 中，全局位置信息表只能有一个，但每一个窗口都可以有自己的局部位置信息表。这两个信息表的外观看上去很类似，但在操作上会稍有不同。</p>
<p>以下为两者的操作比较：</p>
<table>
<thead>
<tr>
<th>动作</th>
<th>全局位置信息表</th>
<th>局部位置信息表</th>
</tr>
</thead>
<tbody><tr>
<td>打开窗口</td>
<td><code>:copen</code></td>
<td><code>:lopen</code></td>
</tr>
<tr>
<td>关闭窗口</td>
<td><code>:cclose</code></td>
<td><code>:lclose</code></td>
</tr>
<tr>
<td>下一个条目</td>
<td><code>:cnext</code></td>
<td><code>:lnext</code></td>
</tr>
<tr>
<td>上一个条目</td>
<td><code>:cprevious</code></td>
<td><code>:lprevious</code></td>
</tr>
<tr>
<td>第一个条目</td>
<td><code>:cfirst</code></td>
<td><code>:lfirst</code></td>
</tr>
<tr>
<td>最后一个条目</td>
<td><code>:clast</code></td>
<td><code>:llast</code></td>
</tr>
</tbody></table>
<p>请参阅 <code>:h :cc</code> 以及底下的内容，来获取更多命令的帮助。</p>
<p><strong>应用实例</strong>：<br>如果我们想用 <code>grep</code> 递归地在当前文件夹中寻找某个关键词，然后把输出结果放到全局位置信息表中，只需要这样：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">let</span> &amp;grepprg = <span class="string">'grep -Rn $* .'</span></span><br><span class="line">:grep! foo</span><br><span class="line">&lt;<span class="keyword">grep</span> output - hit enter&gt;</span><br><span class="line">:<span class="keyword">copen</span></span><br></pre></td></tr></table></figure>

<p>执行了上面的代码，你就能看到所有包含字符串 “foo” 的文件名以及匹配到的相关字段都会显示在全局位置信息表中。</p>
<p>返回主目录 <a href="#基础">:arrow_heading_up:</a></p>
<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p>你可以在 Vim 中录制一系列按键，并把他们存储到<a href="#寄存器">寄存器</a>中。对于一些需要临时使用多次的一系列操作，把它们作为宏保存起来会显著地提升效率。对于一些复杂的操作，建议使用 Vim 脚本来实现。</p>
<ul>
<li>首先，按下 <kbd>q</kbd>，然后按下你想要保存的寄存器，任何小写字母都可以。比如我们来把它保存到 <code>q</code> 这个寄存器中。按下 <code>qq</code>，你会发现命令行里已经显示了 “recording @q”。</li>
<li>如果你已经录制完成，那么只需要再按一次 <kbd>q</kbd> 就可以结束录制。</li>
<li>如果你想调用刚才录制的宏，只需要 <code>[count]@q</code></li>
<li>如果你想调用上一次使用的宏，只需要 <code>[count]@@</code></li>
</ul>
<p><strong>实例1</strong>：</p>
<p>一个插入字符串 “abc” 后换行的宏，重复调用十次：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">qq</span><br><span class="line"><span class="keyword">iabc</span><span class="symbol">&lt;cr&gt;</span><span class="symbol">&lt;esc&gt;</span></span><br><span class="line">q</span><br><span class="line"><span class="number">10</span>@q</span><br></pre></td></tr></table></figure>

<p>（对于上面这个功能，你同样可以通过如下的按键： <kbd>o</kbd><kbd>a</kbd><kbd>b</kbd><kbd>c</kbd> 然后 <kbd>ESC</kbd> 然后 <kbd>1</kbd><kbd>0</kbd><kbd>.</kbd> 来实现）。</p>
<p><strong>实例2</strong>：</p>
<p>一个在每行前都加上行号的宏。从第一行开始，行号为 1，后面依次递增。我们可以通过 <kbd>Ctrl</kbd> + <kbd>a</kbd> 来实现递增的行号，在定义宏的时候，它会显示成 <code>^A</code>。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">qq</span><br><span class="line"><span class="number">0</span>yf jP0^A</span><br><span class="line">q</span><br><span class="line"><span class="number">1000</span> @q</span><br></pre></td></tr></table></figure>

<p>这里能实现功能，是因为我们假定了文件最多只有 1000 行。但更好的方式是使用「递归」宏，它会一直执行，知道不能执行为止：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">qq</span><br><span class="line"><span class="number">0</span>yf jP0^A@q</span><br><span class="line">q</span><br><span class="line">@q</span><br></pre></td></tr></table></figure>

<p>（对于上面这个插入行号的功能，如果你不愿意使用宏，同样可以通过这段按键操作来实现：<code>:%s/^/\=line(&#39;.&#39;) . &#39;. &#39;</code>）。</p>
<p>这里向大家展示了如何不用宏来达到相应的效果，但要注意，这些不用宏的实现方式只适用于这些简单的示例。对于一些比较复杂的自动化操作，你确实应该考虑使用宏。</p>
<p>请参阅以下文档获取更多帮助：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:h recording</span><br><span class="line">:h <span class="string">'lazyredraw'</span></span><br></pre></td></tr></table></figure>

<p>返回主目录 <a href="#基础">:arrow_heading_up:</a></p>
<h2 id="颜色主题"><a href="#颜色主题" class="headerlink" title="颜色主题"></a>颜色主题</h2><p>颜色主题可以把你的 Vim 变得更漂亮。Vim 是由多个组件构成的，我们可以给每一个组件都设置不同的文字颜色、背景颜色以及文字加粗等等。比如，我们可以通过这个命令来设置背景颜色：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">highlight</span> Normal ctermbg=<span class="number">1</span> guibg=<span class="keyword">red</span></span><br></pre></td></tr></table></figure>

<p>执行后你会发现，现在背景颜色变成红色了。请参阅 <code>:h :highlight</code> 来获取更多帮助。</p>
<p>其实，颜色主题就是一系列的 <code>:highlight</code> 命令的集合。</p>
<p>事实上，大部分颜色主题都包含两套配置。一套适用于例如 xterm 和 iTerm 这样的终端环境（使用前缀 <code>cterm</code>），另一套适用于例如 gvim 和 MacVim 的图形界面环境（使用前缀 <code>gui</code>）。对于上面的例子，<code>ctermbg</code> 就是针对终端环境的，而 <code>guibg</code> 就是针对图形界面环境的。</p>
<p>如果你下载了一个颜色主题，并且在终端环境中打开了 Vim，然后发现显示的颜色与主题截图中差别很大，那很可能是配置文件只设置了图形界面环境的颜色。反之同理，如果你使用的是图形界面环境，发现显示颜色有问题，那就很可能是配置文件只设置了终端环境的颜色。</p>
<p>第二种情况（图形界面环境的显示问题）其实不难解决。如果你使用的是 Neovim 或者 Vim 7.4.1830 的后续版本，可以通过打开<a href="https://zh.wikipedia.org/wiki/真彩色" target="_blank" rel="noopener">真彩色</a>设置来解决显示问题。这就可以让终端环境的 Vim 使用 GUI 的颜色定义，但首先，你要确认一下你的终端环境和环境内的组件（比如 tmux）是否都支持真彩色。可以看一下<a href="https://gist.github.com/XVilka/8346728" target="_blank" rel="noopener">这篇文档</a>，描述的十分详细。</p>
<p>请参阅以下文档或链接来获取更多帮助：</p>
<ul>
<li><code>:h &#39;termguicolors&#39;</code></li>
<li><a href="#主题列表">主题列表</a></li>
<li><a href="#自定义主题中的颜色">自定义主题中的颜色</a></li>
</ul>
<p>返回主目录 <a href="#基础">:arrow_heading_up:</a></p>
<h2 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h2><p>每一部分文字（或者代码）都会有特定的结构。对于存在结构的文字和代码，也就意味着它们可以按照一定的逻辑分割成不同区域。Vim 中的折叠功能，就是按照特定的逻辑把文字和代码折叠成一行，并显示一些简短的描述。折叠功能涉及到很多操作，而且折叠功能可以嵌套使用。</p>
<p>在 Vim 中，有以下 6 中折叠类型：</p>
<table>
<thead>
<tr>
<th>折叠方式</th>
<th>概述</th>
</tr>
</thead>
<tbody><tr>
<td>diff</td>
<td>在「比较窗口」中折叠未改变的文本</td>
</tr>
<tr>
<td>expr</td>
<td>使用 <code>&#39;foldexpr&#39;</code> 来创建新的折叠逻辑</td>
</tr>
<tr>
<td>indent</td>
<td>基于缩进折叠</td>
</tr>
<tr>
<td>manual</td>
<td>使用 <code>zf</code>、<code>zF</code> 或 <code>:fold</code> 来自定义折叠</td>
</tr>
<tr>
<td>marker</td>
<td>根据特定的文本标记折叠（通常用于代码注释）</td>
</tr>
<tr>
<td>syntax</td>
<td>根据语法折叠，比如折叠 <code>if</code> 代码块</td>
</tr>
</tbody></table>
<p><strong>注意</strong>：折叠功能可能会显著地影响性能。如果你在使用折叠功能的时候出现了打字卡顿之类的问题，请考虑使用 <a href="https://github.com/Konfekt/FastFold" target="_blank" rel="noopener">FastFold 插件</a>。这个插件可以让 Vim 按需更新折叠内容，而不是一直调用。</p>
<p>请参阅以下文档获取更多帮助：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:h usr_28</span><br><span class="line">:h folds</span><br></pre></td></tr></table></figure>

<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>如果你保存了当前的「视图」（请参阅 <code>:h :mkview</code>），那么当前窗口、配置和按键映射都会被保存下来（请参阅 <code>:h :loadview</code>）。</p>
<p>「会话」就是存储所有窗口的相关设置，以及全局设置。简单来说，就是给当前的 Vim 运行实例拍个照，然后把相关信息存储到会话文件中。存储之后的改动就不会在会话文件中显示，你只需要在改动后更新一下会话文件就可以了。</p>
<p>你可以把当前工作的「项目」存储起来，然后可以在不同的「项目」之间切换。</p>
<p>现在就来试试吧。打开几个窗口和标签，然后执行 <code>:mksession Foo.vim</code>。如果你没有指定文件名，那就会默认保存为 <code>Session.vim</code>。这个文件会保存在当前的目录下，你可以通过 <code>:pwd</code> 来显示当前路径。重启 Vim 之后，你只需要执行 <code>:source Foo.vim</code>，就可以恢复刚才的会话了。所有的缓冲区、窗口布局、按键映射以及工作路径都会恢复到保存时的状态。</p>
<p>其实 Vim 的会话文件就只是 Vim 命令的集合。你可以通过命令 <code>:vs Foo.vim</code> 来看看会话文件中究竟有什么。</p>
<p>你可以决定 Vim 会话中究竟要保存哪些配置，只需要设置一下 <code>&#39;sessionoptions&#39;</code> 就可以了。</p>
<p>为了方便开发，Vim 把最后一次调用或写入的会话赋值给了一个内部变量 <code>v:this_session</code>。</p>
<p>请参阅以下文档来获取更多帮助：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:h Session</span><br><span class="line">:h <span class="string">'sessionoptions'</span></span><br><span class="line">:h <span class="variable">v:this_session</span></span><br></pre></td></tr></table></figure>

<h2 id="局部化"><a href="#局部化" class="headerlink" title="局部化"></a>局部化</h2><p>以上提到的很多概念，都有一个局部化（非全局）的版本：</p>
<table>
<thead>
<tr>
<th>全局</th>
<th>局部</th>
<th>作用域</th>
<th>帮助文档</th>
</tr>
</thead>
<tbody><tr>
<td><code>:set</code></td>
<td><code>:setlocal</code></td>
<td>缓冲区或窗口</td>
<td><code>:h local-options</code></td>
</tr>
<tr>
<td><code>:map</code></td>
<td><code>:map &lt;buffer&gt;</code></td>
<td>缓冲区</td>
<td><code>:h :map-local</code></td>
</tr>
<tr>
<td><code>:autocmd</code></td>
<td><code>:autocmd * &lt;buffer&gt;</code></td>
<td>缓冲区</td>
<td><code>:h autocmd-buflocal</code></td>
</tr>
<tr>
<td><code>:cd</code></td>
<td><code>:lcd</code></td>
<td>窗口</td>
<td><code>:h :lcd</code></td>
</tr>
<tr>
<td><code>:&lt;leader&gt;</code></td>
<td><code>:&lt;localleader&gt;</code></td>
<td>缓冲区</td>
<td><code>:h maploacalleader</code></td>
</tr>
</tbody></table>
<p>变量也有不同的作用域，详细内容请参考 <a href="http://vimdoc.sourceforge.net/htmldoc/usr_41.html" target="_blank" rel="noopener">Vim scripting 的文档</a>。</p>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="获取离线帮助"><a href="#获取离线帮助" class="headerlink" title="获取离线帮助"></a>获取离线帮助</h2><p>Vim 自带了一套很完善的帮助文档，它们是一个个有固定排版格式的文本文件，通过标签可以访问这些文件的特定位置。</p>
<p>在开始之前先读一下这个章节：<code>:help :help</code>。执行这个命令以后会在新窗口打开 <code>$VIMRUNTIME/doc/helphelp.txt</code> 文件并跳转到这个文件中 <code>:help</code> 标签的位置。</p>
<p>一些关于帮助主题的简单规则：</p>
<ul>
<li>用单引号把文本包起来表示选项，如：<code>:h &#39;textwidth&#39;</code></li>
<li>以小括号结尾表示 VimL 函数，如：<code>:h reverse()</code></li>
<li>以英文冒号开头表示命令，如：<code>:h :echo</code></li>
</ul>
<p>使用快捷键 <code>&lt;c-d&gt;</code> （这是 <kbd>ctrl</kbd>+<kbd>d</kbd>）来列出所有包含你当前输入的内容的帮助主题。如：<code>:h tab&lt;c-d&gt;</code> 会列出所有包含 <code>tab</code> 主题，从 <code>softtabstop</code> 到 <code>setting-guitablabel</code> （译者注：根据安装的插件不同列出的选项也会不同）。</p>
<p>你想查看所有的 VimL 方法吗？很简单，只要输入：<code>:h ()&lt;c-d&gt;</code> 就可以了。你想查看所有与窗口相关的函数吗？输入 <code>:h win*()&lt;c-d&gt;</code>。</p>
<p>相信你很快就能掌握这些技巧，但是在刚开始的时候，你可能对于该通过什么进行查找一点线索都没有。这时你可以想象一些与要查找的内容相关的关键字，再让 <code>:helpgrep</code> 来帮忙。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">helpgrep</span> backwards</span><br></pre></td></tr></table></figure>

<p>上面的命令会在所有的帮助文件中搜索“backwards”，然后跳转到第一个匹配的位置。所有的匹配位置都会被添加到全局位置信息表，用 <code>:cp / :cn</code> 可以在匹配位置之间进行切换。或者用 <code>:copen</code> 命令来打开全局位置信息表，将光标定位到你想要的位置，再按 回车就可以跳转到该匹配项。详细说明请参考 <code>:h quickfix</code>。</p>
<h2 id="获取离线帮助（补充）"><a href="#获取离线帮助（补充）" class="headerlink" title="获取离线帮助（补充）"></a>获取离线帮助（补充）</h2><p>这个列表最初发表在 <a href="https://groups.google.com/forum/#!forum/vim_dev" target="_blank" rel="noopener">vim_dev</a>，由 @chrisbra 编辑的，他是 Vim 开发人员中最活跃的一个。</p>
<p>经过一些微小的改动后，重新发布到了这里。</p>
<hr>
<p>如果你知道你想要找什么，使用帮助系统的搜索会更简单一些，因为搜索出的主题都带有固定的格式。</p>
<p>而且帮助系统中的主题包含了你当前使用的 Vim 版本的所特有特性，而网上那些已经过时或者是早期发布的话题是不会包含这些的。</p>
<p>因此学习使用帮助系统以及它所用的语言是很有必要的。这里是一些例子（不一定全，我有可能忘了一些什么）。</p>
<p>（译者注：下面列表中提及的都是如何指定搜索主题以便快速准确的找到你想要的帮助）</p>
<ol>
<li><p>选项要用单引号引起来。用 <code>:h &#39;list&#39;</code> 来查看列表选项帮助。只有你明确的知道你要找这么一个选项的时候才可以这么做，不然的话你可以用 <code>:h options.txt</code> 来打开所有选项的帮助页面，再用正则表达式进行搜索，如：<code>/width</code>。某些选项有它们自己的命名空间，如：<code>:h cpo-a</code>，<code>:h cpo-A</code>， <code>:h cpo-b</code> 等等。</p>
</li>
<li><p>普通模式的命令不能用冒号作为前缀。使用 <code>:h gt</code> 来转到“gt”命令的帮助页面。</p>
</li>
<li><p>正则表达式以“/”开头，所以 <code>:h /\+</code> 会带你到正则表达式中量词“+”的帮助页面。</p>
</li>
<li><p>组合键经常以一个字母开头表示它们可以在哪些模式中使用。如：<code>:h i_CTRL-X</code> 会带你到插入模式下的 CTRL-X 命令的用法帮助页面，这是一个自动完成类的组合键。需要注意的是某些键是有固定写法的，如Control键写成CTRL。还有，查找普通模式下的组合键帮助时，可以省略开头的字母“n”，如：<code>:h CTRL-A</code>。而 <code>:h c_CTRL-A</code>（译者注：原文为 <code>:h c_CRTL-R</code>，感觉改为 A 更符合上下文语境）会解释 CTRL-A 在命令模式下输入命令时的作用；<code>:h v_CTRL-A</code> 说的是在可见模式下把光标所在处的数字加 1；<code>:h g_CTRL-A</code> 则说的是 g 命令（你需要先按 “g” 的命令）。这里的 “g” 代表一个普通的命令，这个命令总是与其它的按键组合使用才生效，与 “z” 开始的命令相似。</p>
</li>
<li><p>寄存器是以 “quote” 开头的。如：<code>:h quote:</code> （译者注：原文为<code>:h quote</code>，感觉作者想以”:”来举例）来查看关于”:”寄存器的说明。</p>
</li>
<li><p>关于 Vim 脚本（VimL）的帮助都在 <code>:h eval.txt</code> 里。而某些方面的语言可以使用 <code>:h expr-X</code> 获取帮助，其中的 ‘X’ 是一个特定的字符，如：<code>:h expr-!</code> 会跳转到描述 VimL 中’!’（非）的章节。另外一个重要提示，可以使用 <code>:h function-list</code> 来查看所有函数的简要描述，列表中包括函数名和一句话描述。</p>
</li>
<li><p>关于映射都可以在 <code>:h map.txt</code> 中找到。通过 <code>:h mapmode-i</code> 来查找 <code>:imap</code> 命令的相关信息；通过 <code>:h map-topic</code> 来查找专门针对映射的帮助（译者注：topic 为一个占位符，正如上面的字符 ‘X’ 一样，在实际使用中需要替换成相应的单词）（如：<code>:h :map-local</code> 查询本地buffer的映射，<code>:h map-bar</code> 查询如何在映射中处理’|’)。</p>
</li>
<li><p>命令定义用 “command-“ 开头，如用 <code>:h command-bar</code> 来查看自定义命令中’!’的作用。</p>
</li>
<li><p>窗口管理类的命令是以 “CTRL-W” 开头的，所以你可以用 <code>:h CTRL-W_*</code> 来查找相应的帮助（译者注：’*‘同样为占位符）（如：<code>:h CTRL-W_p</code> 查看切换到之前访问的窗口命令的解释）。如果你想找窗口处理的命令，还可以通过访问 <code>:h windows.txt</code> 并逐行向下浏览，所有窗口管理的命令都在这里了。</p>
</li>
<li><p>执行类的命令以”:”开头，即：<code>:h :s</code> 讲的是 “:s” 命令。</p>
</li>
<li><p>在输入某个话题时按 CTRL-D，让 Vim 列出所有的近似项辅助你输入。</p>
</li>
<li><p>用 <code>:helpgrep</code> 在所有的帮助页面（通常还包括了已安装的插件的帮助页面）中进行搜索。参考 <code>:h :helpgrep</code> 来了解如何使用。当你搜索了一个话题之后，所有的匹配结果都被保存到了全局位置信息表（或局部位置信息表）当中，可以通过 <code>:copen</code> 或 <code>:lopen</code> 打开。在打开的窗口中可能通过 <code>/</code> 对搜索结果进行进一步的过滤。</p>
</li>
<li><p><code>:h helphelp</code> 里介绍了如何使用帮助系统。</p>
</li>
<li><p>用户手册。它采用了一种对初学者更加友好的方式来展示帮助话题。用 <code>:h usr_toc.txt</code> 打开目录（你可能已经猜到这个命令的用处了）。浏览用户手册能帮助你找出某些你想了解的话题，如你可以在第24章看到关于“复合字符”以及“输入特殊字符”的讲解（用 <code>:h usr_24.txt</code> 可以快速打开相关章节）。</p>
</li>
<li><p>高亮分组的帮助以 <code>hl-</code> 开头。如：<code>:h hl-WarningMsg</code> 说的是警告信息分组的高亮。</p>
</li>
<li><p>语法高亮以<code>:syc-</code> 开头，如：<code>:h :syn-conceal</code> 讲的是 <code>:syn</code> 命令的对于隐藏字符是如何显示的。</p>
</li>
<li><p>快速修复命令以 <code>:c</code> 开头，而位置列表命令以 <code>:l</code> 开头。</p>
</li>
<li><p><code>:h BufWinLeave</code> 讲的是 BufWinLeave 自动命令。还有，<code>:h autocommand-events</code> （译者注：原文是 <code>:h autocommands-events</code>，但是没有该帮助）讲的是所有可用的事件。</p>
</li>
<li><p>启动参数都以“-”开头，如：<code>:h -f</code> 会告诉你 Vim 中 “-f” 参数的作用。</p>
</li>
<li><p>额外的特性都以“+”开头，如：<code>:h +conceal</code> 讲的是关于隐藏字符的支持。</p>
</li>
<li><p>错误代码可以在帮助系统中直接查到。<code>:h E297</code> 会带你到关于这一错误的详细解释。但是有时并没有转到错误描述，而是列出了经常导出这一错误的 Vim 命令，如 <code>:h E128</code> （译者注：原文为<code>:h hE128</code>，但是并没有该帮助）会直接跳转到 <code>:function</code> 命令。</p>
</li>
<li><p>关于包含的语法文件的文档的帮助话题格式是 <code>:h ft-*-syntax</code>。如：<code>:h ft-c-syntax</code> 说的就是C语言语法文件以及它所提供的选项。有的语法文件还会带有自动完成（<code>:h ft-php-omni</code>）或文件类型插件（<code>:h ft-tex-plugin</code>）相关的章节可以查看。</p>
</li>
</ol>
<p>另外在每个帮助页的顶端通常会包含一个用户文档链接（更多的从从用户的角度出发来主角命令的功能和用法，不涉及那么多细节）。如：<code>:h pattern.txt</code> 里包含了 <code>:h 03.9</code> 和 <code>:h usr_27</code> 两个章节的链接。</p>
<h2 id="获取在线帮助"><a href="#获取在线帮助" class="headerlink" title="获取在线帮助"></a>获取在线帮助</h2><p>如果你遇到了无法解决的问题，或者需要指引的话，可以参考 <a href="https://groups.google.com/forum/#!forum/vim_use" target="_blank" rel="noopener">Vim 使用</a>邮件列表。 <a href="https://de.wikipedia.org/wiki/Internet_Relay_Chat" target="_blank" rel="noopener">IRC</a> 也是一个很不错的资源。 <a href="https://freenode.net/" target="_blank" rel="noopener">Freenode</a> 上的 <code>#vim</code> 频道很庞大，并且里面有许多乐于助人的人。</p>
<p>如果你想给 Vim 提交 Bug 的话，可以使用 <a href="https://groups.google.com/forum/#!forum/vim_dev" target="_blank" rel="noopener">vim_dev</a> 邮件列表。</p>
<h2 id="执行自动命令"><a href="#执行自动命令" class="headerlink" title="执行自动命令"></a>执行自动命令</h2><p>你可以触发任何事件，如：<code>:doautocmd BufRead</code>。</p>
<h3 id="用户自定义事件"><a href="#用户自定义事件" class="headerlink" title="用户自定义事件"></a>用户自定义事件</h3><p>对于插件而言，创建你自己的自定义事件有时非常有用。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">Chibby</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">" A lot of stuff is happening here.</span></span><br><span class="line">    <span class="comment">" And at last..</span></span><br><span class="line">    <span class="keyword">doautocmd</span> User ChibbyExit</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<p>现在你插件的用户可以在Chibby执行完成之后做任何他想做的事情：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">autocmd</span> User ChibbyExit <span class="keyword">call</span> ChibbyCleanup()</span><br></pre></td></tr></table></figure>

<p>顺便提一句，如果在使用 <code>:autocmd</code> 或 <code>:doautocmd</code> 时没有捕捉异常，那么会输出 “No matching autocommands” 信息。这也是为什么许多插件用 <code>silent doautocmd ...</code> 的原因。但是这也会有不足，那就是你不能再在 :autocmd 中使用 <code>echo &quot;foo&quot;</code> 了，取而代之的是你要使用 <code>unsilent echo &quot;foo&quot;</code> 来输出。</p>
<p>这就是为什么要在触发事件之前先判断事件是否存在的原因，</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">exists</span>(<span class="string">'#User#ChibbyExit'</span>)</span><br><span class="line">  <span class="keyword">doautocmd</span> User ChibbyExit</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p>帮助文档：<code>:h User</code></p>
<h3 id="事件嵌套"><a href="#事件嵌套" class="headerlink" title="事件嵌套"></a>事件嵌套</h3><p>默认情况下，自动命令不能嵌套！如果某个自动命令执行了一个命令，这个命令再依次触发其它的事件，这是不可能的。</p>
<p>例如你想在每次启动 Vim 的时候自动打开你的 vimrc 文件：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">autocmd</span> VimEnter * <span class="keyword">edit</span> $MYVIMRC</span><br></pre></td></tr></table></figure>

<p>当你启动 Vim 的时候，它会帮你打开你的 vimrc 文件，但是你很快会注意到这个文件没有任何的高亮，尽管平时它是正常可以高亮的。</p>
<p>问题在于你的非嵌套自动命令 <code>:edit</code> 不会触发“BufRead”事件，所以并不会把文件类型设置成“vim”，进而 <code>$VIMRUNTIME/syntax/vim.vim</code> 永远不会被引入。详细信息请参考：<code>:au BufRead *.vim</code>。要想完成上面所说的需求，使用下面这个命令：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">autocmd</span> VimEnter * nested <span class="keyword">edit</span> $MYVIMRC</span><br></pre></td></tr></table></figure>

<p>帮助文档：<code>:h autocmd-nested</code></p>
<h2 id="剪切板"><a href="#剪切板" class="headerlink" title="剪切板"></a>剪切板</h2><p>如果你想在没有GUI支持的Unix系统中使用 Vim 的 <code>&#39;clipboard&#39;</code> 选项，则需要 <code>+clipboard</code> 以及可选的 <code>+xterm_clipboard</code> 两个<a href="#what-kind-of-vim-am-i-running">特性</a>支持。</p>
<p>帮助文档：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:h <span class="string">'clipboard'</span></span><br><span class="line">:h <span class="keyword">gui</span>-clipboard</span><br><span class="line">:h <span class="keyword">gui</span>-selections</span><br></pre></td></tr></table></figure>

<p>另外请参考：<a href="#持续粘贴为什么我每次都要设置-paste-模式">持续粘贴（为什么我每次都要设置 ‘paste’ 模式</a></p>
<h3 id="剪贴板的使用（Windows-OSX）"><a href="#剪贴板的使用（Windows-OSX）" class="headerlink" title="剪贴板的使用（Windows, OSX）"></a>剪贴板的使用（Windows, OSX）</h3><p>Windows 自带了<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms649012(v=vs.85).aspx" target="_blank" rel="noopener">剪贴板</a>，OSX 则带了一个<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/PasteboardGuide106/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008100-SW1" target="_blank" rel="noopener">粘贴板</a></p>
<p>在这两个系统中都可以用大家习惯用的 <code>ctrl+c / cmd+c</code> 复制选择的文本，然后在另外一个应用中用 <code>ctrl+v / cmd+v</code> 进行粘贴。</p>
<p>需要注意的是复制的文本已经被发送到了剪贴板，所以你在粘贴复制的内容之前关闭这个应用是没有任何问题的。</p>
<p>每次复制的时候，都会向剪贴板寄存器 <code>*</code> 中写入数据。 而在 Vim 中分别使用 <code>&quot;*y</code> 和 <code>&quot;*p</code> 来进行复制（yank) 和 粘贴（paste)。</p>
<p>如果你不想每次操作都要指定 <code>*</code> 寄存器，可以在你的 vimrc 中添加如下配置：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> clipboard=unnamed</span><br></pre></td></tr></table></figure>

<p>通常情况下复制/删除/放入操作会往 <code>&quot;</code> 寄存器中写入数据，而加上了上面的配置之后 <code>*</code> 寄存器也会被写入同样数据，因此简单的使用 <code>y</code> 和 <code>p</code> 就可以复制粘贴了。</p>
<p>我再说一遍：使用上面的选项意味着每一次的复制/粘贴，即使在同一个 Vim 窗口里，都会修改剪贴板的内容。你自己决定上面的选项是否适合。</p>
<p>如果你觉得输入 <code>y</code> 还是太麻烦的话，可以使用下面的设置把在可视模式下选择的内容发送到剪贴板：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> clipboard=unnamed,autoselect</span><br><span class="line"><span class="keyword">set</span> guioptions+=<span class="keyword">a</span></span><br></pre></td></tr></table></figure>

<p>帮助文档：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:h clipboard-unnamed</span><br><span class="line">:h autoselect</span><br><span class="line">:h <span class="string">'go_a'</span></span><br></pre></td></tr></table></figure>

<h3 id="剪贴板的使用（Linux-BSD-…）"><a href="#剪贴板的使用（Linux-BSD-…）" class="headerlink" title="剪贴板的使用（Linux, BSD, …）"></a>剪贴板的使用（Linux, BSD, …）</h3><p>如果你的系统使用了 <a href="http://www.x.org/wiki" target="_blank" rel="noopener">X 图形界面</a>，事情会变得有一点不同。X 图形界面实现了 <a href="http://www.x.org/releases/X11R7.7/doc/xproto/x11protocol.html" target="_blank" rel="noopener">X 窗口系统协议</a>, 这个协议在1987年发布的主版本11，因此 X 也通常被称为 X11。</p>
<p>在 X10 版本中，<a href="http://www.x.org/releases/X11R7.7/doc/xorg-docs/icccm/icccm.html#Peer_to_Peer_Communication_by_Means_of_Cut_Buffers" target="_blank" rel="noopener">剪贴缓冲区</a>被用来实现像 <em>clipboard</em> 一样由 X 来复制文本，并且可以被所有的程序访问。现在这个机制在 X 中还存在，但是已经过时了，很多程序都不再使用这一机制。</p>
<p>近年来数据在程序之间是通过<a href="http://www.x.org/releases/X11R7.7/doc/xorg-docs/icccm/icccm.html#Peer_to_Peer_Communication_by_Means_of_Selections" target="_blank" rel="noopener">选择</a>进行传递的。一共有三种选择，经常用到的有两种：PRIMARY 和 CLIPBOARD。</p>
<p>选择的工作工模大致是这样的：</p>
<pre><code>Program A：&lt;ctrl+c&gt;
Program A：声称对 CLIPBOARD 的所有权
Program B：&lt;ctrl+v&gt;
Program B：发现CLIPBOARD的所有权被Program A持有
Program B：从Program A请求数据
Program A：响应这个请求并发送数据给Program B
Program B：从Program A接收数据并插入到窗口中</code></pre><table>
<thead>
<tr>
<th>选择</th>
<th>何时使用</th>
<th>如何粘贴</th>
<th>如何在 Vim 中访问</th>
</tr>
</thead>
<tbody><tr>
<td>PRIMARY</td>
<td>选择文本</td>
<td>鼠标中键, shift+insert</td>
<td><code>*</code> 寄存器</td>
</tr>
<tr>
<td>CLIPBOARD</td>
<td>选择文本并按 <code>ctrl+c</code></td>
<td><code>ctrl+v</code></td>
<td><code>+</code>寄存器</td>
</tr>
</tbody></table>
<p><strong>注意</strong>：X 服务器并不会保存选择（不仅仅是 CLIPBOARD 选择）！因此在关闭了相应的程序后，你用 <code>ctrl+c</code> 复制的内容将丢失。</p>
<p>使用 <code>&quot;*p</code> 来贴粘 PRIMARY 选择中的内容，或者使用 <code>&quot;+y1G</code> 来将整个文件的内容复制到 CLIPBOARD 选择。</p>
<p>如果你需要经常访问这两个寄存器，可以考虑使用如下配置：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> clipboard^=unnamed          <span class="comment">" * 寄存器</span></span><br><span class="line"><span class="comment">" 或者</span></span><br><span class="line"><span class="keyword">set</span> clipboard^=unnamedplus      <span class="comment">" + 寄存器</span></span><br></pre></td></tr></table></figure>

<p>（<code>^=</code> 用来将设置的值加到默认值之前，详见：<code>:h :set^=</code>）</p>
<p>这会使得所有复制/删除/放入操作使用 <code>*</code> 或 <code>+</code> 寄存器代替默认的未命令寄存器 <code>&quot;</code>。之后你就可以直接使用 <code>y</code> 或 <code>p</code> 访问你的X选择了。</p>
<p>帮助文档：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:h clipboard-unnamed</span><br><span class="line">:h clipboard-unnamedplus</span><br></pre></td></tr></table></figure>

<h2 id="打开文件时恢复光标位置"><a href="#打开文件时恢复光标位置" class="headerlink" title="打开文件时恢复光标位置"></a>打开文件时恢复光标位置</h2><p>如果没有这个设置，每次打开文件时光标都将定位在第一行。而加入了这个设置以后，你就可以恢复到上次关闭文件时光标所在的位置了。</p>
<p>将下面的配置添加到你的 vimrc 文件：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">autocmd</span> BufReadPost *</span><br><span class="line">    \ <span class="keyword">if</span> <span class="built_in">line</span>(<span class="string">"'\""</span>) &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">line</span>(<span class="string">"'\""</span>) &lt;= <span class="built_in">line</span>(<span class="string">"$"</span>) |</span><br><span class="line">    \   <span class="keyword">exe</span> <span class="string">"normal! g`\""</span> |</span><br><span class="line">    \ <span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p>这是通过判断之前的光标位置是否存在（文件可能被其它程序修改而导致所记录的位置已经不存在了），如果存在的话就执行 <code>g`&quot;</code> （转到你离开时的光标位置但是不更改跳转列表）。</p>
<p>这需要使用 viminfo 文件：<code>:h viminfo-</code>。</p>
<h2 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h2><p>根据选项的不同， Vim 最多会创建4种工作文件。</p>
<h3 id="备份文件"><a href="#备份文件" class="headerlink" title="备份文件"></a>备份文件</h3><p>你可以让 Vim 在将修改写入到文件之前先备份原文件。默认情况下， Vim 会保存一个备份文件但是当修改成功写入后会立即删除它（<code>:set writebackup</code>）。如果你想一直保留这个备份文件的话，可以使用 <code>:set backup</code>。而如果你想禁用备份功能的话，可以使用 <code>:set nobackup nowritebackup</code>。</p>
<p>咱们来看一下上次我在 vimrc 中改了什么：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ diff ~/.vim/vimrc ~/.vim/files/backup/vimrc-vimbackup</span><br><span class="line">390d389</span><br><span class="line">&lt; <span class="built_in">command</span>! -bar -nargs=* -complete=<span class="built_in">help</span> H helpgrep &lt;args&gt;</span><br></pre></td></tr></table></figure>

<p>帮助文档：<code>:h backup</code></p>
<h3 id="交换文件"><a href="#交换文件" class="headerlink" title="交换文件"></a>交换文件</h3><p>假设你有一个非常棒的科幻小说的构思。在按照故事情节已经写了好几个小时几十万字的时候..忽然停电了！而那时你才想起来你上次保存 <code>~/来自外太空的邪恶入侵者.txt</code> 是在.. 好吧，你从来没有保存过。</p>
<p>但是并非没有希望了！在编辑某个文件的时候， Vim 会创建一个交换文件，里面保存的是对当前文件所有未保存的修改。自己试一下，打开任意的文件，并使用 <code>:swapname</code> 获得当前的交换文件的保存路径。你也可以将 <code>:set noswapfile</code> 加入到 vimrc 中来禁用交换文件。</p>
<p>默认情况下，交换文件会自动保存在被编辑文件所在的目录下，文件名以 <code>.file.swp</code> 后缀结尾，每当你修改了超过 200 个字符或是在之前 4 秒内没有任何动作时更新它的内容，在你不再编辑这个文件的时候会被删除。你可以自己修改这些数字，详见：<code>:h &#39;updatecount&#39;</code> 和 <code>:h &#39;updatetime&#39;</code>。</p>
<p>而在断电时，交换文件并不会被删除。当你再次打开 <code>vim ~/来自外太空的邪恶入侵者.txt</code> 时， Vim 会提示你恢复这个文件。</p>
<p>帮助文档：<code>:h swap-file</code> 和 <code>:h usr_11</code></p>
<h3 id="撤销文件"><a href="#撤销文件" class="headerlink" title="撤销文件"></a>撤销文件</h3><p><a href="#%E5%86%85%E5%AE%B9%E5%8F%98%E6%9B%B4%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95">内容变更历史记录</a>是保存在内存中的，并且会在 Vim 退出时清空。如果你想让它持久化到磁盘中，可以设置 <code>:set undofile</code>。这会把文件 <code>~/foo.c</code> 的撤销文件保存在 <code>~/foo.c.un~</code>。</p>
<p>帮助文档：<code>:h &#39;undofile&#39;</code> 和 <code>:h undo-persistence</code></p>
<h3 id="viminfo-文件"><a href="#viminfo-文件" class="headerlink" title="viminfo 文件"></a>viminfo 文件</h3><p>备份文件、交换文件和撤销文件都是与文本状态相关的，而 viminfo 文件是用来保存在 Vim 退出时可能会丢失的其它的信息的。包括历史记录（命令历史、搜索历史、输入历史）、寄存器内容、标注、缓冲区列表、全局变量等等。</p>
<p>默认情况下，viminfo 被保存在 <code>~/.viminfo</code>。</p>
<p>帮助文档：<code>:h viminfo</code> 和 <code>:h &#39;viminfo&#39;</code></p>
<h3 id="临时文件管理设置示例"><a href="#临时文件管理设置示例" class="headerlink" title="临时文件管理设置示例"></a>临时文件管理设置示例</h3><p>如果你跟我一样，也喜欢把这些文件放到一个位置（如：<code>~/.vim/files</code>）的话，可以使用下面的配置：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">" 如果文件夹不存在，则新建文件夹</span></span><br><span class="line"><span class="keyword">if</span> !isdirectory($HOME.<span class="string">'/.vim/files'</span>) &amp;&amp; <span class="built_in">exists</span>(<span class="string">'*mkdir'</span>)</span><br><span class="line">  <span class="keyword">call</span> <span class="built_in">mkdir</span>($HOME.<span class="string">'/.vim/files'</span>)</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" 备份文件</span></span><br><span class="line"><span class="keyword">set</span> backup</span><br><span class="line"><span class="keyword">set</span> backupdir   =$HOME/.<span class="keyword">vim</span>/<span class="keyword">files</span>/backup/</span><br><span class="line"><span class="keyword">set</span> backupext   =-vimbackup</span><br><span class="line"><span class="keyword">set</span> backupskip  =</span><br><span class="line"><span class="comment">" 交换文件</span></span><br><span class="line"><span class="keyword">set</span> directory   =$HOME/.<span class="keyword">vim</span>/<span class="keyword">files</span>/swap//</span><br><span class="line"><span class="keyword">set</span> updatecount =<span class="number">100</span></span><br><span class="line"><span class="comment">" 撤销文件</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">undofile</span></span><br><span class="line"><span class="keyword">set</span> undodir     =$HOME/.<span class="keyword">vim</span>/<span class="keyword">files</span>/<span class="keyword">undo</span>/</span><br><span class="line"><span class="comment">" viminfo 文件</span></span><br><span class="line"><span class="keyword">set</span> viminfo     =<span class="string">'100,n$HOME/.vim/files/info/viminfo</span></span><br></pre></td></tr></table></figure>

<p>注意：如果你在一个多用户系统中编辑某个文件时， Vim 提示你交换文件已经存在的话，可能是因为有其他的用户此时正在编辑这个文件。而如果将交换文件放到自己的home目录的话，这个功能就失效了。因此服务器非常不建议将这些文件修改到HOME目录，避免多人同时编辑一个文件，却没有任何警告。</p>
<h2 id="编辑远程文件"><a href="#编辑远程文件" class="headerlink" title="编辑远程文件"></a>编辑远程文件</h2><p>Vim 自带的 netrw 插件支持对远程文件的编辑。实际上它将远程的文件通过 scp 复制到本地的临时文件中，再用那个文件打开一个缓冲区，然后在保存时把文件再复制回远程位置。</p>
<p>下面的命令在你本地的 VIM 配置与 SSH 远程服务器上管理员想让你使用的配置有冲突时尤其有用：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">e</span> scp://bram@awesome.site.<span class="keyword">com</span>/.vimrc</span><br></pre></td></tr></table></figure>

<p>如果你已经设置了 <code>~/.ssh/config</code>，SSH 会自动读取这里的配置：</p>
<pre><code>Host awesome
    HostName awesome.site.com
    Port 1234
    User bram</code></pre><p>如果你的 <code>~/.ssh/config</code> 中有以上的内容，那么下面的命令就可以正常执行了：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">e</span> scp://awesome/.vimrc</span><br></pre></td></tr></table></figure>

<p>可以用同样的方法编辑 <code>~/.netrc</code>, 详见：<code>:h netrc-netrc</code>。</p>
<p>确保你已经看过了 <code>:h netrw-ssh-hack</code> 和 <code>:h g:netrw_ssh_cmd</code>。</p>
<p>另外一种编辑远程文件的方法是使用 <a href="https://wiki.archlinux.org/index.php/Sshfs" target="_blank" rel="noopener">sshfs</a>，它会用 <a href="https://en.wikipedia.org/wiki/Filesystem_in_Userspace" target="_blank" rel="noopener">FUSE</a> 来挂载远程的文件系统到你本地的系统当中。</p>
<h2 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h2><p><a href="https://github.com/tpope/vim-pathogen" target="_blank" rel="noopener">Pathogen</a>是第一个比较流行的插件管理工具。实际上它只是修改了 <em>runtimepath</em> （<code>:h &#39;rtp&#39;</code>） 来引入所有放到该目录下的文件。你需要自己克隆插件的代码仓库到那个目录。</p>
<p>真正的插件管理工具会在 Vim 中提供帮助你安装或更新插件的命令。以下是一些常用的插件管理工具：</p>
<ul>
<li><a href="https://github.com/Shougo/dein.vim" target="_blank" rel="noopener">dein</a></li>
<li><a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener">plug</a></li>
<li><a href="https://github.com/MarcWeber/vim-addon-manager" target="_blank" rel="noopener">vim-addon-manager</a></li>
<li><a href="https://github.com/VundleVim/Vundle.vim" target="_blank" rel="noopener">vundle</a></li>
</ul>
<h2 id="多行编辑"><a href="#多行编辑" class="headerlink" title="多行编辑"></a>多行编辑</h2><p>这是一种可以同时输入多行连续文本的技术。参考这个<a href="https://raw.githubusercontent.com/mhinz/vim-galore/master/contents/images/content-block_insert.gif" target="_blank" rel="noopener">示例</a>。</p>
<p>用 <code>&lt;c-v&gt;</code> 切换到可视块模式。然后向下选中几行，按 <code>I</code> 或 <code>A</code> （译者注：大写字母，即 shift+i 或 shift+a）然后开始输入你想要输入的文本。</p>
<p>在刚开始的时候可能会有些迷惑，因为文本只出现在了当前编辑的行，只有在当前的插入动作结束后，之前选中的其它行才会出现插入的文本。</p>
<p>举一个简单的例子：<code>&lt;c-v&gt;3jItext&lt;esc&gt;</code>。</p>
<p>如果你要编辑的行长度不同，但是你想在他们后面追加相同的内容的话，可以试一下这个：<code>&lt;c-v&gt;3j$Atext&lt;esc&gt;</code>。</p>
<p>有时你可能需要把光标放到当前行末尾之后，默认情况下你是不可能做到的，但是可能通过设置 <code>virtualedit</code> 选项达到目的：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> virtualedit=<span class="keyword">all</span></span><br></pre></td></tr></table></figure>

<p>设置之后 <code>$10l</code> 或 <code>90|</code> 都会生效，即使超过了行尾的长度。</p>
<p>详见 <code>:h blockwise-examples</code>。在开始的时候可能会觉得有些复杂，但是它很快就会成为你的第二天性的。</p>
<p>如果你想探索更有趣的事情，可以看看<a href="https://github.com/terryma/vim-multiple-cursors" target="_blank" rel="noopener">多光标</a></p>
<h2 id="使用外部程序和过滤器"><a href="#使用外部程序和过滤器" class="headerlink" title="使用外部程序和过滤器"></a>使用外部程序和过滤器</h2><p>免责声明：Vim 是单线程的，因此在 Vim 中以前端进程执行其它的程序时会阻止其它的一切。当然你可以使用 Vim 程序接口，如Lua，并且使用它的多线程支持，但是在那期间， Vim 的处理还是被阻止了。Neovim 添加了任务 API 解决了此问题。</p>
<p>（据说 Bram 正在考虑在 Vim 中也添加任务控制。如果你使用了较新版本的的 Vim ，可以看一下 <code>:helpgrep startjob</code>。）</p>
<p>使用 <code>:!</code> 启动一个新任务。如果你想列出当前工作目录下的所有文件，可以使用 <code>:!ls</code>。 用 <code>|</code> 来将结果通过管道重定向，如：<code>:!ls -l | sort | tail -n5</code>。</p>
<p>没有使用范围时（译者注：范围就是 <code>:</code> 和 <code>!</code> 之间的内容，<code>.</code> 表示当前行，<code>+4</code> 表示向下偏移4行，<code>$</code> 表示最末行等，多行时用 <code>,</code> 将它们分开，如 <code>.,$</code> 表示从当前行到末行），<code>:!</code> 会显示在一个可滚动的窗口中（译者注：在 GVim 和在终端里运行的结果稍有不同）。相反的，如果指定了范围，这些行会被<a href="https://en.wikipedia.org/wiki/Filter_(software)" target="_blank" rel="noopener">过滤</a>。这意味着它们会通过管道被重定向到过滤程序的 <a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_input_.28stdin.29" target="_blank" rel="noopener">stdin</a>，在处理后再通过过滤程序的 <a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29" target="_blank" rel="noopener">stdout</a> 输出，用输出结果替换范围内的文本。例如：为接下来的5行文本添加行号，可以使用：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:.,+<span class="number">4</span>!nl -<span class="keyword">ba</span> -w1 -s<span class="string">' '</span></span><br></pre></td></tr></table></figure>

<p>由于手动添加范围很麻烦， Vim 提供了一些辅助方法以方便的添加范围。如果需要经常带着范围的话，你可以在可见模式中先选择，然后再按 <code>:</code> （译者注：选中后再按 <code>!</code> 更方便）。还可以使用 <code>!</code> 来取用一个motion的范围，如 <code>!ipsort</code> （译者注：原文为 <code>!ip!sort</code> ，但经过实验发现该命令执行报错，可能是因为 Vim 版本的原因造成的，新版本使用 <code>ip</code> 选择当前段落后自动在命令后添加了 <code>!</code> ，按照作者的写法来看，可能之前的版本没有自动添加 <code>!</code> ）可以将当前段落的所有行按字母表顺序进行排序。</p>
<p>一个使用过滤器比较好的案例是<a href="https://golang.org/" target="_blank" rel="noopener">Go语言</a>。它的缩进语法非常个性，甚至还专门提供了一个名为 <code>gofmt</code> 的过滤器来对Go语言的源文件进行正确的缩进。Go语言的插件通常会提供一个名为 <code>:Fmt</code> 的函数，这个函数就是执行了 <code>:%!gofmt</code> 来对整个文件进行缩进。</p>
<p>人们常用 <code>:r !prog</code> 将prog程序的插入放到当前行的下面，这对于脚本来说是很不错的选择，但是在使用的过程中我发现 <code>!!ls</code> 更加方便，它会用输出结果替换当前行的内容。（译者注：前面命令中的 <code>prog</code> 只是个占位符，在实际使用中需要替换成其它的程序，如 <code>:r !ls</code>，这就与后面的 <code>!!ls</code> 相对应了，两者唯一的不同是第一个命令不会覆盖当前行内容，但是第二个命令会）</p>
<p>帮助文档：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:h <span class="built_in">filter</span></span><br><span class="line">:h :read!</span><br></pre></td></tr></table></figure>

<h2 id="Cscope"><a href="#Cscope" class="headerlink" title="Cscope"></a>Cscope</h2><p><a href="http://cscope.sourceforge.net/" target="_blank" rel="noopener">Cscope</a> 的功能比 <a href="http://ctags.sourceforge.net/" target="_blank" rel="noopener">ctags</a> 要完善，但是只支持C（通过设置cscope.files后同样支持C++以及Java）。</p>
<p>鉴于Tag文件只是知道某个符号是在哪里定义的，cscope的数据库里的数据信息就多的多了：</p>
<ul>
<li>符号是在哪里定义的？</li>
<li>符号是在哪里被使用的？</li>
<li>这个全局符号定义了什么？</li>
<li>这个变量是在哪里被赋值的？</li>
<li>这个函数在源文件的哪个位置？</li>
<li>哪些函数调用了这个函数？</li>
<li>这个函数调用了哪些函数？</li>
<li>“out of space”消息是从哪来的？</li>
<li>在目录结构中当前的源文件在哪个位置？</li>
<li>哪些文件引用了这个头文件？</li>
</ul>
<h3 id="1-构建数据库"><a href="#1-构建数据库" class="headerlink" title="1. 构建数据库"></a>1. 构建数据库</h3><p>在你项目的根目录执行下面的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ cscope -bqR</span><br></pre></td></tr></table></figure>

<p>这条命令会在当前目录下创建三个文件：<code>cscope{,.in,.po}.out</code> 。把它们想象成你的数据库。</p>
<p>不幸的时 <code>cscope</code> 默认只分析 <code>*.[c|h|y|l]</code> 文件。如果你想在Java项目中使用 cscope ，需要这样做：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ find . -name <span class="string">"*.java"</span> &gt; cscope.files</span><br><span class="line">$ cscope -bq</span><br></pre></td></tr></table></figure>

<h3 id="2-添加数据库"><a href="#2-添加数据库" class="headerlink" title="2. 添加数据库"></a>2. 添加数据库</h3><p>打开你新创建的数据库连接：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">cs</span> <span class="built_in">add</span> <span class="keyword">cscope</span>.out</span><br></pre></td></tr></table></figure>

<p>检查连接已经创建成功：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">cs</span> show</span><br></pre></td></tr></table></figure>

<p>（当然你可以添加多个连接。）</p>
<h3 id="3-查询数据库"><a href="#3-查询数据库" class="headerlink" title="3. 查询数据库"></a>3. 查询数据库</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">cs</span> <span class="keyword">find</span> <span class="symbol">&lt;kind&gt;</span> <span class="symbol">&lt;query&gt;</span></span><br></pre></td></tr></table></figure>

<p>如：<code>:cs find d foo</code> 会列出 <code>foo(...)</code> 调用的所有函数。</p>
<table>
<thead>
<tr>
<th>Kind</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>s</td>
<td><strong>s</strong>ymbol：查找使用该符号的引用</td>
</tr>
<tr>
<td>g</td>
<td><strong>g</strong>lobal：查找该全局符号的定义</td>
</tr>
<tr>
<td>c</td>
<td><strong>c</strong>alls：查找调用当前方法的位置</td>
</tr>
<tr>
<td>t</td>
<td><strong>t</strong>ext：查找出现该文本的位置</td>
</tr>
<tr>
<td>e</td>
<td><strong>e</strong>grep：使用 egrep 搜索当前单词</td>
</tr>
<tr>
<td>f</td>
<td><strong>f</strong>ile：打开文件名</td>
</tr>
<tr>
<td>i</td>
<td><strong>i</strong>ncludes：查询引入了当前文件的文件</td>
</tr>
<tr>
<td>d</td>
<td><strong>d</strong>epends：查找当前方法调用的方法</td>
</tr>
</tbody></table>
<p>推荐一些比较方便的映射，如：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">cs</span> :<span class="keyword">cscope</span> <span class="keyword">find</span> s  <span class="symbol">&lt;c-r&gt;</span>=<span class="built_in">expand</span>(<span class="string">'&lt;cword&gt;'</span>)<span class="symbol">&lt;cr&gt;</span><span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">cg</span> :<span class="keyword">cscope</span> <span class="keyword">find</span> g  <span class="symbol">&lt;c-r&gt;</span>=<span class="built_in">expand</span>(<span class="string">'&lt;cword&gt;'</span>)<span class="symbol">&lt;cr&gt;</span><span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">cc</span> :<span class="keyword">cscope</span> <span class="keyword">find</span> <span class="keyword">c</span>  <span class="symbol">&lt;c-r&gt;</span>=<span class="built_in">expand</span>(<span class="string">'&lt;cword&gt;'</span>)<span class="symbol">&lt;cr&gt;</span><span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="symbol">&lt;leader&gt;</span>ct :<span class="keyword">cscope</span> <span class="keyword">find</span> t  <span class="symbol">&lt;c-r&gt;</span>=<span class="built_in">expand</span>(<span class="string">'&lt;cword&gt;'</span>)<span class="symbol">&lt;cr&gt;</span><span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">ce</span> :<span class="keyword">cscope</span> <span class="keyword">find</span> <span class="keyword">e</span>  <span class="symbol">&lt;c-r&gt;</span>=<span class="built_in">expand</span>(<span class="string">'&lt;cword&gt;'</span>)<span class="symbol">&lt;cr&gt;</span><span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">cf</span> :<span class="keyword">cscope</span> <span class="keyword">find</span> <span class="keyword">f</span>  <span class="symbol">&lt;c-r&gt;</span>=<span class="built_in">expand</span>(<span class="string">'&lt;cfile&gt;'</span>)<span class="symbol">&lt;cr&gt;</span><span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="symbol">&lt;leader&gt;</span>ci :<span class="keyword">cscope</span> <span class="keyword">find</span> i ^<span class="symbol">&lt;c-r&gt;</span>=<span class="built_in">expand</span>(<span class="string">'&lt;cfile&gt;'</span>)<span class="symbol">&lt;cr&gt;</span>$<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">cd</span> :<span class="keyword">cscope</span> <span class="keyword">find</span> d  <span class="symbol">&lt;c-r&gt;</span>=<span class="built_in">expand</span>(<span class="string">'&lt;cword&gt;'</span>)<span class="symbol">&lt;cr&gt;</span><span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure>

<p>所以 <code>:tag</code> （或 <code>&lt;c-]&gt;</code>）跳转到标签定义的文件，而 <code>:cstag</code> 可以达到同样的目的，同时还会打开 cscope 的数据库连接。<code>&#39;cscopetag&#39;</code> 选项使得 <code>:tag</code> 命令自动的像 <code>:cstag</code> 一样工作。这在你已经使用了基于标签的映射时会非常方便。</p>
<p>帮助文档：<code>:h cscope</code></p>
<h2 id="MatchIt"><a href="#MatchIt" class="headerlink" title="MatchIt"></a>MatchIt</h2><p>由于 Vim 是用 C 语言编写的，因此许多功能都假设使用类似 C 语言的语法。默认情况下，如果你的光标在 <code>{</code> 或 <code>#endif</code> , 就可以使用 <code>%</code> 跳转到与之匹配的 <code>}</code> 或 <code>#ifdef</code>。</p>
<p>Vim 自带了一个名为 matchit.vim 的插件，但是默认没有启用。启用后可以用 <code>%</code> 在HTML相匹配的标签或 VimL 的 if/else/endif 块之间进行跳转，它还带来了一些新的命令。</p>
<h3 id="在-Vim-8-中安装"><a href="#在-Vim-8-中安装" class="headerlink" title="在 Vim 8 中安装"></a>在 Vim 8 中安装</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">" vimrc</span></span><br><span class="line">packadd! matchit</span><br></pre></td></tr></table></figure>

<h3 id="在-Vim-7-或者更早的版本中安装"><a href="#在-Vim-7-或者更早的版本中安装" class="headerlink" title="在 Vim 7 或者更早的版本中安装"></a>在 Vim 7 或者更早的版本中安装</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">"vimrc</span></span><br><span class="line"><span class="keyword">runtime</span> macros/matchit.<span class="keyword">vim</span></span><br></pre></td></tr></table></figure>

<p>由于matchit的文档很全面，我建议安装以后执行一次下面的命令：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:!mkdir -<span class="keyword">p</span> ~/.<span class="keyword">vim</span>/doc</span><br><span class="line">:!cp $VIMRUNTIME/macros/matchit.<span class="keyword">vim</span> ~/.<span class="keyword">vim</span>/doc</span><br><span class="line">:<span class="keyword">helptags</span> ~/.<span class="keyword">vim</span>/doc</span><br></pre></td></tr></table></figure>

<h3 id="简短的介绍"><a href="#简短的介绍" class="headerlink" title="简短的介绍"></a>简短的介绍</h3><p>至此这个插件已经可以使用了。 参考 <code>:h matchit-intro</code> 来获得支持的命令以及 <code>:h matchit-languages</code> 来获得支持的语言。</p>
<p>你可以很方便的定义自己的匹配对，如：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">autocmd</span> FileType <span class="keyword">python</span> <span class="keyword">let</span> <span class="variable">b:match_words</span> = <span class="string">'\&lt;if\&gt;:\&lt;elif\&gt;:\&lt;else\&gt;'</span></span><br></pre></td></tr></table></figure>

<p>之后你就可以在任何的 Python 文件中使用 <code>%</code> （向前）或 <code>g%</code> （向后）在这三个片断之间跳转了。</p>
<p>帮助文档：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:h matchit-install</span><br><span class="line">:h matchit</span><br><span class="line">:h <span class="variable">b:match_words</span></span><br></pre></td></tr></table></figure>

<h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="聪明地使用-n-和-N"><a href="#聪明地使用-n-和-N" class="headerlink" title="聪明地使用 n 和 N"></a>聪明地使用 n 和 N</h2><p><kbd>n</kbd> 与 <kbd>N</kbd> 的实际跳转方向取决于使用 <code>/</code> 还是 <code>?</code> 来执行搜索，其中 <code>/</code> 是向后搜索，<code>?</code> 是向前搜索。一开始我（原作者）觉得这里很难理解。</p>
<p>如果你希望 <kbd>n</kbd> 始终为向后搜索，<kbd>N</kbd> 始终为向前搜索，那么只需要这样设置：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;expr&gt;</span> n  <span class="string">'Nn'</span>[<span class="variable">v:searchforward</span>]</span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;expr&gt;</span> <span class="keyword">N</span>  <span class="string">'nN'</span>[<span class="variable">v:searchforward</span>]</span><br></pre></td></tr></table></figure>

<h2 id="聪明地使用命令行历史"><a href="#聪明地使用命令行历史" class="headerlink" title="聪明地使用命令行历史"></a>聪明地使用命令行历史</h2><p>我（原作者）习惯用 <kbd>Ctrl</kbd> + <kbd>p</kbd> 和 <kbd>Ctrl</kbd> + <kbd>n</kbd> 来跳转到上一个/下一个条目。其实这个操作也可以用在命令行中，快速调出之前执行过的命令。</p>
<p>不仅如此，你会发现 <kbd>上</kbd> 和 <kbd>下</kbd> 其实更智能。如果命令行中已经存在了一些文字，我们可以通过按方向键来匹配已经存在的内容。比如，命令行中现在是 <code>:echo</code>，这时候我们按 <kbd>上</kbd>，就会帮我们补全成 <code>:echo &quot;Vim rocks!&quot;</code>（前提是，之前输入过这段命令）。</p>
<p>当然，Vim 用户都不愿意去按方向键，事实上我们也不需要去按，只需要设置这样的映射：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cnoremap</span> <span class="symbol">&lt;c-n&gt;</span> <span class="symbol">&lt;down&gt;</span></span><br><span class="line"><span class="keyword">cnoremap</span> <span class="symbol">&lt;c-p&gt;</span> <span class="symbol">&lt;up&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个功能，我（原作者）每天都要用很多次。</p>
<h2 id="智能-Ctrl-l"><a href="#智能-Ctrl-l" class="headerlink" title="智能 Ctrl-l"></a>智能 Ctrl-l</h2><p><kbd>Ctrl</kbd> + <kbd>l</kbd> 的默认功能是清空并「重新绘制」当前的屏幕，就和 <code>:redraw!</code> 的功能一样。下面的这个映射就是执行重新绘制，并且取消通过 <code>/</code> 和 <code>?</code> 匹配字符的高亮，而且还可以修复代码高亮问题（有时候，由于多个代码高亮的脚本重叠，或者规则过于复杂，Vim 的代码高亮显示会出现问题）。不仅如此，还可以刷新「比较模式」（请参阅 <code>:help diff-mode</code>）的代码高亮：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">l</span> :<span class="keyword">nohlsearch</span><span class="symbol">&lt;cr&gt;</span>:<span class="keyword">diffupdate</span><span class="symbol">&lt;cr&gt;</span>:<span class="keyword">syntax</span> <span class="keyword">sync</span> fromstart<span class="symbol">&lt;cr&gt;</span><span class="symbol">&lt;c-l&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="禁用错误报警声音和图标"><a href="#禁用错误报警声音和图标" class="headerlink" title="禁用错误报警声音和图标"></a>禁用错误报警声音和图标</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> noerrorbells</span><br><span class="line"><span class="keyword">set</span> novisualbell</span><br><span class="line"><span class="keyword">set</span> t_vb=</span><br></pre></td></tr></table></figure>

<p>请参阅 <a href="http://vim.wikia.com/wiki/Disable_beeping" target="_blank" rel="noopener">Vim Wiki: Disable beeping</a>。</p>
<h2 id="快速移动当前行"><a href="#快速移动当前行" class="headerlink" title="快速移动当前行"></a>快速移动当前行</h2><p>有时，我（原作者）想要快速把当前行上移或下移一行，只需要这样设置映射：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> [<span class="keyword">e</span>  :<span class="symbol">&lt;c-u&gt;</span><span class="keyword">execute</span> <span class="string">'move -1-'</span>. <span class="variable">v:count1</span><span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> ]<span class="keyword">e</span>  :<span class="symbol">&lt;c-u&gt;</span><span class="keyword">execute</span> <span class="string">'move +'</span>. <span class="variable">v:count1</span><span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个映射，同样可以搭配数字使用，比如连续按下 <kbd>2</kbd> <kbd>]</kbd> <kbd>e</kbd> 就可以把当前行向下移动两行。</p>
<h2 id="快速添加空行"><a href="#快速添加空行" class="headerlink" title="快速添加空行"></a>快速添加空行</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> [<span class="symbol">&lt;space&gt;</span>  :<span class="symbol">&lt;c-u&gt;</span>put! =<span class="built_in">repeat</span>(<span class="built_in">nr2char</span>(<span class="number">10</span>), <span class="variable">v:count1</span>)<span class="symbol">&lt;cr&gt;</span><span class="string">'[</span></span><br><span class="line"><span class="string">nnoremap ]&lt;space&gt;  :&lt;c-u&gt;put =repeat(nr2char(10), v:count1)&lt;cr&gt;</span></span><br></pre></td></tr></table></figure>

<p>设置之后，连续按下 <kbd>5</kbd> <kbd>[</kbd> <kbd>空格</kbd> 在当前行上方插入 5 个空行。</p>
<h2 id="快速编辑自定义宏"><a href="#快速编辑自定义宏" class="headerlink" title="快速编辑自定义宏"></a>快速编辑自定义宏</h2><p>这个功能真的很实用！下面的映射，就是在一个新的命令行窗口中读取某一个寄存器（默认为 <code>*</code>）。当你设置完成后，只需要按下 <kbd>回车</kbd> 即可让它生效。</p>
<p>在录制宏的时候，我经常用这个来更改拼写错误。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">m</span>  :<span class="symbol">&lt;c-u&gt;</span><span class="symbol">&lt;c-r&gt;</span><span class="symbol">&lt;c-r&gt;</span>=<span class="string">'let @'</span>. <span class="variable">v:register</span> .<span class="string">' = '</span>. <span class="built_in">string</span>(<span class="built_in">getreg</span>(<span class="variable">v:register</span>))<span class="symbol">&lt;cr&gt;</span><span class="symbol">&lt;c-f&gt;</span><span class="symbol">&lt;left&gt;</span></span><br></pre></td></tr></table></figure>

<p>只需要连续按下 <kbd>leader</kbd> <kbd>m</kbd> 或者 <kbd>"</kbd> <kbd>leader</kbd> <kbd>m</kbd> 就可以调用了。</p>
<p>请注意，这里之所以要写成 <code>&lt;c-r&gt;&lt;c-r&gt;</code> 是为了确保 <code>&lt;c-r&gt;</code> 执行了。请参阅 <code>:h c_^R^R</code></p>
<h2 id="快速跳转到源-头-文件"><a href="#快速跳转到源-头-文件" class="headerlink" title="快速跳转到源(头)文件"></a>快速跳转到源(头)文件</h2><p>这个技巧可以用在多种文件类型中。当你从源文件或者头文件中切换到其他文件的时候，这个技巧可以设置「文件标记」（请参阅 <code>:h marks</code>），然后你就可以通过连续按下 <kbd>'</kbd> <kbd>C</kbd> 或者 <kbd>'</kbd> <kbd>H</kbd> 快速跳转回去（请参阅 <code>:h &#39;A</code>）。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">autocmd</span> BufLeave *.&#123;<span class="keyword">c</span>,cpp&#125; <span class="keyword">mark</span> C</span><br><span class="line"><span class="keyword">autocmd</span> BufLeave *.h       <span class="keyword">mark</span> H</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：由于这个标记是设置在 viminfo 文件中，因此请先确认 <code>:set viminfo?</code> 中包含了 <code>:h viminfo-&#39;</code>。</p>
<h2 id="在-GUI-中快速改变字体大小"><a href="#在-GUI-中快速改变字体大小" class="headerlink" title="在 GUI 中快速改变字体大小"></a>在 GUI 中快速改变字体大小</h2><p>印象中，我（原作者）记得一下代码是来自 tpope’s 的配置文件：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">command! Bigger  :<span class="keyword">let</span> &amp;guifont = <span class="keyword">substitute</span>(&amp;guifont, <span class="string">'\d\+$'</span>, <span class="string">'\=submatch(0)+1'</span>, <span class="string">''</span>)</span><br><span class="line">command! Smaller :<span class="keyword">let</span> &amp;guifont = <span class="keyword">substitute</span>(&amp;guifont, <span class="string">'\d\+$'</span>, <span class="string">'\=submatch(0)-1'</span>, <span class="string">''</span>)</span><br></pre></td></tr></table></figure>

<h2 id="根据模式改变光标类型"><a href="#根据模式改变光标类型" class="headerlink" title="根据模式改变光标类型"></a>根据模式改变光标类型</h2><p>我（原作者）习惯在普通模式下用块状光标，在插入模式下用条状光标（形状类似英文 “I” 的样子），然后在替换模式中使用下划线形状的光标。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">empty</span>($TMUX)</span><br><span class="line">  <span class="keyword">let</span> &amp;t_SI = <span class="string">"\&lt;Esc&gt;]50;CursorShape=1\x7"</span></span><br><span class="line">  <span class="keyword">let</span> &amp;t_EI = <span class="string">"\&lt;Esc&gt;]50;CursorShape=0\x7"</span></span><br><span class="line">  <span class="keyword">let</span> &amp;t_SR = <span class="string">"\&lt;Esc&gt;]50;CursorShape=2\x7"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">let</span> &amp;t_SI = <span class="string">"\&lt;Esc&gt;Ptmux;\&lt;Esc&gt;\&lt;Esc&gt;]50;CursorShape=1\x7\&lt;Esc&gt;\\"</span></span><br><span class="line">  <span class="keyword">let</span> &amp;t_EI = <span class="string">"\&lt;Esc&gt;Ptmux;\&lt;Esc&gt;\&lt;Esc&gt;]50;CursorShape=0\x7\&lt;Esc&gt;\\"</span></span><br><span class="line">  <span class="keyword">let</span> &amp;t_SR = <span class="string">"\&lt;Esc&gt;Ptmux;\&lt;Esc&gt;\&lt;Esc&gt;]50;CursorShape=2\x7\&lt;Esc&gt;\\"</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p>原理很简单，就是让 Vim 在进入和离开插入模式的时候，输出一些序列，请参考 <a href="https://en.wikipedia.org/wiki/Escape_sequence" target="_blank" rel="noopener">escape sequence</a>。Vim 与终端之间的中间层，比如 <a href="https://tmux.github.io" target="_blank" rel="noopener">tmux</a> 会处理并执行上面的代码。</p>
<p>但上面这个还是有一个缺点的。终端环境的内部原理不尽相同，对于序列的处理方式也稍有不同。因此，上面的代码可能无法在你的环境中运行。甚至，你的运行环境也有可能不支持其他光标形状，请参阅你的 Vim 运行环境的文档。</p>
<p>好消息是，上面这个代码，可以在 iTerm2 中完美运行。</p>
<h2 id="防止水平滑动的时候失去选择"><a href="#防止水平滑动的时候失去选择" class="headerlink" title="防止水平滑动的时候失去选择"></a>防止水平滑动的时候失去选择</h2><p>如果你选中了一行或多行，那么你可以用 <kbd>&lt;</kbd> 或 <kbd>></kbd> 来调整他们的缩进。但在调整之后就不会保持选中状态了。</p>
<p>你可以连续按下 <kbd>g</kbd> <kbd>v</kbd> 来重新选中他们，请参考 <code>:h gv</code>。因此，你可以这样来配置映射：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">xnoremap</span> &lt;  &lt;<span class="keyword">gv</span></span><br><span class="line"><span class="keyword">xnoremap</span> &gt;  &gt;<span class="keyword">gv</span></span><br></pre></td></tr></table></figure>

<p>设置好之后，在可视模式中使用 <code>&gt;&gt;&gt;&gt;&gt;</code> 就不会再出现上面提到的问题了。</p>
<h2 id="重新载入保存文件"><a href="#重新载入保存文件" class="headerlink" title="重新载入保存文件"></a>重新载入保存文件</h2><p>通过<a href="#自动命令">自动命令</a>，你可以在保存文件的同时触发一些其他功能。比如，如果这个文件是一个配置文件，那么就重新载入；或者你还可以对这个文件进行代码风格检查。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">autocmd</span> BufWritePost $MYVIMRC <span class="keyword">source</span> $MYVIMRC</span><br><span class="line"><span class="keyword">autocmd</span> BufWritePost ~/.Xdefaults <span class="keyword">call</span> <span class="built_in">system</span>(<span class="string">'xrdb ~/.Xdefaults'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="更加智能的当前行高亮"><a href="#更加智能的当前行高亮" class="headerlink" title="更加智能的当前行高亮"></a>更加智能的当前行高亮</h2><p>我（原作者）很喜欢「当前行高亮」（请参阅 <code>:h cursorline</code>）这个功能，但我只想让这个效果出现在当前窗口，而且在插入模式中关闭这个效果：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">autocmd</span> InsertLeave,WinEnter * <span class="keyword">set</span> cursorline</span><br><span class="line"><span class="keyword">autocmd</span> InsertEnter,WinLeave * <span class="keyword">set</span> nocursorline</span><br></pre></td></tr></table></figure>

<h2 id="更快的关键字补全"><a href="#更快的关键字补全" class="headerlink" title="更快的关键字补全"></a>更快的关键字补全</h2><p>关键字补全（<code>&lt;c-n&gt;</code> 或 <code>&lt;c-p&gt;</code>）功能的工作方式是，无论 <code>&#39;complete&#39;</code> 设置中有什么，它都会尝试着去补全。这样，一些我们用不到的标签也会出现在补全列表中。而且，它会扫描很多文件，有时候运行起来非常慢。如果你不需要这些，那么完全可以像这样把它们禁用掉：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="built_in">complete</span>-=i   <span class="comment">" disable scanning included files</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">complete</span>-=t   <span class="comment">" disable searching tags</span></span><br></pre></td></tr></table></figure>

<h2 id="改变颜色主题的默认外观"><a href="#改变颜色主题的默认外观" class="headerlink" title="改变颜色主题的默认外观"></a>改变颜色主题的默认外观</h2><p>如果你想让状态栏在颜色主题更改后依然保持灰色，那么只需要这样设置：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">autocmd</span> ColorScheme * <span class="keyword">highlight</span> StatusLine ctermbg=darkgray cterm=NONE guibg=darkgray <span class="keyword">gui</span>=NONE</span><br></pre></td></tr></table></figure>

<p>同理，如果你想让某一个颜色主题（比如 “lucius”）的状态栏为灰色（请使用 <code>:echo color_name</code> 来查看当前可用的所有颜色主题）：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">autocmd</span> ColorScheme lucius <span class="keyword">highlight</span> StatusLine ctermbg=darkgray cterm=NONE guibg=darkgray <span class="keyword">gui</span>=NONE</span><br></pre></td></tr></table></figure>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>下面的命令都比较有用，最好了解一下。用 <code>:h :&lt;command name&gt;</code> 来了解更多关于它们的信息，如：<code>:h :global</code>。</p>
<h3 id="global-和-vglobal-在所有匹配行执行命令"><a href="#global-和-vglobal-在所有匹配行执行命令" class="headerlink" title=":global 和 :vglobal - 在所有匹配行执行命令"></a>:global 和 :vglobal - 在所有匹配行执行命令</h3><p>在所有符合条件的行上执行某个命令。如： <code>:global /regexp/ print</code> 会在所有包含 “regexp” 的行上执行 <code>print</code> 命令（译者注：regexp 有正则表达式的意思，该命令同样支持正则表达式，在所有符合正则表达式的行上执行指定的命令）。</p>
<p>趣闻：你们可能都知道老牌的 grep 命令，一个由 Ken Thompson 编写的过滤程序。它是干什么用的呢？它会输出所有匹配指定正则表达式的行！现在猜一下 <code>:global /regexp/ print</code> 的简写形式是什么？没错！就是 <code>:g/re/p</code> 。 Ken Thompsom 在编写 grep 程序的时候是受了 vi <code>:global</code> 的启发。（译者注： <a href="https://robots.thoughtbot.com/how-grep-got-its-name）" target="_blank" rel="noopener">https://robots.thoughtbot.com/how-grep-got-its-name）</a></p>
<p>既然它的名字是 <code>:global</code>，理应仅作用在所有行上，但是它也是可以带范围限制的。假设你想使用 <code>:delete</code> 命令删除从当前行到下一个空行（由正则表达式 <code>^$</code> 匹配）范围内所有包含 “foo” 的行：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:,/^$/g/foo/d</span><br></pre></td></tr></table></figure>

<p>如果要在所有 <em>不</em> 匹配的行上执行命令的话，可以使用 <code>:global!</code> 或是它的别名 <code>:vglobal</code> （ V 代表的是 inVerse ）。</p>
<h3 id="normal-和-execute-脚本梦之队"><a href="#normal-和-execute-脚本梦之队" class="headerlink" title=":normal 和 :execute - 脚本梦之队"></a>:normal 和 :execute - 脚本梦之队</h3><p>这两个命令经常在 Vim 的脚本里使用。</p>
<p>借助于 <code>:normal</code> 可以在命令行里进行普通模式的映射。如：<code>:normal! 4j</code> 会令光标下移 4 行（由于加了”!”，所以不会使用自定义的映射 “j”）。</p>
<p>需要注意的是 <code>:normal</code> 同样可以使用范围数（译者注：参考 <code>:h range</code> 和 <code>:h :normal-range</code> 了解更多），故 <code>:%norm! Iabc</code> 会在所有行前加上 “abc”。</p>
<p>借助于 <code>:execute</code> 可以将命令和表达式混合在一起使用。假设你正在编辑一个 C 语言的文件，想切换到它的头文件：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">execute</span> <span class="string">'edit'</span> <span class="built_in">fnamemodify</span>(<span class="built_in">expand</span>(<span class="string">'%'</span>), <span class="string">':r'</span>) . <span class="string">'.h'</span></span><br></pre></td></tr></table></figure>

<p>（译者注：头文件为与与源文件同名但是扩展名为 <code>.h</code> 的文件。上面的命令中 expand 获得当前文件的名称，fnamemodify 获取不带扩展名的文件名，再连上 ‘.h’ 就是头文件的文件名了，最后在使用 edit 命令打开这个头文件。）</p>
<p>这两个命令经常一起使用。假设你想让光标下移 n 行：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">let</span> n = <span class="number">4</span></span><br><span class="line">:<span class="keyword">execute</span> <span class="string">'normal!'</span> n . <span class="string">'j'</span></span><br></pre></td></tr></table></figure>

<h3 id="重定向消息"><a href="#重定向消息" class="headerlink" title="重定向消息"></a>重定向消息</h3><p>许多命令都会输出消息，<code>:redir</code> 用来重定向这些消息。它可以将消息输出到文件、<a href="#寄存器">寄存器</a>或是某个变量中。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">" 将消息重定向到变量 `neatvar` 中</span></span><br><span class="line">:<span class="keyword">redir</span> =&gt; neatvar</span><br><span class="line"><span class="comment">" 打印所有寄存器的内容</span></span><br><span class="line">:<span class="keyword">reg</span></span><br><span class="line"><span class="comment">" 结束重定向</span></span><br><span class="line">:<span class="keyword">redir</span> END</span><br><span class="line"><span class="comment">" 输出变量</span></span><br><span class="line">:<span class="keyword">echo</span> neatvar</span><br><span class="line"><span class="comment">" 恶搞一下，我们把它输出到当前缓冲区</span></span><br><span class="line">:<span class="keyword">put</span> =neatvar</span><br></pre></td></tr></table></figure>

<p>再 Vim 8 中，可以更简单的方式即位：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">:put =execute(<span class="string">'reg'</span>)</span><br></pre></td></tr></table></figure>

<p>（译者注：原文最后一条命令是 <code>:put =nicevar</code> 但是实际会报变量未定义的错误）<br>（实测 neovim/vim8 下没问题）</p>
<p>帮助文档：<code>:h :redir</code></p>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><h2 id="常规建议"><a href="#常规建议" class="headerlink" title="常规建议"></a>常规建议</h2><p>如果你遇到了奇怪的行为，尝试用这个命令重现它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vim -u NONE -N</span><br></pre></td></tr></table></figure>

<p>这样会在不引用vimrc（默认设置）的情况下重启vim，并且在 <strong>nocompatible</strong> 模式下（使用vim默认设置而不是vi的）。（搜索 <code>:h --noplugin</code> 命令了解更多启动加载方式）</p>
<p>如果仍旧能够出现该错误，那么这极有可能是vim本身的bug，请给 <a href=""https://groups.google.com/forum/#!forum/vim_dev"">vim_dev</a> 发送邮件反馈错误，多数情况下问题不会立刻解决，你还需要进一步研究</p>
<p>许多插件经常会提供新的（默认的/自动的）操作。如果在保存的时候发生了，那么请用 <code>:verb au BufWritePost</code> 命令检查潜在的问题</p>
<p>如果你在使用一个插件管理工具，将插件行注释调，再进行调试。</p>
<p>问题还没有解决？如果不是插件的问题，那么肯定是你的自定义的设置的问题，可能是你的 options 或 autocmd 等等。</p>
<p>到了一行行代码检查的时候了，不断地排除缩小检查范围知道你找出错误，根据二分法的原理你不会花费太多时间的。</p>
<p>在实践过程中，可能就是这样，把 <code>:finish</code> 放在你的 <strong>vimrc</strong> 文件中间，Vim会跳过它之后的设置。如果问题还在，那么问题就出在<code>:finish</code>之前的设置中，再把<code>:finish</code>放到前一部分设置的中间位置。否则问题就出现在它后面的半部分设置，那么就把<code>:finish</code>放到后半部分的中间位置。不断的重复即可找到。</p>
<h2 id="调整日志等级"><a href="#调整日志等级" class="headerlink" title="调整日志等级"></a>调整日志等级</h2><p>Vim现在正在使用的另一个比较有用的方法是增加debug信息输出详细等级。现在Vim支持9个等级，可以用<code>:h &#39;verbose&#39;</code>命令查看。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">e</span> /tmp/foo</span><br><span class="line">:<span class="keyword">set</span> <span class="keyword">verbose</span>=<span class="number">2</span></span><br><span class="line">:<span class="keyword">w</span></span><br><span class="line">:<span class="keyword">set</span> <span class="keyword">verbose</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这可以显示出所有引用的文件、没有变化的文件或者各种各样的作用于保存的插件。</p>
<p>如果你只是想用简单的命令来提高等级，也是用 <code>:verbose</code> ，放在其他命令之前，通过计数来指明等级，默认是1.</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">verb</span> <span class="keyword">set</span> <span class="keyword">verbose</span></span><br><span class="line"><span class="comment">"  verbose=1</span></span><br><span class="line">:<span class="number">10</span><span class="keyword">verb</span> <span class="keyword">set</span> <span class="keyword">verbose</span></span><br><span class="line"><span class="comment">"  verbose=10</span></span><br></pre></td></tr></table></figure>

<p>通常用等级1来显示上次从哪里设置的选项</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">verb</span> <span class="keyword">set</span> ai?</span><br><span class="line"><span class="comment">"      Last set from ~/.vim/vimrc</span></span><br></pre></td></tr></table></figure>

<p>一般等级越高输出信息月详细。但是不要害怕，亦可以把输出导入到文件中：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">set</span> verbosefile=/tmp/foo | <span class="number">15</span><span class="keyword">verbose</span> <span class="keyword">echo</span> <span class="string">"foo"</span> | <span class="keyword">vsplit</span> /tmp/foo</span><br></pre></td></tr></table></figure>

<p>你可以一开始的时候就打开verbosity，用 <code>-V</code> 选项，它默认设置调试等级为10。 例如：<code>vim -V5</code></p>
<h2 id="查看启动日志"><a href="#查看启动日志" class="headerlink" title="查看启动日志"></a>查看启动日志</h2><h2 id="查看运行时日志"><a href="#查看运行时日志" class="headerlink" title="查看运行时日志"></a>查看运行时日志</h2><h2 id="vim-脚本调试"><a href="#vim-脚本调试" class="headerlink" title="vim 脚本调试"></a>vim 脚本调试</h2><h2 id="语法文件调试"><a href="#语法文件调试" class="headerlink" title="语法文件调试"></a>语法文件调试</h2><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="附加资源"><a href="#附加资源" class="headerlink" title="附加资源"></a>附加资源</h2><h2 id="Vim-配置集合"><a href="#Vim-配置集合" class="headerlink" title="Vim 配置集合"></a>Vim 配置集合</h2><h2 id="内置插件"><a href="#内置插件" class="headerlink" title="内置插件"></a>内置插件</h2><h2 id="将-Control-映射到-CapsLock"><a href="#将-Control-映射到-CapsLock" class="headerlink" title="将 Control 映射到 CapsLock"></a>将 Control 映射到 CapsLock</h2><h2 id="复活节彩蛋"><a href="#复活节彩蛋" class="headerlink" title="复活节彩蛋"></a>复活节彩蛋</h2><h2 id="为何使用-hjkl"><a href="#为何使用-hjkl" class="headerlink" title="为何使用 hjkl"></a>为何使用 hjkl</h2><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="编辑小文件时很慢"><a href="#编辑小文件时很慢" class="headerlink" title="编辑小文件时很慢"></a>编辑小文件时很慢</h3><p>有两个因素对性能影响非常大：</p>
<ol>
<li><p>过于复杂的 <strong>正则表达式</strong> 。尤其是 Ruby 的语法文件，以前会造成性能下降。（见<a href="#debugging-syntax-files">调试语法文件</a>）</p>
</li>
<li><p><strong>屏幕重绘</strong> 。有一些功能会强制重绘所有行。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>典型肇事者</th>
<th>原因</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td><code>:set cursorline</code></td>
<td>会导致所有行重绘</td>
<td><code>:set nocursorline</code></td>
</tr>
<tr>
<td><code>:set cursorcolumn</code></td>
<td>会导致所有行重绘</td>
<td><code>:set nocursorcolumn</code></td>
</tr>
<tr>
<td><code>:set relativenumber</code></td>
<td>会导致所有行重绘</td>
<td><code>:set norelativenumber</code></td>
</tr>
<tr>
<td><code>:set foldmethod=syntax</code></td>
<td>如果语法文件已经很慢了，这只会变得更慢</td>
<td><code>:set foldmethod=manual</code>，<code>:set foldmethod=marker</code> 或者使用<a href="https://github.com/Konfekt/FastFold" target="_blank" rel="noopener">快速折叠</a>插件</td>
</tr>
<tr>
<td><code>:set synmaxcol=3000</code></td>
<td>由于内部表示法，Vim 处理比较长的行时会有问题。让它高亮到 3000 列……</td>
<td><code>:set synmaxcol=200</code></td>
</tr>
<tr>
<td>matchparen.vim</td>
<td>Vim 默认加载的插件，用正则表达式查找配对的括号</td>
<td>禁用插件：<code>:h matchparen</code></td>
</tr>
</tbody></table>
<p><strong>注意</strong>：只有在你真正遇到性能问题的时候才需要做上面的调整。在大多数情况下使用上面提到的选项是完全没有问题的。</p>
<h3 id="编辑大文件的时候很慢"><a href="#编辑大文件的时候很慢" class="headerlink" title="编辑大文件的时候很慢"></a>编辑大文件的时候很慢</h3><p>Vim 处理大文件最大的问题就是它会一次性读取整个文件。这么做是由于缓冲区的内部机理导致的（在 <a href="https://groups.google.com/forum/#!topic/vim_dev/oY3i8rqYGD4/discussion" target="_blank" rel="noopener">vim_dev</a> 中讨论）。</p>
<p>如果只是想查看的话，<code>tail hugefile | vim -</code> 是一个不错的选择。</p>
<p>如果你能接受没有语法高亮，并且禁用所有插件和设置的话，使用：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ vim -u NONE -N</span><br></pre></td></tr></table></figure>

<p>这将会使得跳转变快很多，尤其是省去了基于很耗费资源的正则表达式的语法高亮。你还可以告诉 Vim 不要使用交换文件和 viminfo 文件，以避免由于写这些文件而造成的延时：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ vim -n -u NONE -i NONE -N</span><br></pre></td></tr></table></figure>

<p>简而言之，尽量避免使用 Vim 写过大的文件。</p>
<h3 id="持续粘贴（为什么我每次都要设置-‘paste’-模式）"><a href="#持续粘贴（为什么我每次都要设置-‘paste’-模式）" class="headerlink" title="持续粘贴（为什么我每次都要设置 ‘paste’ 模式）"></a>持续粘贴（为什么我每次都要设置 ‘paste’ 模式）</h3><p>持续粘贴模式让终端模拟器可以区分输入内容与粘贴内容。</p>
<p>你有没有遇到过往 Vim 里粘贴代码之后被搞的一团糟？</p>
<p>这在你使用 <code>cmd+v</code>、<code>shirt-insert</code>、<code>middle-click</code> 等进行粘贴的时候才会发生。因为那样的话你只是向终端模拟器扔了一大堆的文本。 Vim 并不知道你刚刚是粘贴的文本，它以为你在飞速的输入。于是它想缩进这些行但是失败了。</p>
<p>这明显不是个问题，如果你用 Vim 的寄存器粘贴，如：<code>&quot;+p</code> ，这时 Vim 就知道了你在粘贴，就不会导致格式错乱了。</p>
<p>使用 <code>:set paste</code> 就可以解决这个问题正常进行粘贴。见 <code>:h &#39;paste&#39;</code> 和 <code>:h &#39;pastetoggle&#39;</code> 获取更多信息。</p>
<p>如果你受够了每次都要设置 <code>&#39;paste&#39;</code> 的话，看看这个能帮你自动设置的插件：<a href="https://github.com/ConradIrwin/vim-bracketed-paste" target="_blank" rel="noopener">bracketed-paste</a>。</p>
<p><a href="http://cirw.in/blog/bracketed-paste" target="_blank" rel="noopener">点此</a>查看该作者对于这个插件的更多描述。</p>
<p>Neovim 尝试把这些变得更顺畅，如果终端支持的话，它会自动开启持续粘贴模式，无须再手动进行切换。</p>
<h3 id="在终端中按-ESC-后有延时"><a href="#在终端中按-ESC-后有延时" class="headerlink" title="在终端中按 ESC 后有延时"></a>在终端中按 ESC 后有延时</h3><p>如果你经常使用命令行，那么肯定要接触 <em>终端模拟器</em> ，如 xterm、gnome-terminal、iTerm2 等等（与实际的<a href="https://en.wikipedia.org/wiki/Computer_terminal" target="_blank" rel="noopener">终端</a>不同）。</p>
<p>终端模拟器与他们的祖辈一样，使用 <a href="https://zh.wikipedia.org/wiki/%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97" target="_blank" rel="noopener">转义序列</a> （也叫 <em>控制序列</em> ）来控制光标移动、改变文本颜色等。转义序列就是以转义字符开头的 ASCII 字符串（用<a href="https://zh.wikipedia.org/wiki/%E8%84%B1%E5%AD%97%E7%AC%A6%E8%A1%A8%E7%A4%BA%E6%B3%95" target="_blank" rel="noopener">脱字符表示法</a>表示成 <code>^[</code> ）。当遇到这样的字符串后，终端模拟器会从<a href="https://en.wikipedia.org/wiki/Terminfo" target="_blank" rel="noopener">终端信息</a>数据库中查找对应的动作。</p>
<p>为了使用问题更加清晰，我会先来解释一下什么是映射超时。在映射存在歧义的时候就会产生映射超时：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">nnoremap</span> ,<span class="keyword">a</span> :<span class="keyword">echo</span> <span class="string">'foo'</span><span class="symbol">&lt;cr&gt;</span></span><br><span class="line">:<span class="keyword">nnoremap</span> ,<span class="keyword">ab</span> :<span class="keyword">echo</span> <span class="string">'bar'</span><span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中两个映射都能正常工作，但是当输入 <code>,a</code> 之后，Vim 会延时1秒，因为它要确认用户是否还要输入那个 <code>b</code>。</p>
<p>转义序列会产生同样的问题：</p>
<ul>
<li><code>&lt;esc&gt;</code> 作为返回普通模式或取消某个动作的按键而被大量使用</li>
<li>光标键使用转义序列进行的编码</li>
<li>Vim 期望 <kbd>Alt</kbd> （也叫作 <em>Mate Key</em> ）会发送一个正确的 8-bit 编码的高位，但是许多终端模拟器并不支持这个（也可能默认没有启用），而只是发送一个转义序列作为代替。</li>
</ul>
<p>你可以这样测试上面所提到的事情： <code>vim -u NONE -N</code> 然后输入 <code>i&lt;c-v&gt;&lt;left&gt;</code> ，你会看到一个以 <code>^[</code> 开头的字符串，表明这是一个转义序列，<code>^[</code> 就是转义字符。</p>
<p>简而言之，Vim 在区分录入的 <code>&lt;esc&gt;</code> 和转义序列的时候需要一定的时间。</p>
<p>默认情况下，Vim 用 <code>:set timeout timeoutlen=1000</code>，就是说它会用 1 秒的时间来区分有歧义的映射 <em>以及</em> 按键编码。这对于映射来说是一个比较合理的值，但是你可以自行定义按键延时的长短，这是解决该问题最根本的办法：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> timeout           <span class="comment">" for mappings</span></span><br><span class="line"><span class="keyword">set</span> timeoutlen=<span class="number">1000</span>   <span class="comment">" default value</span></span><br><span class="line"><span class="keyword">set</span> ttimeout          <span class="comment">" for key codes</span></span><br><span class="line"><span class="keyword">set</span> ttimeoutlen=<span class="number">10</span>    <span class="comment">" unnoticeable small value</span></span><br></pre></td></tr></table></figure>

<p>在 <code>:h ttimeout</code> 里你可以找到一个关于这些选项之间关系的小表格。</p>
<p>而如果你在 tmux 中使用 Vim 的话，别忘了把下面的配置加入到你的 <code>~/.tmux.conf</code>文件中：</p>
<pre><code>set -sg escape-time 0</code></pre><h3 id="无法重复函数中执行的搜索"><a href="#无法重复函数中执行的搜索" class="headerlink" title="无法重复函数中执行的搜索"></a>无法重复函数中执行的搜索</h3><ul>
<li>在命令中的搜索（<code>/</code>、<code>:substitute</code> 等）内容会改变“上次使用的搜索内容”。（它保存在<code>/</code>寄存器中，用 <code>:echo @/</code> 可以输出它里面的内容）</li>
<li>简单的文本变化可以通过 <code>.</code> 重做。（它保存在 <code>.</code> 寄存器，用 <code>:echo @.</code> 可以输出它的内容）</li>
</ul>
<p>而在你在函数中进行这些操作的时候，一切就会变得不同。因此你不能用 N/n 查找某个函数刚刚查找的内容，也不能重做函数中对文本的修改。</p>
<p>帮助文档：<code>:h function-search-undo</code>。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
